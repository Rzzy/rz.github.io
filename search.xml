<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6模块Modules]]></title>
    <url>%2F2018%2F01%2F03%2FES6%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[详解见：https://likebeta.gitbooks.io/es6tutorial/content/docs/module.html?q= importimport语句用于导入由另一个模块导出的绑定。 现在浏览器们才刚刚开始去实现这个功能。但它在许多转换器中已经实现，例如 Traceur Compiler ， Babel ， Rollup 或 Webpack。 语法123456789import defaultExport from "module-name";import * as name from "module-name";import &#123; export &#125; from "module-name";import &#123; export as alias &#125; from "module-name";import &#123; export1 , export2 &#125; from "module-name";import &#123; export1 , export2 as alias2 , [...] &#125; from "module-name";import defaultExport, &#123; export [ , [...] ] &#125; from "module-name";import defaultExport, * as name from "module-name";import "module-name"; name description defaultExport 将引用模块默认导出的名称。 module-name 要导入的模块。这通常是包含模块的.js文件的相对或绝对路径名，不包括.js扩展名。某些打包工具可以允许或要求使用该扩展；检查你的环境。只允许单引号和双引号的字符串。 name 引用时将用作一种命名空间的模块对象的名称。 alias, aliasN 将引用指定的导入的名称。 描述name参数是“模块对象”的名称，它将用一种名称空间来引用导出。导出参数指定单个命名导出，而import * as name语法导入所有导出。以下示例阐明该语法。 导入整个模块的内容这将myModule插入当前作用域，其中包含来自位于/modules/my-module.js文件中导出的所有模块。 1import * as myModule from '/modules/my-module.js'; 在这里，访问导出意味着使用模块名称（在这种情况下为“myModule”）作为命名空间。例如，如果上面导入的模块包含一个doAllTheAmazingThings()，你可以这样调用： 1myModule.doAllTheAmazingThings(); 导入单个导出给定一个名为myExport的对象或值，它已经从模块my-module导出（因为整个模块被导出）或显式地导出（使用export语句），将myExport插入当前作用域。 1import &#123;myExport&#125; from '/modules/my-module.js'; 导入多个导出这将foo和bar插入当前作用域。 1import &#123;foo, bar&#125; from '/modules/my-module.js'; 导入带有别名的导出导入时可以重命名导出。例如，将shortName插入当前作用域。 1import &#123;reallyReallyLongModuleExportName as shortName&#125; from '/modules/my-module.js'; 导入时重命名多个导出 使用别名导入模块的多个导出。 1234import &#123; reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short&#125; from "my-module"; 导入默认值可以使用默认export（无论是对象，函数，类等）。然后可以使用import语句来导入这样的默认值。 最简单版本，直接导入默认值： 1import myDefault from "my-module"; 也可以使用默认语法与上述（命名空间导入或命名导入）。在这种情况下，默认导入将必须首先声明。 例如： 12import myDefault, * as myModule from "my-module";// myModule used as a namespace 或者 12import myDefault, &#123;foo, bar&#125; from "my-module";// specific, named imports 示例从辅助模块导入以协助处理AJAX JSON请求。 模块：file.js从辅助模块导入以协助处理AJAX JSON请求。 123456789101112function getJSON(url, callback) &#123; let xhr = new XMLHttpRequest(); xhr.onload = function () &#123; callback(this.responseText) &#125;; xhr.open('GET', url, true); xhr.send();&#125;export function getUsefulContents(url, callback) &#123; getJSON(url, data =&gt; callback(JSON.parse(data)));&#125; 主程序：main.js 1234import &#123; getUsefulContents &#125; from '/modules/file.js';getUsefulContents('http://www.example.com', data =&gt; &#123; doSomethingUseful(data); &#125;); exportexport语句用于在创建JavaScript模块时，从模块中导出函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。 此特性目前仅在 Safari 和 Chrome 原生实现。它在许多转换器中实现，如Traceur Compiler，Babel或Rollup。 语法12345678910111213export &#123; name1, name2, …, nameN &#125;;export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;export let name1, name2, …, nameN; // also varexport let name1 = …, name2 = …, …, nameN; // also var, constexport default expression;export default function (…) &#123; … &#125; // also class, function*export default function name1(…) &#123; … &#125; // also class, function*export &#123; name1 as default, … &#125;;export * from …;export &#123; name1, name2, …, nameN &#125; from …;export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …; name description nameN 导出的标识符（用来被其他脚本的 import 导入） 描述有两种不同的导出方式，每种方式对应于上述的一种语法： 命名导出： 12345// exports a function declared earlier 导出前面声明的函数export &#123; myFunction &#125;; // exports a constant(常数)export const foo = Math.sqrt(2); 默认导出（函数）： 1export default function() &#123;&#125; 默认导出（类）： 1export default class &#123;&#125; 命名导出对导出多个值很有用。在导入期间，必须使用相应对象的相同名称。但是，可以使用任何名称导入默认导出，例如： 1234567export default k = 12; // in file test.js(在test.js 中)// -------分割线-------------import m from './test' // note that we got the freedom to use import m instead of import k, because k was default exportconsole.log(m); // will log 12 只能有一个默认的导出以下语法不会导出已导入模块中的默认导出： 1export * from …; 示例使用命名导出在模块中，我们可以使用以下代码： 123456// module "my-module.js"export function cube(x) &#123; return x * x * x;&#125;const foo = Math.PI + Math.SQRT2;export &#123; cube,foo &#125;; 这样的话，在其它脚本 (比如import)，我们可以这样使用： 123import &#123; cube, foo &#125; from 'my-module.js';console.log(cube(3)); // 27console.log(foo); // 4.555806215962888 使用默认导出如果我们要导出一个值或模块中的返回值，就可以使用默认导出： 1234// module "my-module.js"export default function cube(x) &#123; return x * x * x;&#125; 然后，在另一个脚本中，可以直接导入默认导出： 123// module "my-module.js"import cube from 'my-module';console.log(cube(3)); // 27​​​​​ 注意，不能使用var，let或const作为默认导出。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator函数详解]]></title>
    <url>%2F2018%2F01%2F03%2FGenerator%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[引用：https://likebeta.gitbooks.io/es6tutorial/content/docs/generator.html 简介基本概念 Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。 Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。 执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。 形式上，Generator函数是一个普通函数，但是有两个特征。 一是，function关键字与函数名之间有一个星号； 二是，函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。 1234567function* helloWorldGenerator() &#123;yield 'hello';yield 'world';return 'ending';&#125;var hw = helloWorldGenerator(); 上面代码定义了一个Generator函数helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello，world和return语句（结束执行）。 然后，Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象(遍历器对象（Iterator Object）)。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。 1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 上面代码一共调用了四次next方法。 第一次调用，Generator函数开始执行，直到遇到第一个yield语句为止。next方法返回一个对象，它的value属性就是当前yield语句的值hello，done属性的值false，表示遍历还没有结束。 第二次调用，Generator函数从上次yield语句停下的地方，一直执行到下一个yield语句。next方法返回的对象的value属性就是当前yield语句的值world，done属性的值false，表示遍历还没有结束。 第三次调用，Generator函数从上次yield语句停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。 第四次调用，此时Generator函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。总结一下，调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。ES6没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。 1234567function * foo(x, y) &#123; ··· &#125;function *foo(x, y) &#123; ··· &#125;function* foo(x, y) &#123; ··· &#125;function*foo(x, y) &#123; ··· &#125; 由于Generator函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。 yield语句由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。+ 如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。+ 如果该函数没有return语句，则返回的对象的value属性值为undefined。+ 需要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 123function* gen() &#123;yield 123 + 456;&#125; 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。 yield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。正常函数只能返回一个值，因为只能执行一次return；Generator函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说Generator生成了一系列的值，这也就是它的名称的来历（在英语中，generator这个词是“生成器”的意思）。+ Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。 123456789function* f() &#123;console.log('执行了！')&#125;var generator = f();setTimeout(function () &#123;generator.next()&#125;, 2000); 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个Generator函数，就变成只有调用next方法时，函数f才会执行。另外需要注意，yield语句不能用在普通函数中，否则会报错。 1234(function ()&#123;yield 1;&#125;)()// SyntaxError: Unexpected number 上面代码在一个普通函数中使用yield语句，结果产生一个句法错误。+ 下面是另外一个例子。+ 123456789101112131415var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123;a.forEach(function (item) &#123;if (typeof item !== 'number') &#123;yield* flat(item);&#125; else &#123;yield item;&#125;&#125;&#125;;for (var f of flat(arr))&#123;console.log(f);&#125; 上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield语句（这个函数里面还使用了yield*语句，这里可以不用理会，详细说明见后文）。一种修改方法是改用for循环。+ 123456789101112131415161718var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123;var length = a.length;for (var i = 0; i &lt; length; i++) &#123;var item = a[i];if (typeof item !== 'number') &#123;yield* flat(item);&#125; else &#123;yield item;&#125;&#125;&#125;;for (var f of flat(arr)) &#123;console.log(f);&#125;// 1, 2, 3, 4, 5, 6 另外，yield语句如果用在一个表达式之中，必须放在圆括号里面。+ 12345console.log('Hello' + yield); // SyntaxErrorconsole.log('Hello' + yield 123); // SyntaxErrorconsole.log('Hello' + (yield)); // OKconsole.log('Hello' + (yield 123)); // OK yield语句用作函数参数或赋值表达式的右边，可以不加括号。+ 12foo(yield 'a', yield 'b'); // OKlet input = yield; // OK 与Iterator接口的关系任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。+由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。+ 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123;yield 1;yield 2;yield 3;&#125;;[...myIterable] // [1, 2, 3] 上面代码中，Generator函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了Iterator接口，可以被…运算符遍历了。 Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。+ 12345678function* gen()&#123;// some code&#125;var g = gen();g[Symbol.iterator]() === g// true 上面代码中，gen是一个Generator函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。+ next方法的参数yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。+ 123456789101112function* f() &#123;for(var i=0; true; i++) &#123;var reset = yield i;if(reset) &#123; i = -1; &#125;&#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。+ 再看一个例子。 123456789101112131415function* foo(x) &#123;var y = 2 * (yield (x + 1));var z = yield (y / 3);return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; 上面代码中，第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN），除以3以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层。 123456789101112131415function wrapper(generatorFunction) &#123;return function (...args) &#123;let generatorObject = generatorFunction(...args);generatorObject.next();return generatorObject;&#125;;&#125;const wrapped = wrapper(function* () &#123;console.log(`First input: $&#123;yield&#125;`);return 'DONE';&#125;);wrapped().next('hello!')// First input: hello! 上面代码中，Generator函数如果不用wrapper先包一层，是无法第一次调用next方法，就输入参数的。再看一个通过next方法的参数，向Generator函数内部输入值的例子。 1234567891011121314function* dataConsumer() &#123;console.log('Started');console.log(`1. $&#123;yield&#125;`);console.log(`2. $&#123;yield&#125;`);return 'result';&#125;let genObj = dataConsumer();genObj.next();// StartedgenObj.next('a')// 1. agenObj.next('b')// 2. b 上面代码是一个很直观的例子，每次通过next方法向Generator函数输入值，然后打印出来。 for…of循环for…of循环可以自动遍历调用Generator函数时生成的Iterator对象，且此时不再需要调用next方法。 12345678910111213function *foo() &#123;yield 1;yield 2;yield 3;yield 4;yield 5;return 6;&#125;for (let v of foo()) &#123;console.log(v);&#125;// 1 2 3 4 5 上面代码使用for…of循环，依次显示5个yield语句的值。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。下面是一个利用Generator函数和for…of循环，实现斐波那契数列的例子。 123456789101112function* fibonacci() &#123;let [prev, curr] = [0, 1];for (;;) &#123;[prev, curr] = [curr, prev + curr];yield curr;&#125;&#125;for (let n of fibonacci()) &#123;if (n &gt; 1000) break;console.log(n);&#125; 从上面代码可见，使用for…of语句时不需要使用next方法。+ 前面章节曾经介绍过，for…of循环、扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们可以将Generator函数返回的Iterator对象，作为参数。+ 1234567891011121314151617181920function* numbers () &#123;yield 1yield 2return 3yield 4&#125;[...numbers()] // [1, 2]Array.from(numbers()) // [1, 2]let [x, y] = numbers();x // 1y // 2for (let n of numbers()) &#123;console.log(n)&#125;// 1// 2 利用for…of循环，可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用for…of循环，通过Generator函数为它加上这个接口，就可以用了。 123456789101112131415function* objectEntries(obj) &#123;let propKeys = Reflect.ownKeys(obj);for (let propKey of propKeys) &#123;yield [propKey, obj[propKey]];&#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123;console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 上面代码中，对象jane原生不具备Iterator接口，无法用for…of遍历。这时，我们通过Generator函数objectEntries为它加上遍历器接口，就可以用for…of遍历了。加上遍历器接口的另一种写法是，将Generator函数加到对象的Symbol.iterator属性上面。+ 1234567891011121314151617function* objectEntries() &#123;let propKeys = Object.keys(this);for (let propKey of propKeys) &#123;yield [propKey, this[propKey]];&#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123;console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe Generator.prototype.throw()Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。+ 12345678910111213141516171819var g = function* () &#123;try &#123;yield;&#125; catch (e) &#123;console.log('内部捕获', e);&#125;&#125;;var i = g();i.next();try &#123;i.throw('a');i.throw('b');&#125; catch (e) &#123;console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被Generator函数体内的catch语句捕获。i第二次抛出错误，由于Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获。+ throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。+ 123456789101112var g = function* () &#123;try &#123;yield;&#125; catch (e) &#123;console.log(e);&#125;&#125;;var i = g();i.next();i.throw(new Error('出错了！'));// Error: 出错了！(…) 注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。+ 123456789101112131415161718192021var g = function* () &#123;while (true) &#123;try &#123;yield;&#125; catch (e) &#123;if (e != 'a') throw e;console.log('内部捕获', e);&#125;&#125;&#125;;var i = g();i.next();try &#123;throw new Error('a');throw new Error('b');&#125; catch (e) &#123;console.log('外部捕获', e);&#125;// 外部捕获 [Error: a] 上面代码中，Generator函数g内部没有部署try…catch代码块，所以抛出的错误直接被外部catch代码块捕获。+ 如果Generator函数内部和外部，都没有部署try…catch代码块，那么程序将报错，直接中断执行。+ 12345678910var gen = function* gen()&#123;yield console.log('hello');yield console.log('world');&#125;var g = gen();g.next();g.throw();// hello// Uncaught undefined 上面代码中，g.throw抛出错误以后，没有任何try…catch代码块可以捕获这个错误，导致程序报错，中断执行。+ throw方法被捕获以后，会附带执行下一条yield语句。也就是说，会附带执行一次next方法。+ 1234567891011121314var gen = function* gen()&#123;try &#123;yield console.log('a');&#125; catch (e) &#123;// ...&#125;yield console.log('b');yield console.log('c');&#125;var g = gen();g.next() // ag.throw() // bg.next() // c 上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要Generator函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。 另外，throw命令与g.throw方法是无关的，两者互不影响。+ 123456789101112131415var gen = function* gen()&#123;yield console.log('hello');yield console.log('world');&#125;var g = gen();g.next();try &#123;throw new Error();&#125; catch (e) &#123;g.next();&#125;// hello// world 上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都进行了正确的操作。+ 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield语句，可以只用一个try…catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在Generator函数内部写一次catch语句就可以了。+ Generator函数体外抛出的错误，可以在函数体内捕获；反过来，Generator函数体内抛出的错误，也可以被函数体外的catch捕获。 123456789101112131415function *foo() &#123;var x = yield 3;var y = x.toUpperCase();yield y;&#125;var it = foo();it.next(); // &#123; value:3, done:false &#125;try &#123;it.next(42);&#125; catch (err) &#123;console.log(err);&#125; 上面代码中，第二个next方法向函数体内传入一个参数42，数值是没有toUpperCase方法的，所以会抛出一个TypeError错误，被函数体外的catch捕获。+ 一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了。 123456789101112131415161718192021222324252627282930313233343536373839function* g() &#123;yield 1;console.log('throwing an exception');throw new Error('generator broke!');yield 2;yield 3;&#125;function log(generator) &#123;var v;console.log('starting generator');try &#123;v = generator.next();console.log('第一次运行next方法', v);&#125; catch (err) &#123;console.log('捕捉错误', v);&#125;try &#123;v = generator.next();console.log('第二次运行next方法', v);&#125; catch (err) &#123;console.log('捕捉错误', v);&#125;try &#123;v = generator.next();console.log('第三次运行next方法', v);&#125; catch (err) &#123;console.log('捕捉错误', v);&#125;console.log('caller done');&#125;log(g());// starting generator// 第一次运行next方法 &#123; value: 1, done: false &#125;// throwing an exception// 捕捉错误 &#123; value: 1, done: false &#125;// 第三次运行next方法 &#123; value: undefined, done: true &#125;// caller done 上面代码一共三次运行next方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator函数就已经结束了，不再执行下去了。+ Generator.prototype.return()Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。+ 1234567891011function* gen() &#123;yield 1;yield 2;yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: "foo", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。 如果return方法调用时，不提供参数，则返回值的value属性为undefined。+ 12345678910function* gen() &#123;yield 1;yield 2;yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return() // &#123; value: undefined, done: true &#125; 如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。+ 1234567891011121314151617function* numbers () &#123;yield 1;try &#123;yield 2;yield 3;&#125; finally &#123;yield 4;yield 5;&#125;yield 6;&#125;var g = numbers()g.next() // &#123; done: false, value: 1 &#125;g.next() // &#123; done: false, value: 2 &#125;g.return(7) // &#123; done: false, value: 4 &#125;g.next() // &#123; done: false, value: 5 &#125;g.next() // &#123; done: true, value: 7 &#125; 上面代码中，调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法。+ yield*语句如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的。+ 12345678910111213141516function* foo() &#123;yield 'a';yield 'b';&#125;function* bar() &#123;yield 'x';foo();yield 'y';&#125;for (let v of bar())&#123;console.log(v);&#125;// "x"// "y" 上面代码中，foo和bar都是Generator函数，在bar里面调用foo，是不会有效果的。+ 这个就需要用到yield*语句，用来在一个Generator函数里面执行另一个Generator函数。 123456789101112131415161718192021222324252627282930function* bar() &#123;yield 'x';yield* foo();yield 'y';&#125;// 等同于function* bar() &#123;yield 'x';yield 'a';yield 'b';yield 'y';&#125;// 等同于function* bar() &#123;yield 'x';for (let v of foo()) &#123;yield v;&#125;yield 'y';&#125;for (let v of bar())&#123;console.log(v);&#125;// "x"// "a"// "b"// "y" 再来看一个对比的例子。 12345678910111213141516171819202122232425function* inner() &#123;yield 'hello!';&#125;function* outer1() &#123;yield 'open';yield inner();yield 'close';&#125;var gen = outer1()gen.next().value // "open"gen.next().value // 返回一个遍历器对象gen.next().value // "close"function* outer2() &#123;yield 'open'yield* inner()yield 'close'&#125;var gen = outer2()gen.next().value // "open"gen.next().value // "hello!"gen.next().value // "close" 上面例子中，outer2使用了yield*，outer1没使用。结果就是，outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值。+ 从语法角度看，如果yield命令后面跟的是一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*语句。+ 123456789101112131415161718let delegatedIterator = (function* () &#123;yield 'Hello!';yield 'Bye!';&#125;());let delegatingIterator = (function* () &#123;yield 'Greetings!';yield* delegatedIterator;yield 'Ok, bye.';&#125;());for(let value of delegatingIterator) &#123;console.log(value);&#125;// "Greetings!// "Hello!"// "Bye!"// "Ok, bye." 上面代码中，delegatingIterator是代理者，delegatedIterator是被代理者。由于yield* delegatedIterator语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。+ yield*后面的Generator函数（没有return语句时），等同于在Generator函数内部，部署一个for…of循环。+ 123456789101112131415function* concat(iter1, iter2) &#123;yield* iter1;yield* iter2;&#125;// 等同于function* concat(iter1, iter2) &#123;for (var value of iter1) &#123;yield value;&#125;for (var value of iter2) &#123;yield value;&#125;&#125; 上面代码说明，yield后面的Generator函数（没有return语句时），不过是for…of的一种简写形式，完全可以用后者替代前者。反之，则需要用var value = yield iterator的形式获取return语句的值。+ 如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。+ 12345function* gen()&#123;yield* ["a", "b", "c"];&#125;gen().next() // &#123; value:"a", done:false &#125; 上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。 实际上，任何数据结构只要有Iterator接口，就可以被yield*遍历。 1234567let read = (function* () &#123;yield 'hello';yield* 'hello';&#125;)();read.next().value // "hello"read.next().value // "h" 上面代码中，yield语句返回整个字符串，yield语句返回单个字符。因为字符串具有Iterator接口，所以被yield遍历。 如果被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据。 1234567891011121314151617181920212223242526function *foo() &#123;yield 2;yield 3;return "foo";&#125;function *bar() &#123;yield 1;var v = yield *foo();console.log( "v: " + v );yield 4;&#125;var it = bar();it.next()// &#123;value: 1, done: false&#125;it.next()// &#123;value: 2, done: false&#125;it.next()// &#123;value: 3, done: false&#125;it.next();// "v: foo"// &#123;value: 4, done: false&#125;it.next()// &#123;value: undefined, done: true&#125; 上面代码在第四次调用next方法的时候，屏幕上会有输出，这是因为函数foo的return语句，向函数bar提供了返回值。 再看一个例子。 12345678910111213function* genFuncWithReturn() &#123;yield 'a';yield 'b';return 'The result';&#125;function* logReturned(genObj) &#123;let result = yield* genObj;console.log(result);&#125;[...logReturned(genFuncWithReturn())]// The result// 值为 [ 'a', 'b' ] 上面代码中，存在两次遍历。第一次是扩展运算符遍历函数logReturned返回的遍历器对象，第二次是yield语句遍历函数genFuncWithReturn返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数genFuncWithReturn返回的遍历器对象。所以，最后的数据表达式得到的值等于[ ‘a’, ‘b’ ]。但是，函数genFuncWithReturn的return语句的返回值The result，会返回给函数logReturned内部的result变量，因此会有终端输出。yield命令可以很方便地取出嵌套数组的所有成员。+ 1234567891011121314151617181920function* iterTree(tree) &#123;if (Array.isArray(tree)) &#123;for(let i=0; i &lt; tree.length; i++) &#123;yield* iterTree(tree[i]);&#125;&#125; else &#123;yield tree;&#125;&#125;const tree = [ 'a', ['b', 'c'], ['d', 'e'] ];for(let x of iterTree(tree)) &#123;console.log(x);&#125;// a// b// c// d// e 下面是一个稍微复杂的例子，使用yield*语句遍历完全二叉树。+ 1234567891011121314151617181920212223242526272829303132333435// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123;this.left = left;this.label = label;this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123;if (t) &#123;yield* inorder(t.left);yield t.label;yield* inorder(t.right);&#125;&#125;// 下面生成二叉树function make(array) &#123;// 判断是否为叶节点if (array.length == 1) return new Tree(null, array[0], null);return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123;result.push(node);&#125;result// ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 作为对象属性的Generator函数如果一个对象的属性是Generator函数，可以简写成下面的形式。+ 12345let obj = &#123;* myGeneratorMethod() &#123;···&#125;&#125;; 上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个Generator函数。+ 它的完整形式如下，与上面的写法是等价的。+ 12345let obj = &#123;myGeneratorMethod: function* () &#123;// ···&#125;&#125;; Generator函数的thisGenerator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法。 12345678910function* g() &#123;&#125;g.prototype.hello = function () &#123;return 'hi!';&#125;;let obj = g();obj instanceof g // trueobj.hello() // 'hi!' 上面代码表明，Generator函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。+ 123456function* g() &#123;this.a = 11;&#125;let obj = g();obj.a // undefined 上面代码中，Generator函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。+ Generator函数也不能跟new命令一起用，会报错。 1234567function* F() &#123;yield this.x = 2;yield this.y = 3;&#125;new F()// TypeError: F is not a constructor 上面代码中，new命令跟构造函数F一起使用，结果报错，因为F不是构造函数。那么，有没有办法让Generator函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？下面是一个变通方法。首先，生成一个空对象，使用bind方法绑定Generator函数内部的this。这样，构造函数调用以后，这个空对象就是Generator函数的实例对象了。 123456789101112131415function* F() &#123;this.a = 1;yield this.b = 2;yield this.c = 3;&#125;var obj = &#123;&#125;;var f = F.call(obj);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;obj.a // 1obj.b // 2obj.c // 3 上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个Iterator对象。这个对象执行三次next方法（因为F内部有两个yield语句），完成F内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。+ 上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？一个办法就是将obj换成F.prototype。 1234567891011121314function* F() &#123;this.a = 1;yield this.b = 2;yield this.c = 3;&#125;var f = F.call(F.prototype);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 再将F改成构造函数，就可以对它执行new命令了。+ 12345678910111213141516171819function* gen() &#123;this.a = 1;yield this.b = 2;yield this.c = 3;&#125;function F() &#123;return gen.call(gen.prototype);&#125;var f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 含义Generator与状态机Generator是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。+ 12345678var ticking = true;var clock = function() &#123; if (ticking) console.log('Tick!'); else console.log('Tock!'); ticking = !ticking;&#125; 上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用Generator实现，就是下面这样。+ 12345678var clock = function*() &#123; while (true) &#123; console.log('Tick!'); yield; console.log('Tock!'); yield; &#125;&#125;; 上面的Generator实现与ES5实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。 Generator与协程协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。+ 协程与子例程的差异传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。+ 协程与普通线程的差异+不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。+ 由于ECMAScript是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。+ Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。+ 如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。+ 应用Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。+ 异步操作的同步化表达Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。+ 1234567891011function* loadUI() &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;var loader = loadUI();// 加载UIloader.next()// 卸载UIloader.next() 上面代码表示，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。+ Ajax是典型的异步操作，通过Generator函数部署Ajax操作，可以用同步的方式表达。+ 1234567891011121314function* main() &#123; var result = yield request("http://some.url"); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it = main();it.next(); 上面代码的main函数，就是通过Ajax操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield语句构成的表达式，本身是没有值的，总是等于undefined。+ 下面是另一个例子，通过Generator函数逐行读取文本文件。+ 12345678910function* numbers() &#123; let file = new FileReader("numbers.txt"); try &#123; while(!file.eof) &#123; yield parseInt(file.readLine(), 10); &#125; &#125; finally &#123; file.close(); &#125;&#125; 上面代码打开文本文件，使用yield语句可以手动逐行读取文件。+ 控制流管理如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。+ 123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); 采用Promise改写上面的代码。+ 12345678910Q.fcall(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量Promise的语法。Generator函数可以进一步改善代码运行流程。+ 1234567891011function* longRunningTask() &#123; try &#123; var value1 = yield step1(); var value2 = yield step2(value1); var value3 = yield step3(value2); var value4 = yield step4(value3); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125; 然后，使用一个函数，按次序自动执行所有步骤。+ 123456789101112scheduler(longRunningTask());function scheduler(task) &#123; setTimeout(function() &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125; &#125;, 0);&#125; 注意，yield语句是同步运行，不是异步运行（否则就失去了取代回调函数的设计目的了）。实际操作中，一般让yield语句返回Promise对象。+ 1234567891011var Q = require('q');function delay(milliseconds) &#123; var deferred = Q.defer(); setTimeout(deferred.resolve, milliseconds); return deferred.promise;&#125;function* f()&#123; yield delay(100);&#125;; 上面代码使用Promise的函数库Q，yield语句返回的就是一个Promise对象。如果yield语句后面的参数，是一个具有遍历器接口的对象，yield会遍历这个对象，再往下执行。这意味着，多个任务按顺序一个接一个执行时，yield语句可以按顺序排列。多个任务需要并列执行时（比如只有A任务和B任务都执行完，才能执行C任务），可以采用数组的写法。 1234567function* parallelTasks() &#123; let [resultA, resultB] = yield [ taskA(), taskB() ]; console.log(resultA, resultB);&#125; 上面代码中，yield语句的参数是一个数组，成员就是两个任务taskA和taskB，只有等这两个任务都完成了，才会接着执行下面的语句。+ 部署iterator接口利用Generator函数，可以在任意对象上部署iterator接口。+ 12345678910111213141516function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了iterator接口。也就是说，可以在任意对象上部署next方法。下面是一个对数组部署Iterator接口的例子，尽管数组原生具有这个接口。 12345678910111213function* makeSimpleGenerator(array)&#123; var nextIndex = 0; while(nextIndex &lt; array.length)&#123; yield array[nextIndex++]; &#125;&#125;var gen = makeSimpleGenerator(['yo', 'ya']);gen.next().value // 'yo'gen.next().value // 'ya'gen.next().done // true 作为数据结构Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。+ 12345function *doStuff() &#123; yield fs.readFile.bind(null, 'hello.txt'); yield fs.readFile.bind(null, 'world.txt'); yield fs.readFile.bind(null, 'and-such.txt');&#125; 上面代码就是依次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样，处理这三个返回的函数。+ 123for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125; 实际上，如果用ES5表达，完全可以用数组模拟Generator的这种用法。+ 1234567function doStuff() &#123; return [ fs.readFile.bind(null, 'hello.txt'), fs.readFile.bind(null, 'world.txt'), fs.readFile.bind(null, 'and-such.txt') ];&#125; 上面的函数，可以用一模一样的for…of循环处理！两相一比较，就不难看出Generator使得数据或者操作，具备了类似数组的接口。+]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map]]></title>
    <url>%2F2018%2F01%2F03%2Fmap%2F</url>
    <content type="text"><![CDATA[Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。引用：官方文档WeakMap详解 语法1new Map([iterable]) 参数iterable:Iterable 可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。 描述一个Map对象以插入顺序迭代其元素 — 一个 for...of 循环为每次迭代返回一个[key，value]数组。 键的相等(Key equality)键的比较是基于 &quot;SameValueZero&quot; 算法：NaN 是与 NaN 相同的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。在目前的ECMAScript规范中，-0和+0被认为是相等的，尽管这在早期的草案中并不是这样。有关详细信息，请参阅浏览器兼容性 表中的“value equality for -0 and 0”。 Objects 和 maps 的比较Object 和 Map类似的一点是,它们都允许你按键存取一个值,都可以删除键,还可以检测一个键是否绑定了值.因此,一直以来,我们都把对象当成Map来使用,不过,现在有了Map,下面的区别解释了为什么使用Map更好点. 一个对象通常都有自己的原型,所以一个对象总有一个”prototype”键。不过，从 ES5 开始可以使用 map = Object.create(null)来创建一个没有原型的对象。 一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。 你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。 但是这并不意味着你可以随意使用 Map，对象仍旧是最常用的。Map 实例只适合用于集合(collections)，你应当考虑修改你原来的代码——先前使用对象来处理集合的地方。对象应该用其字段和方法来作为记录的。 如果你不确定要使用哪个，请思考下面的问题： 在运行之前 key 是否是未知的，是否需要动态地查询 key 呢？ 是否所有的值都是统一类型，这些值可以互换么？ 是否需要不是字符串类型的 key ？ 键值对经常增加或者删除么？ 是否有任意个且非常容易改变的键值对? 这个集合可以遍历么(Is the collection iterated)? 假如以上全是“是”的话，那么你需要用Map 来保存这个集。 相反，你有固定数目的键值对，独立操作它们，区分它们的用法，那么你需要的是对象。 属性 属性 Map.length 属性 length 的值为 0 。 get Map[@@species] 本构造函数用于创建派生对象。 Map.prototype 表示 Map构造器的原型。 允许添加属性从而应用于所有的Map 对象。 Map 实例所有的 Map 对象实例都会继承 Map.prototype。 属性 Map.prototype.constructor 返回一个函数，它创建了实例的原型。默认是Map函数。 Map.prototype.size 返回Map对象的键/值对的数量。 方法 Map.prototype.clear() 移除Map对象的所有键/值对 。 Map.prototype.delete(key) 移除任何与键相关联的值，并且返回该值，该值在之前会被Map.prototype.has(key)返回为true。之后再调用Map.prototype.has(key)会返回false。 Map.prototype.entries() 返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。 Map.prototype.forEach(callbackFn[, thisArg]) 按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。 Map.prototype.get(key) 返回键对应的值，如果不存在，则返回undefined。 Map.prototype.has(key) 返回一个布尔值，表示Map实例是否包含键对应的值。 Map.prototype.keys() 返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。 Map.prototype.set(key, value) 设置Map对象中键的值。返回该Map对象。 Map.prototype.values() 返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。 Map.prototype[@@iterator]() 返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value]数组。 示例使用映射对象 12345678910111213141516171819202122var myMap = new Map();var keyObj = &#123;&#125;, keyFunc = function () &#123;&#125;, keyString = "a string";// 添加键myMap.set(keyString, "和键'a string'关联的值");myMap.set(keyObj, "和键keyObj关联的值");myMap.set(keyFunc, "和键keyFunc关联的值");myMap.size; // 3// 读取值myMap.get(keyString); // "和键'a string'关联的值"myMap.get(keyObj); // "和键keyObj关联的值"myMap.get(keyFunc); // "和键keyFunc关联的值"myMap.get("a string"); // "和键'a string'关联的值" // 因为keyString === 'a string'myMap.get(&#123;&#125;); // undefined, 因为keyObj !== &#123;&#125;myMap.get(function() &#123;&#125;) // undefined, 因为keyFunc !== function () &#123;&#125; 将NaN作为映射的键NaN也可以作为Map对象的键. 虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true), 但下面的例子表明, 两个NaN作为Map的键来说是没有区别的: 1234567var myMap = new Map();myMap.set(NaN, "not a number");myMap.get(NaN); // "not a number"var otherNaN = Number("foo");myMap.get(otherNaN); // "not a number" 使用for..of方法迭代映射映射也可以使用for..of循环来实现迭代： 12345678910111213141516171819202122var myMap = new Map();myMap.set(0, "zero");myMap.set(1, "one");for (var [key, value] of myMap) &#123; console.log(key + " = " + value);&#125;// 将会显示两个log。一个是"0 = zero"另一个是"1 = one"for (var key of myMap.keys()) &#123; console.log(key);&#125;// 将会显示两个log。 一个是 "0" 另一个是 "1"for (var value of myMap.values()) &#123; console.log(value);&#125;// 将会显示两个log。 一个是 "zero" 另一个是 "one"for (var [key, value] of myMap.entries()) &#123; console.log(key + " = " + value);&#125;// 将会显示两个log。 一个是 "0 = zero" 另一个是 "1 = one" 使用forEach()方法迭代映射映射也可以通过forEach()方法迭代： 1234myMap.forEach(function(value, key) &#123; console.log(key + " = " + value);&#125;, myMap)// 将会显示两个logs。 一个是 "0 = zero" 另一个是 "1 = one" 映射与数组对象的关系 123456789101112var kvArray = [["key1", "value1"], ["key2", "value2"]];// 使用映射对象常规的构造函数将一个二维键值对数组对象转换成一个映射关系var myMap = new Map(kvArray);myMap.get("key1"); // 返回值为 "value1"// 使用展开运算符将一个映射关系转换成一个二维键值对数组对象console.log(uneval([...myMap])); // 将会向您显示和kvArray相同的数组// 或者使用展开运算符作用在键或者值的迭代器上，进而得到只含有键或者值得数组console.log(uneval([...myMap.keys()])); // 输出 ["key1", "key2"]]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承中方法属性的重写]]></title>
    <url>%2F2018%2F01%2F02%2Fji-cheng-zhong-fang-fa-shu-xing-de-zhong-xie%2F</url>
    <content type="text"><![CDATA[继承中方法属性的重写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163function F()&#123;&#125;;var f = new F();f.name = "cf";f.hasOwnProperty("name");//trueF.prototype.age = 22;f.hasOwnProperty("age");//false,age是原型对象的属性，name是F对象的属性，不是同一个。hasOwnProperty是对象的方法F.prototype.isPrototypeOf(f);//true//多态：编译时多态，运行时多态：方法重载、重写//js不支持同名的方法var o = &#123;run:function()&#123;&#125;,run:function()&#123;&#125;, //js同名会覆盖，run指向的是这个函数对象的地址，地址名加小括号就是这个类对象开始执行。function F()&#123;&#125; 既是类也是对象，new F()说明是一个类，F()函数名加小括号就是函数执行，说明是一个对象。&#125;=======================================================================function demo (a,b) &#123; console.log(demo.length);//形参个数，2 console.log(arguments.length);//实参个数，3 console.log(arguments[0]); console.log(arguments[1]);&#125;demo(4,5,6);function add()&#123; var total = 0; for (var i = arguments.length - 1; i &gt;= 0; i--) &#123; total += arguments[i]; &#125;; return total;&#125;console.log(add(1));console.log(add(1,2));//可变长度function fontSize()&#123; var ele = document.getElementById("js"); if (arguments.length == 0)&#123; return ele.style.fontSize; &#125;else&#123; ele.style.fontSize = arguments[0]; &#125;&#125;fontSize(18);console.log(fontSize());function setting()&#123; var ele = document.getElementById("js"); if (typeof arguments[0] ==="object")&#123; for(p in arguments[0])&#123;//p是key,arguments[p]是value, ele.style[p] = arguments[0][p]; &#125; &#125;else&#123; ele.style.fontSize = arguments[0]; ele.style.backgroundColor= arguments[1]; &#125;&#125;setting(18,"red");setting(&#123;fontSize:20,backgroundColor:"green"&#125;);//js里面不能写同名的方法，所以只能够对方法的参数做判断，==========================================================================function demo(o)&#123;//demo是一个类，o是类的对象属性 o.run();//调用属性的方法&#125;var o = &#123;run:function()&#123; console.log("o is running...");&#125;&#125;;demo(o);//类调用，java里面类不可以调用,这是跟java不一样的。var p =&#123;run:function()&#123; console.log("p is running...");&#125;&#125;;demo(p);//函数是一个类也是一个对象，函数调用对象就会执行起来。function F()&#123;&#125;;var f = new F();F.prototype.run = function()&#123;console.log("111");&#125;//原型区域，对象. 可以访问f.run();//111f.run = function()&#123;console.log("222");&#125;;//只是给f自己加了一个方法，没有改变类的原型对象，相当于方法的重写。f.什么都是给自己对象加的f.run();//222F.prototype.run();//111f.run = function()&#123;//run指向一个对象的地址 console.log("222"); F.prototype.run();//重写父的，并且还要调用父的，&#125;;f.run();//222 , 111=======================================================================function Parent()&#123; this.run = function()&#123;//现在把Parent当成类看，run是一个对象的地址， console.log("parent is running..."); &#125;&#125;function Child()&#123; Parent.call(this);//继承父的方法,相当于父有了一个run方法，this.run = function()&#123;console.log("parent is running...");&#125;，但是2个方法不是同一个，只是相当于把父的属性和方法在这里写了一遍。 var parentRun = this.run;//用this,parentRun指向run函数的地址， this.run = function ()&#123;//run重新指向，重写，添加同名的子类方法 console.log("child is running..."); parentRun();//地址名小括号就是对象的执行 &#125;&#125;var c = new Child();//Child看成是类，c是对象c.run();//run是函数的地址，地址小括号就是对象执行========================================================================function Parent()&#123; this.name = "333";//只能通过 对象.name 访问 var age = 34;//给嵌套函数使用&#125;var p = new Parent();console.log(p.name);//333console.log(Parent.name);//Parentconsole.log(p.age);//undefined, console.log(Parent.age);//undefined, Parent.aa = "aa"; //静态属性，对象. 访问不到，类. 访问得到Parent.prototype.aaa = "asa";//原型公有区域，对象. 访问得到，类. 访问不到console.log(p.aa);//undefined，console.log(Parent.aa);//aaconsole.log(p.aaa);//asa，console.log(Parent.aaa);//undefinedp.zz = "zz";//只是加给了对象自己，没有加给类和类的原型console.log(p.zz);//zzconsole.log(Parent.zz);//undefinedconsole.log(Parent.prototype.zz)//undefin==========================================================================function Parent()&#123;&#125;Parent.prototype.run = function() &#123; console.log("parent");&#125;;Child.prototype = Object.create(Parent.prototype);//继承Child.prototype.constructor = Child;//修正Child.super = Parent.prototype; //给Child增加静态属性function Child()&#123;&#125;Child.prototype.run=function()&#123; console.log('child is running...'); Child.super.run();&#125;var c = new Child();c.run(); 类里面的this.属性给对象用的，静态属性、方法给类用，什么都不加的和var给嵌套函数用，什么都不加的在window对象中。（静态属性、方法通过F.xx 添加） 对象的静态属性、方法给自己用。（静态属性、方法通过 p.xx 添加） 原型里面的属性、方法是给对象和原型自己用的。（通过 F.prototype.xx 添加） 123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; function F()&#123; this.name = "yw"; var age = 32; sch = 890; &#125; var f = new F(); alert(f.name);//yw alert(f.age);//undefined alert(f.sch);//undefined F.kr = "gh"; F.ss = function()&#123;alert(123);&#125; alert(f.kr);//undefined f.ss();//f.ss is not a function alert(F.prototype.kr);//undefined F.prototype.ss();//F.prototype.ss is not a function f.a = "a"; f.y = function()&#123;alert("y");&#125; alert(F.a);//undefined F.y();//F.y is not a function alert(F.prototype.a);//undefined F.prototype.y();//F.prototype.y is not a function F.prototype.o = "o"; F.prototype.oo = function()&#123;alert("oo");&#125; alert(f.o);//o f.oo();//oo alert(F.o);//undefined F.oo();//F.oo is not a function&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set详解]]></title>
    <url>%2F2018%2F01%2F02%2Fset-and-map%2F</url>
    <content type="text"><![CDATA[Set Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 引用：官方文档 语法 1new Set([iterable]); 参数iterable如果传递一个可迭代对象，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的Set为空。 返回值一个新的Set对象。 简述Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。 值的相等因为 Set 中的值总是唯一的，所以需要判断两个值是否相等。在ECMAScript规范的早期版本中，这不是基于和===操作符中使用的算法相同的算法。具体来说，对于Set s， +0 （+0 严格相等于-0）和-0是不同的值。然而，在 ECMAScript 2015规范中这点已被更改。有关详细信息，请参阅浏览器兼容性 表中的“value equality for -0 and 0”。 另外，NaN和undefined都可以被存储在Set 中， NaN之间被视为相同的值（尽管 NaN !== NaN）。 属性Set.length:length属性的值为0。 get Set[@@species]:构造函数用来创建派生对象. Set.prototype:表示Set构造器的原型，允许向所有Set对象添加新的属性。 Set实例所有Set实例继承自 Set.prototype。 属性 属性 introduce Set.prototype.constructor 返回实例的构造函数。默认情况下是Set Set.prototype.size 返回Set对象的值的个数 方法 方法 introduce Set.prototype.add(value) 在Set对象尾部添加一个元素。返回该Set对象。 Set.prototype.clear() 移除Set对象内的所有元素。 Set.prototype.delete(value) 移除Set的中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。Set.prototype.has(value)在此后会返回false。 Set.prototype.entries() 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。 Set.prototype.forEach(callbackFn[, thisArg]) 按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。 Set.prototype.has(value) 返回一个布尔值，表示该值在Set中存在与否。 Set.prototype.keys() 与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。 Set.prototype.values() 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。 Set.prototype[@@iterator]() 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。 示例使用Set对象 12345678910111213141516171819202122232425let mySet = new Set();mySet.add(1); // Set(1) &#123;1&#125;mySet.add(5); // Set(2) &#123;1, 5&#125;mySet.add(5); // Set &#123; 1, 5 &#125;mySet.add("some text"); // Set(3) &#123;1, 5, "some text"&#125;var o = &#123;a: 1, b: 2&#125;;mySet.add(o);mySet.add(&#123;a: 1, b: 2&#125;); // o 指向的是不同的对象，所以没问题mySet.has(1); // truemySet.has(3); // falsemySet.has(5); // truemySet.has(Math.sqrt(25)); // truemySet.has("Some Text".toLowerCase()); // truemySet.has(o); // truemySet.size; // 5mySet.delete(5); // true, 从set中移除5mySet.has(5); // false, 5已经被移除mySet.size; // 4, 刚刚移除一个值console.log(mySet); // Set &#123;1, "some text", Object &#123;a: 1, b: 2&#125;, Object &#123;a: 1, b: 2&#125;&#125; Set不支持索引 1234arr.indexOf('a') !== -1 //慢//truesetOfWords.has('a') //快 //true 迭代Set 12345678910111213141516171819202122232425262728293031323334353637383940414243// 迭代整个set// 按顺序输出：1, "some text" for (let item of mySet) console.log(item);// 按顺序输出：1, "some text" for (let item of mySet.keys()) console.log(item);// 按顺序输出：1, "some text" for (let item of mySet.values()) console.log(item);// 按顺序输出：1, "some text" //(键与值相等)for (let [key, value] of mySet.entries()) console.log(key);// 转换Set为Array (with Array comprehensions)var myArr = [v for (v of mySet)]; // [1, "some text"]// 替代方案(with Array.from)var myArr = Array.from(mySet); // [1, "some text"]// 如果在HTML文档中工作，也可以：mySet.add(document.body);mySet.has(document.querySelector("body")); // true// Set 和 Array互换mySet2 = new Set([1,2,3,4]);mySet2.size; // 4[...mySet2]; // [1,2,3,4]// intersect can be simulated via var intersection = new Set([...set1].filter(x =&gt; set2.has(x))); // 新的迭代器对象// difference can be simulated viavar difference = new Set([...set1].filter(x =&gt; !set2.has(x)));// 用forEach迭代mySet.forEach(function(value) &#123; console.log(value);&#125;);// 1// 2// 3// 4 Array 相关 123456789var myArray = ["value1", "value2", "value3"];// 用Set构造器将Array转换为Setvar mySet = new Set(myArray);mySet.has("value1"); // returns true// 用...(展开操作符)操作符将Set转换为Arrayconsole.log([...mySet]); // 与myArray完全一致 String 相关 1234var text = 'Indiana';var mySet = new Set(text); // Set &#123;'I', 'n', 'd', 'i', 'a'&#125;mySet.size; // 5]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class详解]]></title>
    <url>%2F2018%2F01%2F01%2Fclass%2F</url>
    <content type="text"><![CDATA[转载：http://www.cnblogs.com/E-WALKER/p/4796278.html Overview借助class 我们可以写出这样的代码: 12345678910111213141516171819202122232425class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); this.color = color; &#125; toString() &#123; return super.toString() + ' in ' + this.color; &#125;&#125;let cp = new ColorPoint(25, 8, 'green');cp.toString(); // '(25, 8) in green'console.log(cp instanceof ColorPoint); // trueconsole.log(cp instanceof Point); // true Base classes我们可以定义如下的class: 123456789class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 我们可以像使用ES5标准中的constructor一样实例化class 123var p = new Point(25, 8);p.toString();// '(25, 8)' 实际上，class还是用function实现的，并没有为js创造一个全新的class体系。 12typeof Point'function' 但是，与function相比，它是不能直接调用的，也就是说必须得new出来 12Point()TypeError: Classes can’t be function-called 另外，它不会像function一样会被hoisted(原因是语义阶段无法解析到extends的内容) 1234567foo(); // works, because `foo` is hoistedfunction foo() &#123;&#125;new Foo(); // ReferenceErrorclass Foo &#123;&#125; 123456789function functionThatUsesBar() &#123; new Bar();&#125;functionThatUsesBar(); // ReferenceErrorclass Bar &#123;&#125;functionThatUsesBar(); // OK 与函数一样，class的定义表达式也有两种，声明形式、表达式形式。之前用的都是声明形式，以下是表达式式的: 12345678910const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;;let inst = new MyClass();console.log(inst.getClassName()); // Meconsole.log(Me.name); // ReferenceError: Me is not defined Inside the body of a class definitionclass定义体是只能包含方法，不能包含属性的(标准定义组织认为原型链中不应包含属性)，属性被写在constructor中。以下是三种会用到的方法(constructor 、static method、 prototype method)： 123456789101112class Foo &#123; constructor(prop) &#123; this.prop = prop; &#125; static staticMethod() &#123; return 'classy'; &#125; prototypeMethod() &#123; return 'prototypical'; &#125;&#125;let foo = new Foo(123); 如下图([[Prototype]]代表着继承关系)当对象被new出来，拿的是Foo.prototype : Object分支，从而可以调prototype method constructor，这个方法本身，代表了class 12Foo === Foo.prototype.constructor// true constructor有时被称为类构造器。相较于ES5，它可以调用父类的constructor(使用super())。static methods,它们归属于类本身，即类方法 1234typeof Foo.staticMethod'function'Foo.staticMethod()'classy' 关于 Getters and setters，它们的语法如下: 12345678910111213141516class MyClass &#123; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop//'getter' 方法名是可以动态生成的 123456789101112class Foo() &#123; myMethod() &#123;&#125;&#125;class Foo() &#123; ['my'+'Method']() &#123;&#125;&#125;const m = 'myMethod';class Foo() &#123; [m]() &#123;&#125;&#125; 增加了迭代器的支持，需要给方法前面加一个* 1234567891011121314151617class IterableArguments &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new IterableArguments('hello', 'world')) &#123; console.log(x);&#125;// hello// world Subclassing通过extends，我们可以继承其它实现constructor的函数或对象。需要注意一下，constructor与非constructor调用父类方法的途径是不同的。 123456789101112131415161718192021222324252627282930class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // (A) this.color = color; &#125; toString() &#123; return super.toString() + ' in ' + this.color; // (B) &#125;&#125;let cp = new ColorPoint(25, 8, 'green');cp.toString()'(25, 8) in green'cp instanceof ColorPoint// truecp instanceof Point// true 子类的原型就是它的父类 123Object.getPrototypeOf(ColorPoint) === Point// true 所以，static method也被继承了 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod(); // 'hello' static方法也是支持调用父类的。 123456789101112class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod(); // 'hello, too' 关于子类中使用构造器，需要注意的是，调用this之前，需要调用super() 12345678910class Foo &#123;&#125; class Bar extends Foo &#123; constructor(num) &#123; let tmp = num * 2; // OK this.num = num; // ReferenceError super(); this.num = num; // OK &#125;&#125; constructors是可以被显示覆盖(override)的。 123456class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;console.log(new Foo() instanceof Foo); // false Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。Object.create() 如果基类中不显示定义constructor，引擎会生成如下代码 1constructor() &#123;&#125; 对于子类 123constructor(...args) &#123; super(...args);&#125; The details of classes 类名不能为eval 或者 arguments，不能有重复的类名，constructor不支持getter,setter。 classes不能像函数一样调用。 原型方法不能用作构造器： 1234class C &#123; m() &#123;&#125;&#125;new C.prototype.m(); // TypeError The details of subclassingES 6中,子类的使用方法如下: 1234567891011121314151617class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; ···&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); this.color = color; &#125; ···&#125;let cp = new ColorPoint(25, 8, 'green'); 原型链实现: 12345678910111213const getProto = Object.getPrototypeOf.bind(Object);getProto(Point) === Function.prototype// truegetProto(function () &#123;&#125;) === Function.prototype// truegetProto(Point.prototype) === Object.prototype// truegetProto(&#123;&#125;) === Object.prototype// true]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入解析 ES6：Symbol]]></title>
    <url>%2F2018%2F01%2F01%2Fsymbol%2F</url>
    <content type="text"><![CDATA[深入解析 ES6：Symbol 引用：http://bubkoo.com/2015/07/24/es6-in-depth-symbols/ Symbol 是什么？ 12typeof Symbol()"symbol" JavaScript 在 1997 年被标准化时，就有 6 种数据类型，直到 ES6 出现之前，程序中的变量一定是以下 6 种数据类型之一： Undefined Null Boolean Number String Object 而symbol则是javascript中的第七种数据类型 Symbol 是完全不一样的东西。一旦创建后就不可更改，不能对它们设置属性（如果在严格模式下尝试这样做，你将得到一个 TypeError）。它们可以作为属性名，这时它们和字符串的属性名没有什么区别。 每个 Symbol 都是独一无二的，不与其它 Symbol 重复（即便是使用相同的 Symbol 描述创建），创建一个 Symbol 就跟创建一个对象一样方便。 ES6 中的 Symbol与传统语言（如 Lisp 和 Ruby）中的 Symbol 中的类似，但并不是完全照搬到 JavaScript 中。在 Lisp 中，所有标识符都是 Symbol；在 JavaScript 中，标识符和大多数属性仍然是字符串，Symbol 只是提供了一个额外的选择。 值得注意的是：与其它类型不同的是，Symbol 不能自动被转换为字符串，当尝试将一个 Symbol 强制转换为字符串时，将返回一个 TypeError。 12345&gt; var sym = Symbol("&lt;3");&gt; "your symbol is " + sym// TypeError: can't convert symbol to string&gt; `your symbol is $&#123;sym&#125;`// TypeError: can't convert symbol to string 应该避免这样的强制转换，应该使用 String(sym) 或 sym.toString() 来转换。 获取 Symbol 的三种方法 Symbol() 每次调用时都返回一个唯一的 Symbol。 Symbol.for(string) 从 Symbol注册表中返回相应的 Symbol，与上个方法不同的是，Symbol注册表中的 Symbol 是共享的。也就是说，如果你调用 Symbol.for(&quot;cat&quot;) 三次，都将返回相同的 Symbol。当不同页面或同一页面不同模块需要共享 Symbol 时，注册表就非常有用。 Symbol.iterator 返回语言预定义的一些 Symbol，每个都有其特殊的用途。 如果你仍不确定 Symbol 是否有用，那么接下来的内容将非常有趣，因为我将为你演示 Symbol 的实际应用。 Symbol 在 ES6 规范中的应用 可以使用 Symbol 来避免代码冲突。 在使用 iterator 时，我们解析for (var item of myArray) 内部是以调用 myArray[Symbol.iterator]() 开始的，这个方法可以使用 myArray.iterator() 来代替，但是使用 Symbol 的后向兼容性更好。 在 ES6 中还有一些地方使用到了 Symbol。（这些特性还没有在 FireFox 中实现。） 使 instanceof 可扩展。在 ES6中，object instanceof constructor 表达式被标准化为构造函数的一个方法：constructor[Symbol.hasInstance](object)，这意味着它是可扩展的。 消除新特性和旧代码之间的冲突。 支持新类型的字符串匹配。在 ES5 中，调用 str.match(myObject) 时，首先会尝试将 myObject转换为 RegExp对象。在 ES6中，首先将检查 myObject中是否有 myObject[Symbol.match](str) 方法，在所有正则表达式工作的地方都可以提供一个自定义的字符串解析方法。 这些用途还比较窄，但仅仅通过我文章中的代码很难看到这些新特性产生的重大影响。JavaScript 的 Symbol 是 PHP 和 Python 中 __doubleUnderscores 的改进版本，标准组织将使用它来为语言添加新特性，而不会对已有代码产生影响。 案例一个布尔值引出的问题：有时，把一些属于其他对象的数据暂存在另一个对象中是非常方便的。例如，假设你正在编写一个 JS 库，使用 CSS 中的 transition 来让一个 DOM元素在屏幕上飞奔，你已经知道不能同时将多个 transition 应用在同一个 div上，否则将使得动画非常不美观，你也确实有办法来解决这个问题，但是首先你需要知道该 div是否已经在移动中。 怎么解决这个问题呢？ 其中一个方法是使用浏览器提供的 API 来探测元素是否处于动画状态，但杀鸡焉用牛刀，在将元素设置为移动时，你的库就知道了该元素正在移动。 你真正需要的是一种机制来跟踪哪些元素正在移动，你可以将正在移动的元素保存在一个数组中，每次要为一个元素设置动画时，首先检查一下这个元素是否已经在这个列表中。 啊哈，但是如果你的数组非常庞大，即便是这样的线性搜索也会产生性能问题。 那么，你真正想做的就是直接在元素上设置一个标志： 1234if (element.isMoving) &#123; smoothAnimations(element);&#125;element.isMoving = true; 这也有一些潜在的问题，不得不承认这样一个事实：还有其他代码也可能操作该 ODM 元素。 在其他代码中，你创建的属性会被 for-in 或 Object.keys() 枚举出来； 在其他一些库中也许已经使用了同样的方式（在元素上设置了相同的属性），那么这将和你的代码发生冲突，产生不可预计的结果； 其他一些库可能在将来会使用同样的方式，这也会与你的代码发生冲突； 标准委员会可能会为每个元素添加一个 .isMoving() 原生方法，那么你的代码就彻底不能工作了。 当然，对于最后三个问题，你可以选择一个无意义的不会有人会使用到的字符串： 1234if (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) &#123; smoothAnimations(element);&#125;element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true; 这似乎太不靠谱了，看了让人眼睛痛。 你还可以用加密算法来生成一个几乎唯一的字符串： 1234567// get 1024 Unicode characters of gibberishvar isMoving = SecureRandom.generateName();...if (element[isMoving]) &#123; smoothAnimations(element);&#125;element[isMoving] = true; object[name] 语法允许我们将任何字符串作为属性名，代码能正常工作，冲突几乎是不可能了，代码看起来也美观多了。但是，这回导致糟糕的调试体验，每次使用 console.log() 打印出包含该属性的元素时，你回看到一个庞大的垃圾字符串，并且如果还不止一个这样的属性呢？每次刷新后属性名都发生了变化，怎么样使这些属性看起来更加直观呢？ 为什么这么难？我们只是为了保存一个小小的标志位。 用 Symbol 来解决问题 Symbol 值可以由程序创建，并可以作为属性名，而且不用担心属性名冲突。 1var mySymbol = Symbol(); 调用 Symbol() 方法将创建一个新的 Symbol 类型的值，并且该值不与其它任何值相等。与数字和字符串一样，Symbol 类型的值也可以作为对象的属性名，正是由于它不与任何其它值相等，对应的属性也不会发生冲突： 12obj[mySymbol] = "ok!"; // guaranteed not to collideconsole.log(obj[mySymbol]); // ok! 下面是使用 Symbol 来解决上面的问题： 1234567// create a unique symbolvar isMoving = Symbol("isMoving");...if (element[isMoving]) &#123; smoothAnimations(element);&#125;element[isMoving] = true; 上面代码需要注意几点： 方法 Symbol(&quot;isMoving&quot;) 中的 &quot;isMoving&quot; 字符串被称为 Symbol的描述信息，这对调试非常有帮助。可以通过 console.log(isMoving) 打印出来，或通过 isMoving.toString() 将 isMoving 转换为字符串时，或在一些错误信息中显示出来。 element[isMoving] 访问的是 symbol-keyed 属性，除了属性名是 Symbol 类型的值之外，与其它属性都一样。 和数组一样，symbol-keyed 属性不能通过 . 操作符来访问，必须使用方括号的方式。 操作 symbol-keyed 属性也非常方便，通过上面代码我们已经知道如何获取和设置 element[isMoving] 的值，我们还可以这样使用：if (isMoving in element) 或 delete element[isMoving]。 另一方面，只有在 isMoving 的作用域范围内才可以使用上述代码，这可以实现弱封装机制：在一个模块内创建一些Symbol，只有在该模块内部的对象才能使用，而不用担心与其它模块的代码发生冲突。 由于 Symbol 的设计初衷是为了避免冲突，当遍历 JavaScript对象时，并不会枚举到以 Symbol 作为建的属性，比如，for-in 循环只会遍历到以字符串作为键的属性，Object.keys(obj) 和 Object.getOwnPropertyNames(obj) 也一样，但这并不意味着 Symbol 为键的属性是不可枚举的：使用 Object.getOwnPropertySymbols(obj) 这个新方法可以枚举出来，还有 Reflect.ownKeys(obj) 这个新方法可以返回对象中所有字符串和 Symbol键。 库和框架的设计者将会发现很多 Symbol 的用途，JavaScript语言本身也对其有广泛的应用。 兼容性对于还没有原生支持 Symbol 的浏览器，你可以使用 polyfill，如 core.js，但该 polyfill 实现并不完美，请阅读注意事项。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板字符串]]></title>
    <url>%2F2018%2F01%2F01%2Fmo-ban-zi-fu-chuan%2F</url>
    <content type="text"><![CDATA[模板字符串 模板字面量/Template literals 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串/template strings”。 语法 12345678`string text``string text line 1 string text line 2``string text $&#123;expression&#125; string text`tag `string text $&#123;expression&#125; string text` Note: 模板字面量也可以使用三元运算符( condition ? true : false ) 和 嵌套 nested！ 描述 模板字符串使用反引号 () 来代替普通字符串中的用双引号和单引号。 模板字符串可以包含特定语法(${expression})的占位符。 占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。 1`\`` === "`" // --&gt; true 多行字符串在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串： 1234console.log("string text line 1\n\string text line 2");// "string text line 1// string text line 2" 要获得同样效果的多行字符串，只需使用如下代码： 1234console.log(`string text line 1string text line 2`);// "string text line 1// string text line 2" 表达式插补在普通字符串中嵌入表达式，必须使用如下语法： 12345var a = 5;var b = 10;console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");// "Fifteen is 15 and// not 20." 现在通过模板字符串，我们可以使用一种更优雅的方式来表示： 12345var a = 5;var b = 10;console.log(`Fifteen is $&#123;a + b&#125; and\nnot $&#123;2 * a + b&#125;.`);// "Fifteen is 15 and// not 20." 带标签的模板字符串更高级的形式的模板字面值被标记模板文本。标记使您可以分析模板文本功能。标记功能的第一个参数包含一个字符串值的数组。其余的参数是相关的表达式。最后，你的函数可以返回处理好的的字符串 （或者它可以返回完全不同的东西 , 如下例所述）。用于该标记的函数的名称可以被命名为任何你想要的东西。 12345678910111213141516171819202122232425262728var person = 'Mike';var age = 28;function myTag(strings, personExp, ageExp) &#123; var str0 = strings[0]; // "that " var str1 = strings[1]; // " is a " // 在技术上,有一个字符串在 // 最终的表达式 (在我们的例子中)的后面, // 但它是空的(""), 所以被忽略. // var str2 = strings[2]; var ageStr; if (ageExp &gt; 60)&#123; ageStr = 'old person'; &#125; else &#123; ageStr = 'young person'; &#125; return str0 + personExp + str1 + ageStr;&#125;var output = myTag`that $&#123; person &#125; is a $&#123; age &#125;`;console.log(output); // that Mike is a young person 12345678910111213141516171819202122232425262728//show函数采用rest参数的写法如下：let name = '张三', age = 20, message = show`我来给大家介绍:$&#123;name&#125;的年龄是$&#123;age&#125;.`;function show(stringArr,...values)&#123; let output =""; let index = 0 for(;index&lt;values.length;index++)&#123; output += stringArr[index]+values[index]; &#125; output += stringArr[index]; return output;&#125;message; //"我来给大家介绍:张三的年龄是20." 正如下面例子所展示的，标签函数并不一定需要返回一个字符串。 12345678910111213141516171819function template(strings, ...keys) &#123; return (function(...values) &#123; var dict = values[values.length - 1] || &#123;&#125;; var result = [strings[0]]; keys.forEach(function(key, i) &#123; var value = Number.isInteger(key) ? values[key] : dict[key]; result.push(value, strings[i + 1]); &#125;); return result.join(''); &#125;);&#125;var t1Closure = template`$&#123;0&#125;$&#123;1&#125;$&#123;0&#125;!`;t1Closure('Y', 'A'); // "YAY!" var t2Closure = template`$&#123;0&#125; $&#123;'foo'&#125;!`;t2Closure('Hello', &#123;foo: 'World'&#125;); // "Hello World!" 原始字符串在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串。 123456function tag(strings, ...values) &#123; console.log(strings.raw[0]); // "string text line 1 \\n string text line 2"&#125;tag`string text line 1 \n string text line 2`; 另外，使用String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。 1String.raw`Hi\n$&#123;2+3&#125;!`; 浏览器兼容]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iterator 迭代器]]></title>
    <url>%2F2018%2F01%2F01%2Fiterator-die-dai-qi%2F</url>
    <content type="text"><![CDATA[iterator 迭代器引用：高鹏、Symbol.iterator 迭代器（Iterator）是一个接口，为各种不同的数据结构提供统一的访问机制。任何数据只要部署了 Iterator 接口，就可以完成遍历操作。 Symbol.iterator 属性的属性特性： 属性 属性特性 writable: false enumerable: false configurable: false 描述 当需要对一个对象进行迭代时（比如开始用于一个for..of循环中），它的@@iterator方法都会在不传参情况下被调用，返回的迭代器用于获取要迭代的值。 一些内置类型拥有默认的迭代器行为，其他类型（如 Object）则没有。下表中的内置类型拥有默认的@@iterator方法： Array.prototype@@iterator TypedArray.prototype@@iterator String.prototype@@iterator Map.prototype@@iterator Set.prototype@@iterator 作用 各种数据结构提供一个统一的、简便的访问接口； 使数据结构成员能够按某种次序排列； ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费 示例 自定义迭代器我们可以像下面这样创建自定义的迭代器： 1234567var myIterable = &#123;&#125;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] 不符合标准的迭代器如果一个迭代器 @@iterator 没有返回一个迭代器对象，那么它就是一个不符合标准的迭代器，这样的迭代器将会在运行期抛出异常，甚至非常诡异的 Bug。 123var nonWellFormedIterable = &#123;&#125;nonWellFormedIterable[Symbol.iterator] = () =&gt; 1[...nonWellFormedIterable] // TypeError: [] is not a function 就拿 for…of 语句来说，它首先调用被遍历对象的 Symbol.iterator 方法，该方法返回一个迭代器对象，迭代器对象可以是拥有 next 方法的任何对象。然后， 在 for…of 的每一次循环中，都将调用该迭代器对象上的 next 方法。每一次调用 next 方法，都会返回数据结构的当前成员信息。具体来说就是返回一个包含 value 和 done 两个属性的对象。其中 value 是当前成员的值，done 是一 个布尔值，表示遍历是否结束。 下面的代码实现了一个简单的迭代器对象： 12345678910111213141516171819202122232425262728var sampleIterator = &#123; index: 0, [Symbol.iterator]: function() &#123; return this &#125;, next: function() &#123; if (this.index &lt; 3) &#123; return &#123; done: false, value: this.index++ &#125; &#125; else &#123; return &#123; done: true, value: undefined &#125; &#125; &#125;&#125;for (var val of sampleIterator) &#123; console.log(val)&#125;// 结果为：// 0// 1// 2// [Finished in 2.7s] 上面的代码中，当使用 for…of 遍历 sampleIterator 时，首先调用了该对象的 [Symool.itirator] 方法，该方法返回对象本身。而该对象中包含有 next 方法，所以该对象本身就是一个 Iterator对象。可以供 for..of消费。当 this.index &gt;= 3 时，返回 {done: true, value: undefined}, 循环结束。 数据结构的默认 Iterator 接口 Iterator 接口的目的，就是为所有的数据结构提供一种统一的访问机制，即 for...of 循环。当使用 for…of 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 ES6 规定，默认的 Iterator 接口就部署在数据结构的 Symbol.iterator 属性。调用该方法，就会得到当前数据结构默认的迭代器生成函数。 ES6 中，有三类数据结构原生具备 Iterator 接口：数组、类似数组的对象（如 NodeList ）、Set 和 Map 结构。 12345678910111213let arr = [1, 2, 4]// 迭代器接口部署在数组的 `Symbol.iterator` 属性上，调用该属性就可以得到迭代器对象（一个包含 next 函数的对象）var iterator = arr[Symbol.iterator]()console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())// 输出结果：// &#123; value: 1, done: false &#125;// &#123; value: 2, done: false &#125;// &#123; value: 4, done: false &#125;// &#123; value: undefined, done: true &#125;// [Finished in 2.6s] 类似数组的对象（存在数值键名和 length 属性），可以直接在 Symbol.iterator 属性上部署数组的 Iterator 接口： 12345678910111213141516171819202122232425262728let iterable = &#123; 0: 'a', 1: 'b', 2: 'c', 3: 'd', length: 4,&#125;for (var item of iterable) &#123; console.log(item)&#125;// 输出结果：// a// b// c// d// [Finished in 2.6 s]// 如果 iterable 的 length 属性为 3：// a// b// c// [Finished in 2.7s]// 如果 iterable 的 length 属性为 5：// a// b// c// d// undefined// [Finished in 2.7s] 注：普通对象部署数组的 Symbol.iterator 方法，并没有效果。如果 Symbol.iterator 方法对应的不是遍历器生成函数，解释引擎会报错。 调用 Iterator 接口的场合除了 for…of 循环，还有几个场合会默认调用 Iterator 接口（即 Symbol.iterator). 解构赋值 扩展运算符 yield* 由于数组遍历调用迭代器接口，所以任何接受数组作为参数的场合，其实都调用了 Iterator 接口： for…of Array.from() Map(), Set(), WeakMap(), WeakSet() Promise.all() Promise.race() …]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数]]></title>
    <url>%2F2017%2F12%2F31%2Fjian-tou-han-shu%2F</url>
    <content type="text"><![CDATA[箭头函数 箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数，并且它们不能用作构造函数。 语法 123456789101112基础语法(参数1, 参数2, …, 参数N) =&gt; &#123;函数声明&#125;(参数1, 参数2, …, 参数N) =&gt; 表达式（单一）//相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return表达式&#125;// 当只有一个参数时，圆括号是可选的：(单一参数) =&gt; &#123;函数声明&#125;单一参数 =&gt; &#123;函数声明&#125;// 没有参数的函数应该写成一对圆括号。() =&gt; &#123;函数声明&#125; 高级语法 12345678910//加括号的函数体返回对象字面表达式：参数=&gt; (&#123;foo: bar&#125;)//支持剩余参数和默认参数(参数1, 参数2, ...rest) =&gt; &#123;函数声明&#125;(参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; &#123;函数声明&#125;//同样支持参数列表解构let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;f(); // 6 描述 引入箭头函数有两个方面的作用：更简短的函数并且不绑定this。 更短的函数 123456789101112131415var materials = [ 'Hydrogen', 'Helium', 'Lithium', 'Beryllium'];materials.map(function(material) &#123; return material.length; &#125;); // [8, 6, 7, 9]materials.map((material) =&gt; &#123; return material.length;&#125;); // [8, 6, 7, 9]materials.map(material =&gt; material.length); // [8, 6, 7, 9] 不绑定this 在箭头函数出现之前，每个新定义的函数都有它自己的 this值（在构造函数的情况下是一个新对象，在严格模式的函数调用中为 undefined，如果该函数被称为“对象方法”则为基础对象等）。This被证明是令人厌烦的面向对象风格的编程。 123456789101112function Person() &#123; // Person() 构造函数定义 `this`作为它自己的实例. this.age = 0; setInterval(function growUp() &#123; // 在非严格模式, growUp()函数定义 `this`作为全局对象, // 与在 Person()构造函数中定义的 `this`并不相同. this.age++; &#125;, 1000);&#125;var p = new Person(); 在ECMAScript 3/5中，通过将this值分配给封闭的变量，可以解决this问题。 123456789function Person() &#123; var that = this; that.age = 0; setInterval(function growUp() &#123; // 回调引用的是`that`变量, 其值是预期的对象. that.age++; &#125;, 1000);&#125; 或者，可以创建绑定函数，以便将预先分配的this值传递到绑定的目标函数（上述示例中的growUp()函数）。 箭头功能不会创建自己的this；它使用封闭执行上下文的this值。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同： 123456789function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; // |this| 正确地指向person 对象 &#125;, 1000);&#125;var p = new Person(); 与严格模式的关系鉴于 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。 12var f = () =&gt; &#123;'use strict'; return this&#125;;f() === window; // 或全局对象 严格模式的其他规则依然不变. 通过 call 或 apply 调用由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并没有什么影响： 1234567891011121314151617181920var adder = &#123; base : 1, add : function(a) &#123; var f = v =&gt; v + this.base; return f(a); &#125;, addThruCall: function(a) &#123; var f = v =&gt; v + this.base; var b = &#123; base : 2 &#125;; return f.call(b, a); &#125;&#125;;console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注） 不绑定arguments箭头函数不绑定Arguments 对象。因此，在本示例中，参数只是在封闭范围内引用相同的名称： 123456789101112var arguments = 42;var arr = () =&gt; arguments;arr(); // 42function foo() &#123; var f = (i) =&gt; arguments[0]+i; // 此处的argument为foo的arguments // foo函数的间接参数绑定 return f(2);&#125;foo(1); // 3 在大多数情况下，使用剩余参数是使用arguments对象的好选择。 1234567function foo() &#123; var f = (...args) =&gt; args[0]; return f(2); &#125;foo(1); // 2 像方法一样使用箭头函数如上所述，箭头函数表达式对非方法函数是最合适的。让我们看看当我们试着把它们作为方法时发生了什么。 123456789101112'use strict';var obj = &#123; i: 10, b: () =&gt; console.log(this.i, this), c: function() &#123; console.log( this.i, this) &#125;&#125;obj.b(); // undefinedobj.c(); // 10, Object &#123;...&#125; 箭头函数没有定义this绑定。另一个涉及Object.defineProperty()的示例： 123456789101112'use strict';var obj = &#123; a: 10&#125;;Object.defineProperty(obj, "b", &#123; get: () =&gt; &#123; console.log(this.a, typeof this.a, this); return this.a+10; // 代表全局对象 'Window', 因此 'this.a' 返回 'undefined' &#125;&#125;); 使用 new 操作符箭头函数不能用作构造器，和 new一起用会抛出错误。 12var Foo = () =&gt; &#123;&#125;;var foo = new Foo(); // TypeError: Foo is not a constructor 使用prototype属性箭头函数没有prototype属性。 12var Foo = () =&gt; &#123;&#125;;console.log(Foo.prototype); // undefined 使用 yield 关键字 yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。 函数体箭头功能可以有一个“简写体”或常见的“块体”。 在一个简写体中，只需要一个表达式，并附加一个隐式的返回值。在块体中，必须使用明确的return语句。 12345var func = x =&gt; x * x; // 简写函数 省略returnvar func = (x, y) =&gt; &#123; return x + y; &#125;; //常规编写 明确的返回值 返回对象字面量记住用params =&gt; {object:literal}这种简单的语法返回对象字面量是行不通的。 12345var func = () =&gt; &#123; foo: 1 &#125;; // Calling func() returns undefined!var func = () =&gt; &#123; foo: function() &#123;&#125; &#125;; // SyntaxError: function statement requires a name 这是因为花括号（{} ）里面的代码被解析为一系列语句（即 foo 被认为是一个标签，而非对象字面量的组成部分）。 所以，记得用圆括号把对象字面量包起来： 1var func = () =&gt; (&#123;foo: 1&#125;); 换行箭头函数在参数和箭头之间不能换行。 123var func = () =&gt; 1; // SyntaxError: expected expression, got '=&gt;' 解析顺序虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。 12345678let callback;callback = callback || function() &#123;&#125;; // okcallback = callback || () =&gt; &#123;&#125;; // SyntaxError: invalid arrow-function argumentscallback = callback || (() =&gt; &#123;&#125;); // ok 更多示例 123456789101112131415161718192021222324252627282930313233343536373839404142// 空的箭头函数返回 undefinedlet empty = () =&gt; &#123;&#125;;(() =&gt; 'foobar')(); // Returns "foobar"// (这是一个立即执行函数表达式,可参阅 'IIFE'术语表) var simple = a =&gt; a &gt; 15 ? 15 : a; simple(16); // 15simple(10); // 10let max = (a, b) =&gt; a &gt; b ? a : b;// Easy array filtering, mapping, ...var arr = [5, 6, 13, 0, 1, 18, 23];var sum = arr.reduce((a, b) =&gt; a + b); // 66var even = arr.filter(v =&gt; v % 2 == 0); // [6, 0, 18]var double = arr.map(v =&gt; v * 2); // [10, 12, 26, 0, 2, 36, 46]// 更简明的promise链promise.then(a =&gt; &#123; // ...&#125;).then(b =&gt; &#123; // ...&#125;);// 无参数箭头函数在视觉上容易分析setTimeout( () =&gt; &#123; console.log('I happen sooner'); setTimeout( () =&gt; &#123; // deeper code console.log('I happen later'); &#125;, 1);&#125;, 1); 箭头函数也可以使用条件（三元）运算符： 12345var simple = a =&gt; a &gt; 15 ? 15 : a;simple(16); // 15simple(10); // 10let max = (a, b) =&gt; a &gt; b ? a : b; 箭头函数内定义的变量及其作用域 12345678910111213141516171819// 常规写法var greeting = () =&gt; &#123;let now = new Date(); return ("Good" + ((now.getHours() &gt; 17) ? " evening." : " day."));&#125;greeting(); //"Good day."console.log(now); // ReferenceError: now is not defined 标准的let作用域// 参数括号内定义的变量是局部变量（默认参数）var greeting = (now=new Date()) =&gt; "Good" + (now.getHours() &gt; 17 ? " evening." : " day.");greeting(); //"Good day."console.log(now); // ReferenceError: now is not defined// 对比：函数体内&#123;&#125;不使用var定义的变量是全局变量var greeting = () =&gt; &#123;now = new Date(); return ("Good" + ((now.getHours() &gt; 17) ? " evening." : " day."));&#125;greeting(); //"Good day."console.log(now); // Fri Dec 22 2017 10:01:00 GMT+0800 (中国标准时间)// 对比：函数体内&#123;&#125; 用var定义的变量是局部变量var greeting = () =&gt; &#123;var now = new Date(); return ("Good" + ((now.getHours() &gt; 17) ? " evening." : " day."));&#125;greeting(); //"Good day."console.log(now); // ReferenceError: now is not defined 箭头函数也可以使用闭包： 123456789101112131415161718192021// 标准的闭包函数function A()&#123; var i=0; return function b()&#123; return (++i); &#125;;&#125;;var v=A();v(); //1v(); //2//箭头函数体的闭包（ i=0 是默认参数）var Add = (i=0) =&gt; &#123;return (() =&gt; (++i) )&#125;;var v = Add();v(); //1v(); //2//因为仅有一个返回，return 及括号（）也可以省略var Add = (i=0)=&gt; ()=&gt; (++i); 箭头函数递归 12var fact = (x) =&gt; ( x==0 ? 1 : x*fact(x-1) );fact(5); // 120 浏览器兼容]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for-of详解]]></title>
    <url>%2F2017%2F12%2F30%2Ffor...of%2F</url>
    <content type="text"><![CDATA[for-of for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。 语法123for (variable of iterable) &#123; //statements&#125; variable在每次迭代中，将不同属性的值分配给变量。 iterable可枚举其枚举属性的对象。 推荐在循环对象属性的时候，使用for…in,在遍历数组的时候的时候使用for…of。 for…in循环出的是key，for…of循环出的是value。for…of修复了for…in的缺陷和不足，假设我们往数组添加一个属性name:aArray.name = ‘demo’,再分别查看上面写的两个循环： 123456for(let index in aArray)&#123; console.log(`$&#123;aArray[index]&#125;`); //aArray.name会也被循环出来了，得到的数组的值的顺序也会被打乱&#125;for(var value of aArray)&#123; console.log(value);&#125; 所以说，作用于数组的for-in循环除了遍历数组元素以外,还会遍历自定义属性。 for…of循环不会循环对象的key，只会循环出数组的value，因此for…of不能循环遍历普通对象,对普通对象的属性遍历推荐使用for…in 如果实在想用for…of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组：然后遍历：12345678910111213var student=&#123; name:'wujunchuan', age:22, locate:&#123; country:'china', city:'xiamen', school:'XMUT' &#125;&#125;for(var key of Object.keys(student))&#123; //先获取studentkey的数组，循环数组再得到对象值，基本上是多此一举 //使用Object.keys()方法获取对象key的数组 console.log(key+": "+student[key]);&#125; for…of不能循环普通的对象，需要通过和Object.keys()搭配使用 123456789101112131415161718// for...in循环可以遍历键名，for...of循环会报错。var es6 = &#123; edition: 6, committee: "TC39", standard: "ECMA-262"&#125;;for (e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (e of es6) &#123; console.log(e);&#125;// TypeError: es6 is not iterable 与forEach()不同的是，它可以正确响应break、continue和return语句,forEach循环会简洁很多，但是不能break、continue、return 1234var a = ["a", "b", "c"];a.forEach(function(element) &#123; console.log(element);&#125;); for…of现在浏览器的支持成都还不是很好 示例 迭代Array 123456789let iterable = [10, 20, 30];for (let value of iterable) &#123; value += 1; console.log(value);&#125;// 11// 21// 31 如果你不想修改语句块中的变量 , 也可以使用const代替let。 12345678let iterable = [10, 20, 30];for (const value of iterable) &#123; console.log(value);&#125;// 10// 20// 30 迭代String 12345678let iterable = "boo";for (let value of iterable) &#123; console.log(value);&#125;// "b"// "o"// "o" 迭代 TypedArray 1234567let iterable = new Uint8Array([0x00, 0xff]);for (let value of iterable) &#123; console.log(value);&#125;// 0// 255 迭代Map 123456789101112131415let iterable = new Map([["a", 1], ["b", 2], ["c", 3]]);for (let entry of iterable) &#123; console.log(entry);&#125;// ["a", 1]// ["b", 2]// ["c", 3]for (let [key, value] of iterable) &#123; console.log(value);&#125;// 1// 2// 3 迭代 Set 12345678let iterable = new Set([1, 1, 2, 2, 3, 3]);for (let value of iterable) &#123; console.log(value);&#125;// 1// 2// 3 迭代 arguments 对象 123456789(function() &#123; for (let argument of arguments) &#123; console.log(argument); &#125;&#125;)(1, 2, 3);// 1// 2// 3 迭代 DOM 集合迭代 DOM 元素集合，比如一个NodeList对象：下面的例子演示给每一个 article 标签内的 p 标签添加一个 “read” 类。 123456//注意：这只能在实现了NodeList.prototype[Symbol.iterator]的平台上运行let articleParagraphs = document.querySelectorAll("article &gt; p");for (let paragraph of articleParagraphs) &#123; paragraph.classList.add("read");&#125; 关闭迭代器对于for…of的循环，可以由break, continue[4], throw 或return[5]终止。在这些情况下，迭代器关闭。 12345678910function* foo()&#123; yield 1; yield 2; yield 3; &#125;; for (let o of foo()) &#123; console.log(o); break; // closes iterator, triggers return&#125; 迭代生成器你还可以迭代一个生成器： 1234567891011121314function* fibonacci() &#123; // 一个生成器函数 let [prev, curr] = [0, 1]; for (;;) &#123; // while (true) &#123; [prev, curr] = [curr, prev + curr]; yield curr; &#125;&#125; for (let n of fibonacci()) &#123; console.log(n); // 当n大于1000时跳出循环 if (n &gt;= 1000) break;&#125; 不要重用生成器生成器不应该重用，即使for…of循环的提前终止，例如通过break关键字。在退出循环后，生成器关闭，并尝试再次迭代，不会产生任何进一步的结果。 1234567891011121314var gen = (function *()&#123; yield 1; yield 2; yield 3;&#125;)();for (let o of gen) &#123; console.log(o); break;//关闭生成器&#125; //生成器不应该重用，以下没有意义！for (let o of gen) &#123; console.log(o);&#125; 迭代其他可迭代对象你还可以迭代显式实现可迭代协议的对象： 123456789101112131415161718192021var iterable = &#123; [Symbol.iterator]() &#123; return &#123; i: 0, next() &#123; if (this.i &lt; 3) &#123; return &#123; value: this.i++, done: false &#125;; &#125; return &#123; value: undefined, done: true &#125;; &#125; &#125;; &#125;&#125;;for (var value of iterable) &#123; console.log(value);&#125;// 0// 1// 2 for…of与for…in的区别无论是for…in还是for…of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。 for…in 语句以原始插入顺序迭代对象的可枚举属性。 for…of 语句遍历可迭代对象定义要迭代的数据。 以下示例显示了与Array一起使用时，for…of循环和for…in循环之间的区别。 123456789101112131415161718192021222324Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;;let iterable = [3, 5, 7];iterable.foo = 'hello';for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"&#125;for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // logs 0, 1, 2, "foo" &#125;&#125;for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7&#125;Object.prototype.objCustom = function() &#123;&#125;;Array.prototype.arrCustom = function() &#123;&#125;; let iterable = [3, 5, 7]; iterable.foo = 'hello'; 每个对象将继承objCustom属性，并且作为Array的每个对象将继承arrCustom属性，因为将这些属性添加到Object.prototype和Array.prototype。由于继承和原型链，对象iterable继承属性objCustom和arrCustom。 123for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom" &#125; 此循环仅以原始插入顺序记录iterable 对象的可枚举属性。它不记录数组元素3, 5, 7 或hello，因为这些不是枚举属性。但是它记录了数组索引以及arrCustom和objCustom。如果你不知道为什么这些属性被迭代，array iteration and for…in中有更多解释。 12345for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // logs 0, 1, 2, "foo" &#125;&#125; 这个循环类似于第一个，但是它使用hasOwnProperty() 来检查，如果找到的枚举属性是对象自己的（不是继承的）。如果是，该属性被记录。记录的属性是0, 1, 2和foo，因为它们是自身的属性（不是继承的）。属性arrCustom和objCustom不会被记录，因为它们是继承的。 123for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7 &#125; 该循环迭代并记录iterable作为可迭代对象定义的迭代值，这些是数组元素 3, 5, 7，而不是任何对象的属性。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
</search>
