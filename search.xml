<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP/IP协议族(三) 数字签名与HTTPS详解]]></title>
    <url>%2F2018%2F01%2F05%2FTCP%3AIP%E5%8D%8F%E8%AE%AE%E6%97%8F(%E4%B8%89)%20%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8EHTTPS%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[转载：http://www.cnblogs.com/ludashi/p/6237715.html 前面几篇博客聊了HTTP的相关东西，今天就来聊一聊HTTPS的东西。因为HTTP协议本身存在着明文传输、不能很好的验证通信方的身份和无法验证报文的完整性等一些安全方面的确点，所以才有了HTTPS的缺陷。HTTPS确切的的说不是一种协议，而是HTTP + SSL (TSL)的结合体。HTTP报文经过SSL层加密后交付给TCP层进行传输。SSL(安全套节层)主要采取的是RSA（非对称加密）与AES（对称加密）结合的加密方式。先通过RSA交互AES的密钥，然后通过AES进行报文加密和解密。本篇博客主要聊的就是HTTPS具体的工作过程。 RSA与AES简述在本篇博客的第一部分呢，先聊一下RAS与AES这两个加密策略，如果你在公司做过支付相关的东西，对数据传输的安全性要求比较高，这时候就得采取一些加密措施将传输的报文进行加密，必要时再进行MD5验签。当然本部分聊的RAS与AES是比较简洁的，关于这两者具体的内容，请自行Google吧。因为HTTPS在传输的过程中使用到了RSA与AES加密算法，所以在聊HTTP+SSL之前呢，我们先简单的聊一下AES与RSA。 Advanced Encryption Standard （AES: 高级加密标准）AES，全称：Advanced Encryption Standard—-高级加密标准。该加密算法有一个密钥，该密钥可以用来加密，也可以用来解密，所以AES是对称加密算法。下方这个就是AES加密和解密的过程。Client端与Server端有一个共同的Key, 这个Key是用来加密和解密的。如果报文在传输的过程中被窃取了，没有这个key, 对加密的内容进行破解是非常困难的，当然窃取者如果有key的话，也是可以轻而易举的解密的。所以在AES中，key是关键。这也就相当于你们家的门钥匙，谁拿到钥匙后都可以打开你们家的门。即使门锁再结实，再安全，在钥匙面前也是不行呢。 所以对于AES加密策略来说这个Key的保密措施要做足一些，如果之后有时间的话可以分享一些具体的AES加密策略。比如每次加密的Key都是从一个密码本中动态生成的，而这个密码本服务端和客户端都有同一本，每次传输的是一些参数。这些参数在经过一些算法的映射，从密码本中取出相应的key用来解密。这样一来，就相当于给AES加了一层防盗门，加大了破解的难度。这样做的好处是每次加密的key都是不同的，而且需要密码本以及映射算法的支持。 RSA 公钥加密算法RAS这个名字，就是该算法三位发明者的名字的首字母的组合。RAS是非对称加密，其在加密和解密的过程中，需要两个Key，一个公钥（public key），一个是私钥（private key）。公钥负责加密，而私钥负责解密。从名字就可以看出，公钥是可以开放出去的，任何人都可以持有公钥进行加密。而私钥必须得进行保护，因为是用来解密的。 这样一来，加密和解密就可以用不同的钥匙来处理。对于加密放来说，即使你可以对报文进行加密，如果没有私有的话也是不可以对你加密的内容进行解密的。这就相当于一个盒子，盒子上有把锁。你可以把东西放进去，然后再锁上盒子。但是如果你没有钥匙的话，也是打不开这把锁的。 下方这个简图就是服务端单向验证的RAS非对称加密算法，Client内置了一个公钥，该公钥与Server端的私钥是配对的，所以Client端可以使用这个内置的Public key加密，而服务端就可以使用这个private key进行解密。目前最常用的是服务端单向认证机制。 CA证书如果你自己通过RAS算法生成了一个私钥和公钥，在公钥发送给客户端的过程中有可能被篡改成其他的公钥，而客户端在没有其他措施的保护下是不知道该公钥是否就是服务器那边的私钥对应的公钥的。这种自己做的RAS的公钥和私钥有可能在公钥分发的过程中被篡改。下方就是Client从Server端获取公钥时被中间者篡改了，将public换成了自己的伪public key, 同样这个中间者持有这个伪public key所对应的伪private key。如果客户端使用的伪public key进行加密传输的话，那么中间者是可以使用自己的private key进行解密的。 举个例子来类比一下这个问题。 假设你在古代，你出门在外，妻子在家养子。你们家有个箱子，箱子上有把锁，这就是你和你妻子互通的工具。你媳妇儿负责往箱子里放东西，然后上锁。你有把独特的钥匙，你负责开锁，取东西。可是你再将箱子给镖局托运的的过程中，被镖局的“小黑”掉包了，箱子的外表一致，锁看起来也一样，可是已经不是你的箱子了。因为路途遥远，古代又没有什么iPhone啥的，你媳妇没办法来辨别该箱子是否是原装的。然后就将一些东西放在了箱子里边，然后上锁交给了镖局的“小黑”。 因为“小黑”掉包的箱子，所以小黑有箱子的钥匙呢，然后就可以打开这个箱子，取东西了。原来的箱子又在小黑那，小黑就可以往原来的箱子里边随便往箱子放点没有价值的东西给你就行了。当你发现箱子里的东西不是你想要的时候，完了，小黑从镖局辞职了，找不到人了。找镖局的人讨说法，可是镖局的人说“小黑”是镖局的临时工，这个责任镖局说了，我们不能担。鉴于你无权无势，这事儿也就此罢了。（故事纯属虚构，如有雷同纯属巧合） 关于更多骗子的故事请移步网络剧《毛骗》一二三季。 为了防止“小黑”再次作案，所以颁布一个公正机构来证明你媳妇收到的箱子就是你发出的箱子。在RAS加密中也有一个第三方机构来充当这个角色，负责证明客户端收到的证书就是你发送的证书，中间没有被篡改。这个中间认证机构，就是数组证书认证机构, 其颁发的证书也就是我们常说的CA证书（CA , Certificate Authority）。 下面我们就来详细的叙述一下证书签名，证书分发以及证书验证的整个过程。 服务端人员使用RSA算法生成两个密钥，一个用来加密一个用来解密。将负责加密的那个密钥公布出去，所以我们称之为公钥（Public Key），而用来解密的那个密钥，不能对外公布，只有服务端持有，所以我们称之为私钥（Private Key）。服务端在将Public Key进行分发证书之前需要向CA机构申请给将要分发的公钥进行数字签名。（服务器公钥负责加密，服务器私钥负责解密） 生成数字签名公钥证书：对于CA机构来说，其也有两个密钥，我们暂且称之为CA私钥和CA公钥。CA机构将服务端的Public Key作为输入参数将其转换为一个特有的Hash值。然后使用CA私钥将这个Hash值进行加密处理，并与服务端的Public Key绑定在一起，生成数字签名证书。其实数字签名证书的本质就是服务端的公钥+CA私钥加密的Hash值。（CA私钥负责签名，CA公钥负责验证） 服务器获取到这个已经含有数字签名并带有公钥的证书，将该证书发送给客户端。当客户端收到该公钥数字证书后，会验证其有效性。大部分客户端都会预装CA机构的公钥，也就是CA公钥。客户端使用CA公钥对数字证书上的签名进行验证，这个验证的过程就是使用CA公钥对CA私钥加密的内容进行解密，将解密后的内容与服务端的Public Key所生成的Hash值进行匹配，如果匹配成功，则说明该证书就是相应的服务端发过来的。否则就是非法证书。 验证完服务端公钥的合法性后，就可以使用该公钥进行加密通信了。 下方这个截图就是苹果的根证书的一些信息，从下方可以看出，CA证书内容中包括加密算法，公共密钥以及数字签名。 下方就是公钥以及数字签名的具体内容，当对下方公共密钥进行验证时，需要使用内置的CA公钥将数字签名进行解密。然后将解密后的内容，与公钥生成的Hash值进行比较，如果匹配成功，那么该证书就是CA机构颁布的合法证书。 HTTPS安全通信机制的建立上面我们聊完AES与RSA加密策略，然后又聊了带有数字签名的公共密钥。上面这两部分内容都是为HTTPS做铺垫的，接下来就看一看HTTP+SSL是如何进行数据传输的。 HTTPS简介在开头的部分也说了，HTTPS不是一个新的通信协议，而是HTTP与SSL（或TSL）的组合。SSL–安全套节层(Secure Socket Layer), TSL（Transport Layer Security 安全传输层）是以SSL为原型开发的协议，IETF以SSL3.0为基准后又制定了TLS1.0、TLS1.1和TLS1.2，当前主流版本为SSL3.0与TLS1.0。 HTTPS就是在HTTP与TCP层中间添加了一个SSL层。因为HTTPS被HTTP多了这层加密的流程，所以HTTPS的速度要比HTTP慢的多。 HTTPS的通信过程SSL的加密过程是RSA与AES混合进行的。简单概括一下，就是通过RSA加密方式来交换AES加解密的密钥，然后使用AES加密的方式来传输报文。下方是SSL建立连接以及传输数据的图解。在下图中大体可以分为四步： 第一步：有客户端发起的第一次握手，此次握手过程的主要目的是从服务端获取数字签名证书，服务端在发送数字签名证书之前要先确认客户端的SSL版本、加密算法等信息。 第二步：完成第一次握手后，接着进行第二次握手。第二次握手是在客户端收到证书后发起的，主要目的是将AES加解密使用的Key （Pre-master secret）发送给服务端。当然这个AES_KEY是使用第一次握手获取的公钥进行加密的。客户端收到这个使用公钥加密后的AES_KEY，使用服务端的私钥进行解密。这样客户端和服务端经过二次握手后都持有了AES加解密的KEY。 第三步：当Client与Server端都持有AES_KEY后，就可以对HTTP报文进行加解密了。END: 最后就是断开连接了。具体如下图所示：]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议族(二) HTTP报文头解析]]></title>
    <url>%2F2018%2F01%2F04%2FTCP%3AIP%E5%8D%8F%E8%AE%AE%E6%97%8F(%E4%BA%8C)%20HTTP%E6%8A%A5%E6%96%87%E5%A4%B4%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[转载：http://www.cnblogs.com/ludashi/p/6237340.html 本篇博客我们就来详细的聊一下HTTP协议的常用头部字段，当然我们将其分为请求头和响应头进行阐述。下方是报文头每个字段的格式，首先是头部字段的名称，如Accept，冒号后方紧跟的是该字段名所对应的值，每个值之间有逗号分隔。如果该值需要优先级，那么在值的后方跟上优先级q=0.8(q的值由0~1，优先级从低到高)。值与优先级中间由分号相隔。 头部字段名：值1, 值2;q=0.8 下方就是截取的网络请求中Request Headers的部分内容。红框中的Accept-Language就是头部字段名，冒号后边就是该字段相应的值了。如下所示： HTTP头部字段可以分为通用头部字段，请求头部字段，响应头部字段以及实体头部字段，下方会给出详细的介绍。 通用头部字段 （General Header Fields）该字段在请求头和响应头都会使用到，下方是常用的通用头部字段： Cache-Control用来操作缓存的工作机制，下方截图响应头中的的Cache-Control的参数为private和max-age=10。private缓存是私有的，仅像特定用户提供相应的缓存信息。如果是public，那么就意味着可向任意方提供相应的缓存信息。max-age = 10表示缓存有效期为10秒。从下方的Expires(过期时间)和Last-Modified(最后修改时间)就可以看出，这两者之间的差值正好是10秒。 该字段还可以对应其他的参数： no-cache：如果是客户端的话，说明客户端不会接收缓存过的响应，要请求最新的内容。而服务器端则表示缓存服务器不能对相应的资源进行缓存。 no-store：表示缓存不能在本地存储。 max-age：该参数后方会被赋值上相应的秒数，在请求头中表示如果缓存时间没有超过这个值就返回给我。而在响应头中时，则表示资源在缓存服务器中缓存的最大时间。 only-if-cached：表示客户端仅仅请求缓存服务器上的内容，如果缓存服务器上没有请求的内容，那么返回504 Gateway Timeout。 must-revalidata：表示缓存服务器在返回资源时，必须向资源服务器确认其缓存的有效性。 no-transform：无论请求还是响应，都不能在传输的过程中改变报文体的媒体类型。 Connection该字段可以控制不转发给代理服务器的首部字段以及管理持久连接，下方这个响应报文头中的Connection就是用来管理持久连接的，其参数为keep-alive，就是保持持久连接的意思。可以使用close参数将其关闭。 Transfer-Encoding该字段表示报文在传输过程中采用的编码方式，在HTTP/1.1的报文传输过程中仅对分块编码有效。下方这个截图就是Transfer-Encoding在Response Header中的使用，后边根的chunked(分块)的参数，说明报文是分块进行传输的。 Via该字段是为了追踪请求和响应报文测传输路径，报文经过代理或者网关是会在Via字段添加该服务器的信息，然后再进行转发。 请求头部字段 （Request Header Fields）顾名思义，请求头部字段当然是在请求头中才使用的字段。该字段用于补充请求的附加信息，客户端信息等。接下来将给出常用而且比较重要的几个请求头部字段。 Accept该字段可通知服务器用户代理能够处理的媒体类型以及该媒体类型对应的优先级。媒体类型可使用“type/subtype”这种形式来指定，分号后边紧跟着的是该类型的优先级。如下所示。 Accept-Encoding该字段用来告知服务器，客户端这边可支持的内容编码以及相应内容编码的优先级, 下方就是Accept-Encoding的用法。gzip表示由文件压缩程序gzip(GNU zip)生成的编码格式。compress表示UNIX文件压缩程序compress生成的编码格式。deflate表示组合使用zlib格式以及有deflate压缩算法生成的编码格式。identity表示不执行压缩或者使用一致的默认编码格式。 Accept-Language该字段用来告知服务器，客户端可处理的自然语言集，以及对应语言集的优先级。以下方的截图为例，Accept-Language后方跟了三个属性，分别是“zh-CN”, “zh;q=0.8”，“en;q=0.6”。也就是说客户端可处理三种自然预言集，zh-CN，其优先级是1（最高）。第二种是zh ，其优先级是0.8，次之。第三个是en，优先级为0.6，优先级在三者之间最低。 Authorization用来告知服务器用户端的认证信息，下方就是连接公司内部SVN系统时需要认证时的请求头部信息。 如果你没有填写认证信息的话，那么就会返回401 Unauthorized。如下所示： If-Match 与If-None-Match上面这两个请求头部字段都是带有逻辑判断的，从上面的英文我们不难看出两者恰好相反。两者后方都跟着串字符串，如If-Match “xcsldjh49773hce”, 后边这个字符的匹配对象是ETag(稍后会介绍)。If-Match的请求是如果后方的字符串与ETag相等则服务器端进行请求，否则不进行处理。If-None-Match是If-Match的非操作，同样是匹配ETag, 如果Etag没有匹配成功就处理请求，否则不处理。 If-Modified-Since与If-Unmodified-SinceIf-Modified-Since也是带有逻辑判断的请求头部字段，该字段后方跟的是一个日期，意思是在该日期后发生了资源更新，那么服务器就会处理该请求。If-Unmodified-Since就是 If-Modified-Since的非操作。 If-Rangeif-Range字段后方也是跟的Etag, 该字段要结合着Range字段进行使用。其所代表的意思就是如果Etag匹配成功，请求的内容就按照Range字段所规定的范围进行返回，否则返回全部的内容。用法如下所示： 12If-Range: &quot;etag_code&quot; Range: bytes=1000-5000 Referer其实Referer是一个错误的拼写，但是一直在使用。正确的英文单词应该是Referrer(此处可翻译为:来历、来路)。Referer字段后方跟的是一个URI, 该URI就是发起请求的URI，具体如下所示： User-Agent该字段会将请求方的浏览器和用户代理名称等信息传达给服务器。下方就是从我当前笔记本的Chrome浏览器请求网络时的User-Agent信息。 示例 响应头部字段 （Request Header Fields）聊完请求报文头部字段后，我们接下来来聊一下响应报文头部字段。响应头是由Server向Client返回响应报文中使用的头部信息。用户补充响应的附加信息、服务信息等。下方是几个常见响应头部字段。 Accept-Ranges该字段用来告知客户端服务器那边是否支持范围请求（请求部分内容，请求头中使用Range字段）。Accept-Ranges的值为bytes时，就说明服务器支持范围请求，为none时，说明服务器不支持客户端的范围请求。下方是博客园的页面的加载，从下方可以看出是支持范围请求的，如下所示： Age该字段告知客户端，源服务器在多久前创建了该响应。 EtagEtag是服务器（当前）请求的服务器资源（图片，HTML页面等）所对应的一个独有的字符串。不同资源间的Etag是不同的，当资源更新时Etag也会进行更新。 所以结合着请求头中的If-Match等逻辑请求头，可以判断当前Client端已经加载的资源在服务器端是否已经更新了。当初次请求一个资源，如图片时，我们可以将其Etag进行保存，在此请求时，可放在If-None-Match后方，进行资源更新。如果服务器资源并未修改，就不对该请求做出响应。下方就是网页中某张图片对应着的Etag，如下所示。 LocationLocation字段一般与重定向结合着使用。下方是我访问“www.baidu.com/hello”这个连接的响应报文。因为服务器上并没有/hello这个资源路径，所以给我重定向了error.html页面，这个重定向的URL就存储在Location字段中，如下所示： Server该响应字段表明了服务器端使用的服务器型号，下方是博客园某张图片的响应头，使用的Web服务器是Tengine, Tengin是淘宝发起的Web服务器项目，是基于Nginx的，关于Tengin的相关内容，请自行Google吧。 VaryVary可对缓存进行控制，通过该字段，源服务器会向代理服务器传达关于本地缓存使用方法的命令。下方就是Vary的使用，Vary后方的参数是Accept-Encoding。其意思是返回的缓存要以Accept-Encoding为准。当请求的Accept-Encoding的参数与缓存内容的Accept-Encoding参数一致时就返回缓存内容，否则就请求源服务器。 WWW-Authenticate该字段用于HTTP的访问认证，在状态码401 Unauthorized中肯定带有此字段，该字段用来指定客户端的认证方案（Basic或者Digest）。参数realm的字符串是为了辨别请求URL指定资源所受到的保护策略。如下所示： 实体头部字段（Content Header Fields） 接下来我们就来聊聊常见的实体头部字段，实体头部字段是报文实体所使用的头部，用来补充与报文实体相关的信息。 Allow该字段用于服务器通知客户端服务器这边所支持的所有请求方法（GET、POST等）。如果服务器找不到客户端请求中所提到的方法的话，就会返回405 Method Not Allowed，于此同时还会把所有能支持的HTTP方法写入到首部字段Allow后返回。 1Allow : GET, POST, HEAD, PUT, DELETE Content-Encoding该字段用来说明报文实体的编码方式，下方这段报文头中的Content-Encoding的参数为gzip，说明是使用gzip对报文实体进行压缩的。 Content-Language该字段表示报文实体使用的自然语言，使用方式如下所示： 1Content-Language: zh-CN Content-Length顾名思义，该字段用来指定报文实体的字节长度，如下所示： Content-MD5该字段中存储的是报文实体进行MD5加密然后再使用Base64进行编码的字符串。客户端收到响应报文后，可以对报文实体进行MD5加密，然后再对其进行Base64编码，然后与Content-MD5中的字符串进行比较来确定报文是否进行修改，可以说这是一个简单的验签功能。但是此方法并不能确定报文是否被修改了，因为Content-MD5这个值也有可能被篡改。 Cookie相关的头部字段因为HTTP协议本身是无状态的，在Web站点中使用Cookie来管理服务器与客户端之间的状态。解析来我就来介绍一下Cookie相关的头部字段。 Set-Cookie响应报文中会使用到该字段。当服务器准备开始管理客户端的状态时，会事先告知其各种信息。下方字段是登录知乎时所返回的所要设置的Cookie信息。接下来我们就要对这串Cookie信息进行解析。 键值对：在Set-Cookie字段中，“z_co=Mi4……”这就是要存入Cookie中的信息，当然可以是多个键值对，中间使用逗号进行分割即可。 Domain：然后是Domain属性，由下方不难看出，Domain中存储的就是Cookie适用对象的域名，若不指定Domain的值，那么默认就是创建Cookie的服务器的域名。 expire：该字段属性的值是一个时间，也就是Cookie的有效期，若不指定该属性的值，默认就是当前会话有效，关闭浏览器Cookie即失效。 httponly：设置该属性的目的是让JavaScript脚本无法获取Cookie，其主要目的是防止跨站脚本攻击对Cookie信息的窃取。 path： 用于限制指定Cookie的发送范围的文件目录。 Secure：仅在HTTPS安全通信时才会发送Cookie。 Cookie请求报文头中会使用该字段，用于将本地存储的Cookie信息发送给服务端。下方就是知乎上每次请求文章所带有的Cookie信息，当然下方只是部分信息，但是我们还是从中可以找到之前我们存储的“z_co=Mi4……”这个键值对的。 存储cookie是浏览器提供的功能。cookie 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的cookie。 当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在cookie中”。 存储在cookie中的数据，每次都会被浏览器自动放在http请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在cookie中，其他类型的数据就不适合了。 但在 localStorage 出现之前，cookie被滥用当做了存储工具。什么数据都放在cookie中，即使这些数据只在页面中使用而不需要随请求传送到服务端。当然cookie标准还是做了一些限制的：每个域名下的cookie 的大小最大为4KB，每个域名下的cookie数量最多为20个（但很多浏览器厂商在具体实现时支持大于20个）。 cookie详解]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 应用程序的通信连接模式]]></title>
    <url>%2F2018%2F01%2F04%2FTCP%3AIP%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[转载：刘光宝:https://www.ibm.com/developerworks/cn/aix/library/0807_liugb_tcpip/index.html TCP/IP 应用层与应用程序TCP/IP 起源于二十世纪 60 年代末美国政府资助的一个分组交换网络研究项目，它是一个真正的开放协议，很多不同厂家生产各种型号的计算机，它们运行完全不同的操作系统，但 TCP/IP 协议组件允许它们互相进行通信。现在 TCP/IP 已经从一个只供一些科学家使用的小实验网成长为一个由成千上万的计算机和用户构成的全球化网络，TCP/IP 也已成为全球因特网（Internet）的基础，越来越多的 TCP/IP 互联网应用和企业商业应用正在改变着世界。 TCP/IP 通讯协议采用了四层的层级模型结构（注：这与 OSI 七层模型不相同），每一层都调用它的下一层所提供的网络任务来完成自己的需求。TCP/IP 的每一层都是由一系列协议来定义的。这 4 层分别为： 应用层 (Application)：应用层是个很广泛的概念，有一些基本相同的系统级 TCP/IP 应用以及应用协议，也有许多的企业商业应用和互联网应用。 传输层 (Transport)：传输层包括 UDP 和 TCP，UDP 几乎不对报文进行检查，而 TCP 提供传输保证。 网络层 (Network)：网络层协议由一系列协议组成，包括 ICMP、IGMP、RIP、OSPF、IP(v4,v6) 等。 链路层 (Link)：又称为物理数据网络接口层，负责报文传输。 图１显示了 TCP/IP 层级模型结构，应用层之间的协议通过逐级调用传输层（Transport layer）、网络层（Network Layer）和物理数据链路层（Physical Data Link）而可以实现应用层的应用程序通信互联。 应用层需要关心应用程序的逻辑细节，而不是数据在网络中的传输活动。应用层其下三层则处理真正的通信细节。在 Internet 整个发展过程中的所有思想和着重点都以一种称为 RFC（Request For Comments）的文档格式存在。针对每一种特定的 TCP/IP 应用，有相应的 RFC 文档。一些典型的 TCP/IP 应用有 FTP、Telnet、SMTP、SNTP、REXEC、TFTP、LPD、SNMP、NFS、INETD 等。RFC 使一些基本相同的 TCP/IP 应用程序实现了标准化，从而使得不同厂家开发的应用程序可以互相通信。 然而除了这些已经实现标准化的系统级 TCP/IP 应用程序外，在企业商业应用和互联网应用开发中，存在着大量的商业应用程序通信互联问题。如图 １ 显示，其中的应用层所包含应用程序主要可以分成两类，即系统级应用和商业应用，互联网商业应用是商业应用中的主要形式之一。 不同开发商和用户在开发各自商业应用通信程序时也存在有许多不同的设计方式。关于 TCP/IP 应用层以下的技术文献与书籍早已是汗牛充栋，但是关于 TCP/IP 应用本身，尤其是关于商业应用的通信设计模式技术讨论方面的文章还是比较少的。TCP/IP 应用通信设计模式实际上是在 TCP/IP 基础编程之上的一种应用编程设计方式，也属于一种应用层协议范畴，其可以包含有 TCP/IP 地址族模式设计、I/O 模式设计、通信连接模式设计以及通信数据格式设计等。鉴于目前讨论 TCP/IP 商业应用程序设计模式问题这方面的文章还很少见，本文尝试给出一些通信连接模式设计中共同的概念与一些典型的设计模式，在以后的文章中将继续讨论地址族模式设计、I/O 模式设计、以及通信数据格式设计等方面的模式设计实现话题。 通信连接模式设计主要考虑内容有： 通信两端程序建立通信方式 通信连接方式 通信报文发送与接收方式 以下内容将介绍建立通信的 Client/Server 模型，然后逐一介绍通信连接模式设计所需要考虑的这些内容。 传输层接口 APIs 与 TCP/IP 应用程序 C/S 模型传输层接口 APIsTCP/IP 应用层位于传输层之上，TCP/IP 应用程序需要调用传输层的接口才能实现应用程序之间通信。目前使用最广泛的传输层的应用编程接口是套接字接口（Socket）。Socket APIs 是于 1983 年在 Berkeley Socket Distribution (BSD) Unix 中引进的。 1986 年 AT&amp;T 公司引进了另一种不同的网络层编程接口 TLI（Transport Layer Interface），1988 年 AT&amp;T 发布了一种修改版的 TLI，叫做 XTI（X/open Transport interface）。XTI/TLI 和 Socket 是用来处理相同任务的不同方法。关于 TCP/IP APIs 使用文章与书籍已相当多，本文则是侧重于如何组合使用这些 APIs 来进行 TCP/IP 应用程序连接模式设计，并归纳出几种基本应用连接模式。 如图 ２ 显示，应用层是通过调用传输层接口 APIs（Socket 或 XTI/TLI）来与传输层和网络层进行通信的。 不管是使用何种编程接口，要在两个机器或两个程序之间建立通信，通信双方必须建立互相一致的通信模式。如果双方的通信设计模式不一致就无法建立有效的通信连接。 以下是经常使用的 socket APIs，是建立 TCP/IP 应用程序的标准接口，也是影响 TCP/IP 应用程序通信方式的几个主要 APIs，不同 APIs 组合再结合系统调用可以实现不同方式的应用。Sockets 支持多种传输层和网络层协议，支持面向连接和无连接的数据传输，允许应用分布式工作。 socket()：是用来创建一个 socket，socket 表示通信中的一个节点，其可以在一个网络中被命名，用 socket 描述符表示，socket 描述符类似于 Unix 中的文件描述符。 bind()：是用来把本地 IP 层地址和 TCP 层端口赋予 socket。 listen() ：把未连接的 socket 转化成一个等待可连接的 socket，允许该 socket 可以被请求连接，并指定该 socket 允许的最大连接数。 accept()：是等待一个连接的进入，连接成功后，产生一个新的 socket 描述符，这个新的描述符用来建立与客户端的连接。 connect()：用来建立一个与服务端的连接。 send()：发送一个数据缓冲区，类似 Unix 的文件函数 write()。另外 sendto() 是用在无连接的 UDP 程序中，用来发送自带寻址信息的数据包。 recv()：接收一个数据缓冲区，类似 Unix 的文件函数 readI()。另外 recvfrom() 是用在无连接的 UDP 程序中，用来接收自带寻址信息的数据包。 close()：关闭一个连接 Client/Server 模型Sockets 是以 Client 和 Server 交互通信方式来使用的。典型的系统配置是把 Server 放在一台机器中，而把 Client 放在另一台机器中，Client 连接到 Server 交换信息。一个 socket 有一系列典型的事件流。例如，在面向连接的 Client/Server 模型中，Server 端的 socket 总是等待一个 Client 端的请求。要实现这个请求，Server 端首先需要建立能够被 Client 使用的地址，当地址建立后，Server 等待 Client 请求服务。当一个 Client 通过 socket 连接到 Server 后，Client 与 Server 之间就可以进行信息交换。Client/Server 是通信程序设计的基本模式。从软件开发的角度讲，TCP/IP 应用程序都是基于 Client/Server 方式的。注意本篇文章以下 Client/Server 概念是针对程序内部调用 Socket API 所讲的概念，与针对整个程序甚至针对机器而讲的客户端 / 服务器概念有所不同。用 Server APIs 建立的程序可以被当作客户端使用，用 Client APIs 建立的程序也可以被用作服务器端使用。建立 Server 需要的 APIs 有 socket(), bind(), listen(), accept()，建立 Client 需要的 APIs 有 Socket(), Connect()。在实际应用开发中，同一个程序里往往同时可以有 Client 和 Server 的代码，或者多种形式的组合。在实际应用编程中，针对 Socket APIs 不同有效组合，结合系统调用可以有多种复杂的设计变化。 面向连接的应用编程存在三类基本的不同级别的设计方式范畴，根据 Socket APIs 从上到下顺序依次是： Client/Server 通信建立方式 Client/Server 通信连接方式 Client/Server 通信发送与接收方式 下面内容以面向连接的 Socket 应用编程为例来说明这几种不同通信范畴的设计实现。 Client/Server 建立方式设计概述一个 Client 连接一个 Server如果只有两台机器之间连接，那么一个是 Client，另一个是 Server，如下面图 3 所示。这是最简单的 TCP/IP 的应用，也是 TCP/IP 应用早期的 Peer to Peer (P2P) 概念。其流程基本如图 ４ 所示。 图 4 显示了 TCP/IP 应用编程最基本的 Client/Server 模式，显示了基本的 Client/Server 通信所需要调用的 Socket APIs 以及顺序。 多个 Client 连接一个 Server多个 Client 同时连接一个 Server 是 TCP/IP 应用的主流形式，如图 ５ 所示，其中 Client 连接数可以从几个到成千上万。 由于 socket APIs 缺省方式下都是阻塞方式的，实现多个 Client 同时连接一个 Server 就需要特别的设计。其实现方式可以有多种不同的设计，这其中也涉及 I/O 模式设计。下面将展开介绍其中几种设计形式。 利用一个 Client 连接一个 Server 形式实现多 Client 连接从程序设计角度讲，只要 Client 和 Server 端口是一对一形式，那么就属于一个 Client 连接一个 Server 形式。在处理多个 Client 端连接时，Server 端轮流使用多个端口建立多个 Client-Server 连接，连接关闭后，被释放端口可以被循环使用。在这种多连接形式中需要谨慎处理 Client 端如何获取使用 Server 端的可用端口。比如图 ６ 显示 Server 有一个服务于所有进程的进程可以先把 Server 端的可用端口发送给 Client 端，Client 端再使用该端口建立连接来处理业务。Server 针对每一个 Client 连接用一个专门的进程来处理。由于可用端口数有限，Server 用一个有限循环来处理每一个可用的端口连接。由于新端口需要用 bind() 来绑定，所以需要从 bind() 开始到 close() 结束都需要包含在循环体内。 使用多个 accept() 实现多 Client 连接多进程 Server 一般有一个专注进程是服务于每一个连接的。当 Client 端完成连接后，专注进程可以循环被另外的连接使用。使用多个 accept() 也可以实现处理多 Client 连接。多 accept() 的 Server 也只有一个 socket()，一个 bind()，一个 listen()，这与通常情况一样。但是它建立许多工作子进程，每一个工作子进程都有 accept()，这样可以为每一个 Client 建立 socket 描述符。如图 ７ 所示，由于 accept() 连接成功后，会产生一个新的 socket 描述符，这样通过循环多进程利用 accept() 产生的多 socket 描述符就可以与多个 Client 进行连接通信。循环体是从 accept() 开始到 close() 结束的。 使用并发 Server 模式实现多 Client 连接并发服务器模式曾经是 TCP/IP 的主流应用程序设计模式，得到广泛使用，目前互联网上仍有相当多的应用使用此种模式。其设计思路是在 accept 之后 fork 出一个子进程。因为 socket 会产生监听 socket 描述符 listenfd，accept 会产生连接 socket 描述符 connfd。连接建立后，子进程继承连接描述符服务于 Client，父进程则继续使用监听描述符等待另外一个 Client 的连接请求，以产生另外一个连接 socket 描述符和子进程。如图 ８ 所示，accept() 接收到一个 Client 连接后，产生一个新的 socket 描述符，通过 fork() 系统调用，用一个子进程来处理该 socket 描述符的连接服务。而父进程可以立即返回到 accept()，等待一个新的 Client 请求，这就是典型的并发服务器模式。并发服务器模式同时处理的最大并发 Client 连接数由 listen() 的第二个参数来指定。 使用 I/O 多路技术实现多 Client 连接 以上三种连接设计，多 Server 端口、多 accept() 和并发服务器模式，都是通过 fork() 系统调用产生多进程来实现多 Client 连接的。使用 I/O 多路技术也可以同时处理多个输入与输出问题，即用一个进程同时处理多个文件描述符。I/O 多路技术是通过 select() 或 poll() 系统调用实现的。poll() 与 select() 功能完全相同，但是 poll() 可以更少使用内存资源以及有更少的错误发生。select() 调用需要与操作文件描述符集的 APIs 配合使用。select() 系统调用可以使一个进程检测多个等待的 I/O 是否准备好，当没有设备准备好时，select() 处于阻塞状态中，其中任一设备准备好后，select() 函数返回调用。select() API 本身也有一个超时时间参数，超时时间到后，无论是否有设备准备好，都返回调用。其流程如图 9 所示。在 socket APIs listen() 和 accept() 之间插入 select() 调用。使用这三个宏 FD_ZERO()、FD_CLR() 和 FD_SET()，在调用 select() 前设置 socket 描述符屏蔽位，在调用 select() 后使用 FD_ISSET 来检测 socket 描述符集中对应于 socket 描述符的位是否被设置。 FD_ISSET() 就相当通知了一个 socket 描述符是否可以被使用，如果该 socket 描述符可用，则可对该 socket 描述符进行读写通信操作。通常，操作系统通过宏 FD_SETSIZE 来声明在一个进程中 select() 所能操作的文件或 socket 描述符的最大数目。更详细的 I/O 多路技术实现，可以参考其他相关文献。 一个 Client 连接多个 Server一个 Client 连接多个 Server 这种方式很少见，主要用于一个客户需要向多个服务器发送请求情况，比如一个 Client 端扫描连接多个 Server 端情况。如图 １０ 所示。此种方式设计主要是 Client 端应用程序的逻辑设计，通常需要在 Client 端设计逻辑循环来连接多个 Server，在此不做更多描述。 复杂 Client/Server 设计与现代 P2P最近几年，对等网络技术 ( Peer-to-Peer，简称 P2P) 迅速成为计算机界关注的热门话题之一，以及影响 Internet 未来的科技之一。与早期点对点 (Peer to Peer) 的 Client/Server 模式不同，现在的 P2P 模式是指每个结点既可充当服务器，为其他结点提供服务，同时也可作为客户端享用其他结点提供的服务。实际上 P2P 模式仍然是基于 Client/Server 模式的，每个通信节点都既是 Server，又是 Client，P2P 是基于复杂 Client/Server 设计的 TCP/IP 应用。图 １１ 显示 P2P 模式下两个用户 PC 之间的对等连接。 在技术上，P2P 本身是基于 TCP/IP Client/Server 技术的一种设计模式思想， P2P 也属于网络应用层技术，与 Web 和 FTP 等应用是并列的。只是 P2P 应用在设计实现上更要复杂的多。P2P 技术实现的协同工作是无需专门的服务器支持的 (Serverless)，这里的服务器概念与 Client/Server 中的 Server 概念是不一样的。在传统意义上中心服务器机器上往往运行的是 TCP/IP 应用的 Server 端程序，所以传统意义上的 Server 概念在机器与应用上是重合的。如果更改 TCP/IP 的应用设计，使应用程序既可做 Server 又可做 Client，就可以实现无中心服务器的 P2P 模式。 在设计模式上，P2P 模式实现了网络终端用户不依赖中心服务器或者服务商而直接进行信息和数据交换的可能，因此 P2P 正在改变着整个互联网的一些基础应用，从而极大地增加了用户之间的信息沟通和交流能力。目前互联网的 P2P 应用与网络都正在飞速发展，一些典型的 P2P 应用程序比如有 BitTorrent, eDonkey 等，另外一些即时通信（IM）类软件比如 MSN、QQ 等也正在向无中心服务器模式转变。无中心服务器的 Internet 应用程序大大降低应用提供商的运营成本，而且减少人们对于 Server 稳定性的依赖。 Client/Server 通信连接方式设计Client/Server 通信方式建立后，下一步就需要考虑通信连接的方式，主要有两种方式的连接，即长连接通信与短连接通信。通信连接方式涉及到的 APIs 主要是 connect() 和 accept()。要实现某种 Client/Server 方式，就必须考虑用某种特定的连接方式。 短连接通信短连接通信是指 Client 方与 Server 方每进行一次通信报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于多个 Client 连接一个 Server 情况，常用于机构与用户之间通信，比如 OLTP（联机事务处理）类应用。在短连接情况下，Client 端完成任务后，就关闭连接并退出。在 Server 端，可以通过循环 accept()，使 Server 不会退出，并连续处理 Client 的请求。图 １２ 显示了一般情况下短连接通信模式的 Socket 事件流，不同设计的连接多 Client 的 Server 有不同的循环流程。 长连接通信长连接通信是指 Client 方与 Server 方先建立通讯连接，连接建立后不会断开，然后再进行报文发送和接收，报文发送与接收完毕后，原来连接不会断开而继续存在，因此可以连续进行交易报文的发送与接收。这种方式下由于通讯连接一直存在，其 TCP/IP 状态是 Established，可以用操作系统的命令 netstat 查看连接是否建立。由于在长连接情况下，Client 端和 Server 端一样可以固定使用一个端口，所以长连接下的 Client 也需要使用 bind() 来绑定 Client 的端口。在长连接方式下，需要循环读写通信数据。为了区分每一次交易的通信数据，每一次交易数据常常需要在数据头部指定该次交易的长度，接收 API 需要首先读出该长度，然后再按该长度读出指定长度的字节。长连接方式常用于一个 Client 端对一个 Server 端的通讯，一般常用于机构与机构之间的商业应用通信，以处理机构之间连续的大量的信息数据交换。或者说可用于两个系统之间持续的信息交流情况。通常为了加快两个系统之间的信息交流，通常还需要建立几条长连接的并行通信线路。图 １３ 显示了一般情况下长连接通信模式的 socket 事件流，可见其最大特点是 Client 和 Server 都有循环体，而且循环体只包含读写 APIs。 Client/Server 通信发送与接收方式设计在通信数据发送与接收之间也存在不同的方式，即同步和异步两种方式。这里的同步和异步与 I/O 层次的同异步概念不同。主要涉及 socket APIs recv() 和 send() 的不同组合方式。 同步发送与接收从应用程序设计的角度讲，报文发送和接收是同步进行的，既报文发送后，发送方等待接收方返回消息报文。同步方式一般需要考虑超时问题，即报文发出去后发送方不能无限等待，需要设定超时时间，超过该时间后发送方不再处于等待状态中，而直接被通知超时返回。同步发送与接收经常与短连接通信方式结合使用，称为同步短连接通信方式，其 socket 事件流程可如上面的图 １２ 所示。 异步发送与接收从应用程序设计的角度讲，发送方只管发送数据，不需要等待接收任何返回数据，而接收方只管接收数据，这就是应用层的异步发送与接收方式。要实现异步方式，通常情况下报文发送和接收是用两个不同的进程来分别处理的，即发送与接收是分开的，相互独立的，互不影响。异步发送与接收经常与长连接通信方式结合使用，称为异步长连接通信方式。从应用逻辑角度讲，这种方式又可分双工和单工两种情况。 异步双工异步双工是指应用通信的接收和发送在同一个程序中，而有两个不同的子进程分别负责发送和接收，异步双工模式是比较复杂的一种通信方式，有时候经常会出现在不同机构之间的两套系统之间的通信。比如银行与银行之间的信息交流。它也可以适用在现代 P2P 程序中。如图 １４ 所示，Server 和 Client 端分别 fork 出两个子进程，形成两对子进程之间的连接，两个连接都是单向的，一个连接是用于发送，另一个连接用于接收，这样方式的连接就被称为异步双工方式连接。 异步单工应用通信的接收和发送是用两个不同的程序来完成，这种异步是利用两对不同程序依靠应用逻辑来实现的。图 １５ 显示了长连接方式下的异步单工模式，在通信的 A 和 B 端，分别有两套 Server 和 Client 程序，B 端的 Client 连接 A 端的 Server，A 端的 Server 只负责接收 B 端 Client 发送的报文。A 端的 Client 连接 B 端的 Server，A 端 Client 只负责向 B 端 Server 发送报文。 典型通信连接模式综上所述，在实际 TCP/IP 应用程序设计中，就连接模式而言，我们需要考虑 Client/Server 建立方式、Client/Server 连接方式、Client/Server 发送与接收方式这三个不同级别的设计方式。实际 TCP/IP 应用程序连接模式可以是以上三类不同级别 Client/Server 方式的组合。比如一般 TCP/IP 相关书籍上提供的 TCP/IP 范例程序大都是同步短连接的 Client/Server 程序。有的组合是基本没有实用价值的，比较常用的有价值的组合是以下几种： 同步短连接 Server/Client 同步长连接 Server/Client 异步短连接 Server/Client 异步长连接双工 Server/Client 异步长连接单工 Server/Client 其中异步长连接双工是较为复杂的一种通信方式，有时候经常会出现在不同银行或不同城市之间的两套系统之间的通信，比如国家金卡工程。由于这几种通信方式比较固定，所以可以预先编制这几种通信方式的模板程序。 总结本文探讨了 TCP/IP 应用程序中连接模式的设计。在以后的文章中还将继续讨论 TCP/IP 应用程序设计中的其他方面的设计话题，包括地址族模式设计、I/O 模式设计、以及通信数据格式设计等。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议族(一) HTTP简介、请求方法与响应状态码]]></title>
    <url>%2F2018%2F01%2F04%2FTCP%3AIP%E5%8D%8F%E8%AE%AE%E6%97%8F(%E4%B8%80)%20HTTP%E7%AE%80%E4%BB%8B%E3%80%81%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B8%8E%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[转载：http://www.cnblogs.com/ludashi/p/6232060.html 接下来想系统的回顾一下TCP/IP协议族的相关东西，当然这些东西大部分是在大学的时候学过的，但是那句话，基础的东西还是要不时的回顾回顾的。接下来的几篇博客都是关于TCP/IP协议族的，本篇博客就先简单的聊一下TCP/IP协议族，然后聊一下HTTP协议，然后再聊一下SSL上的HTTP（也就是HTTPS）了。当然TCP/IP协议族是个老生常谈的话题，网络上关于该内容的文章一抓一大把呢，但是鉴于其重要性，还是有必要系统的总结一下的。 TCP/IP协议组简述在聊HTTP与HTTPS之前呢，我们先简单的聊一下TCP/IP协议族。TCP/IP不单单指的就是TCP和IP这两个协议，而是指的与其相关的各种协议。比如HTTP, FTP, DNS, TCP, UDP, IP, SNMP等等都属于TCP/IP协议族的范畴。 TCP/IP协议的分层TCP/IP协议族是分层管理的，在OSI标准中可以分为7层（应用层、表示层、会话层、传输层、网络层、数据链路层、物理层，可记为：应表会传网数物），本篇博客我们采用的是TCP/IP协议族中的四层（应用层、传输层、网络层、链路层）。下方是对四层中每层的简单介绍： 应用层：该层是面向用户的一层，也就是说用户可以直接操作该层，该层决定了向用户提供应用服务时的通信活动。本篇博客要聊的HTTP（HyperText Transfer Protocol：超文本传输协议）就位于该层。我们经常使用的FTP(File Transfer Protocol: 文件传输协议)和DNS (Domain Name System: 域名系统)都位于该层。FTP简单的说就是用来文件传输的。而DNS则负责域名解析的，通过DNS可以将域名（比如：www.cnblogs.com）与IP地址（201.33.xx.09）进行相互的转换。在7层中，又将该层分为：应用层、表示层和会话层。 传输层：应用层的下方是传输层，应用层胡将数据交付给传输层进行传输。TCP(Transmission Control Prococol:传输控制协议)和UDP(User Data Protocol: 用户数据协议)位于该层，当然见名知意，该层是用来提供处于网络连接中的两台计算机直接的数据传输的。TCP建立连接是需要三次握手来确认连接情况，而UDP则没有三次握手的过程。稍后会介绍。 网络层：传输层的下方是网络层，网络层用来处理在网络上流动的数据包，IP(Internet Protocol: 网际协议)就位于这层。该层负责在众多网络线路中选择一条传输线路。当然这个选择传输线路的过程需要IP地址和MAC地址的支持。 链路层：在7层协议中，将链路层分为数据链路层和物理层。该部分主要是用来处理网络的硬件部分，我们常说的NIC（Net Work Card），也就是网卡就位于这一部分，当然光纤也是链路层的一部分。 在TCP/IP协议族中的每次直接在传输数据时的协作关系，以及交互过程，还是引用《图解HTTP》一书上的一张图来解释吧。下图就是这四层协议在数据传输过程中的工作方式。下面这张图还是相当直观的。在发送端是应用层–&gt;链路层这个方向的封包过程，没经过一层都会增加该层的头部。而接收端则是从链路层–&gt;应用层解包的过程，每经过一层则会去掉相应的首部。 TCP协议的三次握手在聊HTTP协议之前，我们先简单的聊一下TCP三次握手的过程，在后面的博客中我们将会对TCP和IP协议进行详述，本篇博客就先简单的聊一下做HTTP协议的基础。 TCP协议位于传输层，为了确保传输的可靠性，TCP协议在建立连接时需要三次握手（Three-way handshaking）。下方这个简图就是TCP协议建立连接时三次握手的过程。 第一次握手：发送端发送一个带SYN(Synchronize)标志的数据包给接收端，用于询问接收端是否可以接收。如果可以，就进行第二次握手。 第二次握手：接收端回传给发送端一个带有SYN/ACK(Acknowledgement)的数据包，给发送端说，我收到你给我发送的SYN标志了，我再给你传一个ACK标志，你能收到吗？如果发送端收到了SYN/ACK这个数据包，就可以确认接收端收到了之前发送的SYN, 然后进行第三次握手。 第三次握手：发送端会给接收端发送一个带有ACK标志的数据包，告诉接收端我可以收到你给我发送的SYN/ACK标志。接收端如果收到了这个来自客户端的ACK标志，就意味着三次握手完成，连接建立，就可以开始传输数据了。 HTTP报文结构HTTP协议全称是HyperText Transfer Protocol，即超文本传输协议，用户客户端和服务器之前的通信，目前普遍使用版本为HTTP/1.1。协议本质上就是规范，我们之前提到过的“面向接口”编程，其实就是“面向协议”编程。先定义好类的协议，也就是接口，相关类都遵循该协议，这样一来我们就规范了这些类的调用方式。而HTTP协议是规范客户端和服务器之间通信的协议。也就是说所有的客户端或者服务器都遵循了HTTP这个通信协议，那么也就是意味着他们对外传输数据的接口是一直的，就可以在其中间连接上管道，这样一来就可以进行传输了。 这些协议就是接口，有着共同的通信协议，多个端就可以相互通信。采用相同的协议，就是便于个个设备之间进行沟通交流。HTTP协议的作用如下所示。 HTTP协议的作用是用来规范通信内容的，在HTTP协议中可以分为请求报文和响应报文。顾名思义，请求报文是请求方发出的信息，而响应报文是响应端收到请求后响应的内容。接下来我们就来看看请求报文和响应报文的整体结构。 请求报文（Request Message）结构下方是请求报文的整体结构。请求报文主要分为两大部分: 一个是请求头（Request Headers） 请求体（Request Body）。 这两者之间由空行分割。在请求头中又分为请求行（Request Line），请求头部字段，通用头部字段和实体头部字段等，这个稍后会详细介绍。下方就是请求报文的结构。 下方这个截图就是请求博客园某个页面时的Request Headers。在请求行中的第一个“GET”是当前请求的方法，稍后会做介绍。中间的就是请求资源的路径，最后一个HTTP/1.1就是当前使用请求协议及其版本。下方这些就是请求头了，稍后会对常用的请求头进行解说。而请求体就是你往服务端传输的数据，比如form表单神马的。 响应报文（Response Message）结构聊完请求报文，接下来我们来聊聊响应报文，响应报文的结构与请求报文的结构类似，也分为报文头和报文体。下方就是响应报文的结构图。响应头（Response Headers）分为状态行（State Line），响应头部字段，通用头部字段、实体头部字段等。响应头与响应体中间也是有空行进行分割的。 下方截图就是上述请求报文发出后的响应头，响应体就是对于的HTML等前端资源了。在响应头中，第一行就是状态行，“HTTP/1.1”表示使用的HTTP协议的1.1版本，状态200表示响应成功，”OK”则是状态原因短语。常用状态，稍后会详细介绍。 HTTP的请求方法以及响应状态码上面在介绍请求报文中提到的“GET”就是请求请求方法，而在响应报文中提到的“200”状态码，就是稍后要聊的响应状态码。请求方法和响应状态码在HTTP协议中算是比较重要的内容了。之前我们在使用Perfect框架开发服务器端的时候，曾聊过请求方法中的GET、POST、PUT以及DELETE，并且这四种方法可以结合着REST使用。本部分是以HTTP协议的角度来聊的请求方法，所以与之前会有稍稍的不同。本部分我们就来聊一下HTTP协议的请求方法和响应状态码。 请求方法接下来我们要聊的请求方法有GET、POST、PUT、HEAD、DELETE、OPTIONS、TRACE、CONNECT。当然上述方法是基于HTTP/1.1的，HTTP/1.0中独有的方法就不说了。 GET—-获取资源GET方法一般用来从服务器上获取资源的方法。服务器端接到GET请求后，就会明白客户端是要从服务器端获取相应的资源，然后就会根据请求报文中相应的参数，将需要的资源返回给客户端。使用GET方式的请求，传输的参数是拼接在URI上的。 POST—-数据提交POST方法一般用于表单提交，将客户端的数据塞到请求体中发送给服务器端。 PUT—-上传文件PUT方法主要用来上传文件，将文件内容塞到请求报文体中，传输给服务器。因为HTTP/1.1的PUT方法自身不带验证机制，所以任何人都可以上传文件，存在安全性，所以上传文件时不推荐使用。但是之前我们在设计接口使用REST标准时，可以使用PUT来做相应内容的更新。 HEAD—-获取响应报文头响应端收到HEAD请求后，只会返回相应的响应头，不会返回响应体。 DELETE—-删除文件DELETE用于删除URI指定的资源，与PUT一样，自身也是不带验证机制的，不过在REST标准中可以用来做相应API的删除功能。 OPTIONS—-查询支持的方法OPTIONS方法是用来查询服务器可对那些请求方法做出相应，返回内容就是响应端所支持的方法。 TRACE—-追踪路径TRACE方法可追踪请求经过的代理路径，在发送请求时会为Max-Forwards头部字段填入数字，每经过一个代理中转Max-Forwards的值就会减一，直至Max-Forwards为零后，才会返回200。因为该方法易引起XST(Cross-Site Tracing，跨站追踪)攻击，所以不常用呢。 CONNECT—-要求用隧道协议连接代理CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL(Secure Sockets Layer, 安全套接层)和TLS(Transport Layer Security, 传输安全层)协议将通信内容进行加密后经网络隧道传输。 响应状态码聊完请求方法后，接下来我们来聊聊HTTP协议的响应状态码。顾名思义，响应状态码是用来标志HTTP响应状态的，响应状态由响应状态码和响应原因短语构成，当然状态码有很多中，本部分就挑出来常用的状态码进行讨论。下方是响应状态码可以分为的几大类： 1xx —- Informational（信息性状态码），表示接受的请求正在处理。 2xx —- Success (成功)，表示请求正常处理完毕。 3xx —- Redirection (重定向)，表示要对请求进行重定向操作，当然其中的304除外。 4xx —- Client Error (客户端错误)，服务器无法处理请求。 5xx —- Server Error (服务器错误)，服务器处理请求时出错。 上面是响应状态码的整体分类，接下来介绍一些常用的响应状态码。 200 OK : 表示服务端正确处理了客户端发送过来的请求。 204 No Content : 表示服务端正确处理请求，但没有报文实体要返回。 206 Partial Content ：表示服务端正确处理了客户端的范围请求，并按照请求范围返回该指定范围内的实体内容。 301 Moved Permanently：永久性重定向，若之前的URI保存到了书签，则更新书签中的URI。 302 Found：临时重定向，该重定向不会变更书签中的内容。 303 See Other：临时重定向，与302功能相同，但是303状态吗明确表示客户端应当采用GET方法获取资源。 304 Not Modified: 资源未变更，该状态码与重定向并没有什么关系，当返回该状态码时，告诉客户端请求的资源并没有更新，响应报文体中并不会返回所请求的内容。 400 Bad Request： 错误请求，表示请求报文中包含语法错误。 401 Unauthorized：请求未认证，表示此发送的请求需要客户端进行HTTP认证（稍后会提到）。 404 Not Found：找不到相应的资源，表示服务器找不到客户端请求的资源。 500 Internal Server Error：服务器内部错误，表示服务器在处理请求时出现了错误，发生了异常。 503 Service Unavailable：服务不可用，表示服务器处于停机状态，无法处理客户端发来的请求。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6模块Modules]]></title>
    <url>%2F2018%2F01%2F03%2FES6%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[详解见：https://likebeta.gitbooks.io/es6tutorial/content/docs/module.html?q= importimport语句用于导入由另一个模块导出的绑定。 现在浏览器们才刚刚开始去实现这个功能。但它在许多转换器中已经实现，例如 Traceur Compiler ， Babel ， Rollup 或 Webpack。 语法123456789import defaultExport from "module-name";import * as name from "module-name";import &#123; export &#125; from "module-name";import &#123; export as alias &#125; from "module-name";import &#123; export1 , export2 &#125; from "module-name";import &#123; export1 , export2 as alias2 , [...] &#125; from "module-name";import defaultExport, &#123; export [ , [...] ] &#125; from "module-name";import defaultExport, * as name from "module-name";import "module-name"; name description defaultExport 将引用模块默认导出的名称。 module-name 要导入的模块。这通常是包含模块的.js文件的相对或绝对路径名，不包括.js扩展名。某些打包工具可以允许或要求使用该扩展；检查你的环境。只允许单引号和双引号的字符串。 name 引用时将用作一种命名空间的模块对象的名称。 alias, aliasN 将引用指定的导入的名称。 描述name参数是“模块对象”的名称，它将用一种名称空间来引用导出。导出参数指定单个命名导出，而import * as name语法导入所有导出。以下示例阐明该语法。 导入整个模块的内容这将myModule插入当前作用域，其中包含来自位于/modules/my-module.js文件中导出的所有模块。 1import * as myModule from '/modules/my-module.js'; 在这里，访问导出意味着使用模块名称（在这种情况下为“myModule”）作为命名空间。例如，如果上面导入的模块包含一个doAllTheAmazingThings()，你可以这样调用： 1myModule.doAllTheAmazingThings(); 导入单个导出给定一个名为myExport的对象或值，它已经从模块my-module导出（因为整个模块被导出）或显式地导出（使用export语句），将myExport插入当前作用域。 1import &#123;myExport&#125; from '/modules/my-module.js'; 导入多个导出这将foo和bar插入当前作用域。 1import &#123;foo, bar&#125; from '/modules/my-module.js'; 导入带有别名的导出导入时可以重命名导出。例如，将shortName插入当前作用域。 1import &#123;reallyReallyLongModuleExportName as shortName&#125; from '/modules/my-module.js'; 导入时重命名多个导出 使用别名导入模块的多个导出。 1234import &#123; reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short&#125; from "my-module"; 导入默认值可以使用默认export（无论是对象，函数，类等）。然后可以使用import语句来导入这样的默认值。 最简单版本，直接导入默认值： 1import myDefault from "my-module"; 也可以使用默认语法与上述（命名空间导入或命名导入）。在这种情况下，默认导入将必须首先声明。 例如： 12import myDefault, * as myModule from "my-module";// myModule used as a namespace 或者 12import myDefault, &#123;foo, bar&#125; from "my-module";// specific, named imports 示例从辅助模块导入以协助处理AJAX JSON请求。 模块：file.js从辅助模块导入以协助处理AJAX JSON请求。 123456789101112function getJSON(url, callback) &#123; let xhr = new XMLHttpRequest(); xhr.onload = function () &#123; callback(this.responseText) &#125;; xhr.open('GET', url, true); xhr.send();&#125;export function getUsefulContents(url, callback) &#123; getJSON(url, data =&gt; callback(JSON.parse(data)));&#125; 主程序：main.js 1234import &#123; getUsefulContents &#125; from '/modules/file.js';getUsefulContents('http://www.example.com', data =&gt; &#123; doSomethingUseful(data); &#125;); exportexport语句用于在创建JavaScript模块时，从模块中导出函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。 此特性目前仅在 Safari 和 Chrome 原生实现。它在许多转换器中实现，如Traceur Compiler，Babel或Rollup。 语法12345678910111213export &#123; name1, name2, …, nameN &#125;;export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;export let name1, name2, …, nameN; // also varexport let name1 = …, name2 = …, …, nameN; // also var, constexport default expression;export default function (…) &#123; … &#125; // also class, function*export default function name1(…) &#123; … &#125; // also class, function*export &#123; name1 as default, … &#125;;export * from …;export &#123; name1, name2, …, nameN &#125; from …;export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …; name description nameN 导出的标识符（用来被其他脚本的 import 导入） 描述有两种不同的导出方式，每种方式对应于上述的一种语法： 命名导出： 12345// exports a function declared earlier 导出前面声明的函数export &#123; myFunction &#125;; // exports a constant(常数)export const foo = Math.sqrt(2); 默认导出（函数）： 1export default function() &#123;&#125; 默认导出（类）： 1export default class &#123;&#125; 命名导出对导出多个值很有用。在导入期间，必须使用相应对象的相同名称。但是，可以使用任何名称导入默认导出，例如： 1234567export default k = 12; // in file test.js(在test.js 中)// -------分割线-------------import m from './test' // note that we got the freedom to use import m instead of import k, because k was default exportconsole.log(m); // will log 12 只能有一个默认的导出以下语法不会导出已导入模块中的默认导出： 1export * from …; 示例使用命名导出在模块中，我们可以使用以下代码： 123456// module "my-module.js"export function cube(x) &#123; return x * x * x;&#125;const foo = Math.PI + Math.SQRT2;export &#123; cube,foo &#125;; 这样的话，在其它脚本 (比如import)，我们可以这样使用： 123import &#123; cube, foo &#125; from 'my-module.js';console.log(cube(3)); // 27console.log(foo); // 4.555806215962888 使用默认导出如果我们要导出一个值或模块中的返回值，就可以使用默认导出： 1234// module "my-module.js"export default function cube(x) &#123; return x * x * x;&#125; 然后，在另一个脚本中，可以直接导入默认导出： 123// module "my-module.js"import cube from 'my-module';console.log(cube(3)); // 27​​​​​ 注意，不能使用var，let或const作为默认导出。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator函数详解]]></title>
    <url>%2F2018%2F01%2F03%2FGenerator%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[引用：https://likebeta.gitbooks.io/es6tutorial/content/docs/generator.html 简介基本概念 Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。 Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。 执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。 形式上，Generator函数是一个普通函数，但是有两个特征。 一是，function关键字与函数名之间有一个星号； 二是，函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。 1234567function* helloWorldGenerator() &#123;yield 'hello';yield 'world';return 'ending';&#125;var hw = helloWorldGenerator(); 上面代码定义了一个Generator函数helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello，world和return语句（结束执行）。 然后，Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象(遍历器对象（Iterator Object）)。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。 1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 上面代码一共调用了四次next方法。 第一次调用，Generator函数开始执行，直到遇到第一个yield语句为止。next方法返回一个对象，它的value属性就是当前yield语句的值hello，done属性的值false，表示遍历还没有结束。 第二次调用，Generator函数从上次yield语句停下的地方，一直执行到下一个yield语句。next方法返回的对象的value属性就是当前yield语句的值world，done属性的值false，表示遍历还没有结束。 第三次调用，Generator函数从上次yield语句停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。 第四次调用，此时Generator函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。总结一下，调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。ES6没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。 1234567function * foo(x, y) &#123; ··· &#125;function *foo(x, y) &#123; ··· &#125;function* foo(x, y) &#123; ··· &#125;function*foo(x, y) &#123; ··· &#125; 由于Generator函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。 yield语句由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。+ 如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。+ 如果该函数没有return语句，则返回的对象的value属性值为undefined。+ 需要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 123function* gen() &#123;yield 123 + 456;&#125; 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。 yield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。正常函数只能返回一个值，因为只能执行一次return；Generator函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说Generator生成了一系列的值，这也就是它的名称的来历（在英语中，generator这个词是“生成器”的意思）。+ Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。 123456789function* f() &#123;console.log('执行了！')&#125;var generator = f();setTimeout(function () &#123;generator.next()&#125;, 2000); 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个Generator函数，就变成只有调用next方法时，函数f才会执行。另外需要注意，yield语句不能用在普通函数中，否则会报错。 1234(function ()&#123;yield 1;&#125;)()// SyntaxError: Unexpected number 上面代码在一个普通函数中使用yield语句，结果产生一个句法错误。+ 下面是另外一个例子。+ 123456789101112131415var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123;a.forEach(function (item) &#123;if (typeof item !== 'number') &#123;yield* flat(item);&#125; else &#123;yield item;&#125;&#125;&#125;;for (var f of flat(arr))&#123;console.log(f);&#125; 上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield语句（这个函数里面还使用了yield*语句，这里可以不用理会，详细说明见后文）。一种修改方法是改用for循环。+ 123456789101112131415161718var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123;var length = a.length;for (var i = 0; i &lt; length; i++) &#123;var item = a[i];if (typeof item !== 'number') &#123;yield* flat(item);&#125; else &#123;yield item;&#125;&#125;&#125;;for (var f of flat(arr)) &#123;console.log(f);&#125;// 1, 2, 3, 4, 5, 6 另外，yield语句如果用在一个表达式之中，必须放在圆括号里面。+ 12345console.log('Hello' + yield); // SyntaxErrorconsole.log('Hello' + yield 123); // SyntaxErrorconsole.log('Hello' + (yield)); // OKconsole.log('Hello' + (yield 123)); // OK yield语句用作函数参数或赋值表达式的右边，可以不加括号。+ 12foo(yield 'a', yield 'b'); // OKlet input = yield; // OK 与Iterator接口的关系任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。+由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。+ 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123;yield 1;yield 2;yield 3;&#125;;[...myIterable] // [1, 2, 3] 上面代码中，Generator函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了Iterator接口，可以被…运算符遍历了。 Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。+ 12345678function* gen()&#123;// some code&#125;var g = gen();g[Symbol.iterator]() === g// true 上面代码中，gen是一个Generator函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。+ next方法的参数yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。+ 123456789101112function* f() &#123;for(var i=0; true; i++) &#123;var reset = yield i;if(reset) &#123; i = -1; &#125;&#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。+ 再看一个例子。 123456789101112131415function* foo(x) &#123;var y = 2 * (yield (x + 1));var z = yield (y / 3);return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; 上面代码中，第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN），除以3以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层。 123456789101112131415function wrapper(generatorFunction) &#123;return function (...args) &#123;let generatorObject = generatorFunction(...args);generatorObject.next();return generatorObject;&#125;;&#125;const wrapped = wrapper(function* () &#123;console.log(`First input: $&#123;yield&#125;`);return 'DONE';&#125;);wrapped().next('hello!')// First input: hello! 上面代码中，Generator函数如果不用wrapper先包一层，是无法第一次调用next方法，就输入参数的。再看一个通过next方法的参数，向Generator函数内部输入值的例子。 1234567891011121314function* dataConsumer() &#123;console.log('Started');console.log(`1. $&#123;yield&#125;`);console.log(`2. $&#123;yield&#125;`);return 'result';&#125;let genObj = dataConsumer();genObj.next();// StartedgenObj.next('a')// 1. agenObj.next('b')// 2. b 上面代码是一个很直观的例子，每次通过next方法向Generator函数输入值，然后打印出来。 for…of循环for…of循环可以自动遍历调用Generator函数时生成的Iterator对象，且此时不再需要调用next方法。 12345678910111213function *foo() &#123;yield 1;yield 2;yield 3;yield 4;yield 5;return 6;&#125;for (let v of foo()) &#123;console.log(v);&#125;// 1 2 3 4 5 上面代码使用for…of循环，依次显示5个yield语句的值。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。下面是一个利用Generator函数和for…of循环，实现斐波那契数列的例子。 123456789101112function* fibonacci() &#123;let [prev, curr] = [0, 1];for (;;) &#123;[prev, curr] = [curr, prev + curr];yield curr;&#125;&#125;for (let n of fibonacci()) &#123;if (n &gt; 1000) break;console.log(n);&#125; 从上面代码可见，使用for…of语句时不需要使用next方法。+ 前面章节曾经介绍过，for…of循环、扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们可以将Generator函数返回的Iterator对象，作为参数。+ 1234567891011121314151617181920function* numbers () &#123;yield 1yield 2return 3yield 4&#125;[...numbers()] // [1, 2]Array.from(numbers()) // [1, 2]let [x, y] = numbers();x // 1y // 2for (let n of numbers()) &#123;console.log(n)&#125;// 1// 2 利用for…of循环，可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用for…of循环，通过Generator函数为它加上这个接口，就可以用了。 123456789101112131415function* objectEntries(obj) &#123;let propKeys = Reflect.ownKeys(obj);for (let propKey of propKeys) &#123;yield [propKey, obj[propKey]];&#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123;console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 上面代码中，对象jane原生不具备Iterator接口，无法用for…of遍历。这时，我们通过Generator函数objectEntries为它加上遍历器接口，就可以用for…of遍历了。加上遍历器接口的另一种写法是，将Generator函数加到对象的Symbol.iterator属性上面。+ 1234567891011121314151617function* objectEntries() &#123;let propKeys = Object.keys(this);for (let propKey of propKeys) &#123;yield [propKey, this[propKey]];&#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123;console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe Generator.prototype.throw()Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。+ 12345678910111213141516171819var g = function* () &#123;try &#123;yield;&#125; catch (e) &#123;console.log('内部捕获', e);&#125;&#125;;var i = g();i.next();try &#123;i.throw('a');i.throw('b');&#125; catch (e) &#123;console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被Generator函数体内的catch语句捕获。i第二次抛出错误，由于Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获。+ throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。+ 123456789101112var g = function* () &#123;try &#123;yield;&#125; catch (e) &#123;console.log(e);&#125;&#125;;var i = g();i.next();i.throw(new Error('出错了！'));// Error: 出错了！(…) 注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。+ 123456789101112131415161718192021var g = function* () &#123;while (true) &#123;try &#123;yield;&#125; catch (e) &#123;if (e != 'a') throw e;console.log('内部捕获', e);&#125;&#125;&#125;;var i = g();i.next();try &#123;throw new Error('a');throw new Error('b');&#125; catch (e) &#123;console.log('外部捕获', e);&#125;// 外部捕获 [Error: a] 上面代码中，Generator函数g内部没有部署try…catch代码块，所以抛出的错误直接被外部catch代码块捕获。+ 如果Generator函数内部和外部，都没有部署try…catch代码块，那么程序将报错，直接中断执行。+ 12345678910var gen = function* gen()&#123;yield console.log('hello');yield console.log('world');&#125;var g = gen();g.next();g.throw();// hello// Uncaught undefined 上面代码中，g.throw抛出错误以后，没有任何try…catch代码块可以捕获这个错误，导致程序报错，中断执行。+ throw方法被捕获以后，会附带执行下一条yield语句。也就是说，会附带执行一次next方法。+ 1234567891011121314var gen = function* gen()&#123;try &#123;yield console.log('a');&#125; catch (e) &#123;// ...&#125;yield console.log('b');yield console.log('c');&#125;var g = gen();g.next() // ag.throw() // bg.next() // c 上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要Generator函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。 另外，throw命令与g.throw方法是无关的，两者互不影响。+ 123456789101112131415var gen = function* gen()&#123;yield console.log('hello');yield console.log('world');&#125;var g = gen();g.next();try &#123;throw new Error();&#125; catch (e) &#123;g.next();&#125;// hello// world 上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都进行了正确的操作。+ 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield语句，可以只用一个try…catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在Generator函数内部写一次catch语句就可以了。+ Generator函数体外抛出的错误，可以在函数体内捕获；反过来，Generator函数体内抛出的错误，也可以被函数体外的catch捕获。 123456789101112131415function *foo() &#123;var x = yield 3;var y = x.toUpperCase();yield y;&#125;var it = foo();it.next(); // &#123; value:3, done:false &#125;try &#123;it.next(42);&#125; catch (err) &#123;console.log(err);&#125; 上面代码中，第二个next方法向函数体内传入一个参数42，数值是没有toUpperCase方法的，所以会抛出一个TypeError错误，被函数体外的catch捕获。+ 一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了。 123456789101112131415161718192021222324252627282930313233343536373839function* g() &#123;yield 1;console.log('throwing an exception');throw new Error('generator broke!');yield 2;yield 3;&#125;function log(generator) &#123;var v;console.log('starting generator');try &#123;v = generator.next();console.log('第一次运行next方法', v);&#125; catch (err) &#123;console.log('捕捉错误', v);&#125;try &#123;v = generator.next();console.log('第二次运行next方法', v);&#125; catch (err) &#123;console.log('捕捉错误', v);&#125;try &#123;v = generator.next();console.log('第三次运行next方法', v);&#125; catch (err) &#123;console.log('捕捉错误', v);&#125;console.log('caller done');&#125;log(g());// starting generator// 第一次运行next方法 &#123; value: 1, done: false &#125;// throwing an exception// 捕捉错误 &#123; value: 1, done: false &#125;// 第三次运行next方法 &#123; value: undefined, done: true &#125;// caller done 上面代码一共三次运行next方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator函数就已经结束了，不再执行下去了。+ Generator.prototype.return()Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。+ 1234567891011function* gen() &#123;yield 1;yield 2;yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: "foo", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。 如果return方法调用时，不提供参数，则返回值的value属性为undefined。+ 12345678910function* gen() &#123;yield 1;yield 2;yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return() // &#123; value: undefined, done: true &#125; 如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。+ 1234567891011121314151617function* numbers () &#123;yield 1;try &#123;yield 2;yield 3;&#125; finally &#123;yield 4;yield 5;&#125;yield 6;&#125;var g = numbers()g.next() // &#123; done: false, value: 1 &#125;g.next() // &#123; done: false, value: 2 &#125;g.return(7) // &#123; done: false, value: 4 &#125;g.next() // &#123; done: false, value: 5 &#125;g.next() // &#123; done: true, value: 7 &#125; 上面代码中，调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法。+ yield*语句如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的。+ 12345678910111213141516function* foo() &#123;yield 'a';yield 'b';&#125;function* bar() &#123;yield 'x';foo();yield 'y';&#125;for (let v of bar())&#123;console.log(v);&#125;// "x"// "y" 上面代码中，foo和bar都是Generator函数，在bar里面调用foo，是不会有效果的。+ 这个就需要用到yield*语句，用来在一个Generator函数里面执行另一个Generator函数。 123456789101112131415161718192021222324252627282930function* bar() &#123;yield 'x';yield* foo();yield 'y';&#125;// 等同于function* bar() &#123;yield 'x';yield 'a';yield 'b';yield 'y';&#125;// 等同于function* bar() &#123;yield 'x';for (let v of foo()) &#123;yield v;&#125;yield 'y';&#125;for (let v of bar())&#123;console.log(v);&#125;// "x"// "a"// "b"// "y" 再来看一个对比的例子。 12345678910111213141516171819202122232425function* inner() &#123;yield 'hello!';&#125;function* outer1() &#123;yield 'open';yield inner();yield 'close';&#125;var gen = outer1()gen.next().value // "open"gen.next().value // 返回一个遍历器对象gen.next().value // "close"function* outer2() &#123;yield 'open'yield* inner()yield 'close'&#125;var gen = outer2()gen.next().value // "open"gen.next().value // "hello!"gen.next().value // "close" 上面例子中，outer2使用了yield*，outer1没使用。结果就是，outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值。+ 从语法角度看，如果yield命令后面跟的是一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*语句。+ 123456789101112131415161718let delegatedIterator = (function* () &#123;yield 'Hello!';yield 'Bye!';&#125;());let delegatingIterator = (function* () &#123;yield 'Greetings!';yield* delegatedIterator;yield 'Ok, bye.';&#125;());for(let value of delegatingIterator) &#123;console.log(value);&#125;// "Greetings!// "Hello!"// "Bye!"// "Ok, bye." 上面代码中，delegatingIterator是代理者，delegatedIterator是被代理者。由于yield* delegatedIterator语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。+ yield*后面的Generator函数（没有return语句时），等同于在Generator函数内部，部署一个for…of循环。+ 123456789101112131415function* concat(iter1, iter2) &#123;yield* iter1;yield* iter2;&#125;// 等同于function* concat(iter1, iter2) &#123;for (var value of iter1) &#123;yield value;&#125;for (var value of iter2) &#123;yield value;&#125;&#125; 上面代码说明，yield后面的Generator函数（没有return语句时），不过是for…of的一种简写形式，完全可以用后者替代前者。反之，则需要用var value = yield iterator的形式获取return语句的值。+ 如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。+ 12345function* gen()&#123;yield* ["a", "b", "c"];&#125;gen().next() // &#123; value:"a", done:false &#125; 上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。 实际上，任何数据结构只要有Iterator接口，就可以被yield*遍历。 1234567let read = (function* () &#123;yield 'hello';yield* 'hello';&#125;)();read.next().value // "hello"read.next().value // "h" 上面代码中，yield语句返回整个字符串，yield语句返回单个字符。因为字符串具有Iterator接口，所以被yield遍历。 如果被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据。 1234567891011121314151617181920212223242526function *foo() &#123;yield 2;yield 3;return "foo";&#125;function *bar() &#123;yield 1;var v = yield *foo();console.log( "v: " + v );yield 4;&#125;var it = bar();it.next()// &#123;value: 1, done: false&#125;it.next()// &#123;value: 2, done: false&#125;it.next()// &#123;value: 3, done: false&#125;it.next();// "v: foo"// &#123;value: 4, done: false&#125;it.next()// &#123;value: undefined, done: true&#125; 上面代码在第四次调用next方法的时候，屏幕上会有输出，这是因为函数foo的return语句，向函数bar提供了返回值。 再看一个例子。 12345678910111213function* genFuncWithReturn() &#123;yield 'a';yield 'b';return 'The result';&#125;function* logReturned(genObj) &#123;let result = yield* genObj;console.log(result);&#125;[...logReturned(genFuncWithReturn())]// The result// 值为 [ 'a', 'b' ] 上面代码中，存在两次遍历。第一次是扩展运算符遍历函数logReturned返回的遍历器对象，第二次是yield语句遍历函数genFuncWithReturn返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数genFuncWithReturn返回的遍历器对象。所以，最后的数据表达式得到的值等于[ ‘a’, ‘b’ ]。但是，函数genFuncWithReturn的return语句的返回值The result，会返回给函数logReturned内部的result变量，因此会有终端输出。yield命令可以很方便地取出嵌套数组的所有成员。+ 1234567891011121314151617181920function* iterTree(tree) &#123;if (Array.isArray(tree)) &#123;for(let i=0; i &lt; tree.length; i++) &#123;yield* iterTree(tree[i]);&#125;&#125; else &#123;yield tree;&#125;&#125;const tree = [ 'a', ['b', 'c'], ['d', 'e'] ];for(let x of iterTree(tree)) &#123;console.log(x);&#125;// a// b// c// d// e 下面是一个稍微复杂的例子，使用yield*语句遍历完全二叉树。+ 1234567891011121314151617181920212223242526272829303132333435// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123;this.left = left;this.label = label;this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123;if (t) &#123;yield* inorder(t.left);yield t.label;yield* inorder(t.right);&#125;&#125;// 下面生成二叉树function make(array) &#123;// 判断是否为叶节点if (array.length == 1) return new Tree(null, array[0], null);return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123;result.push(node);&#125;result// ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 作为对象属性的Generator函数如果一个对象的属性是Generator函数，可以简写成下面的形式。+ 12345let obj = &#123;* myGeneratorMethod() &#123;···&#125;&#125;; 上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个Generator函数。+ 它的完整形式如下，与上面的写法是等价的。+ 12345let obj = &#123;myGeneratorMethod: function* () &#123;// ···&#125;&#125;; Generator函数的thisGenerator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法。 12345678910function* g() &#123;&#125;g.prototype.hello = function () &#123;return 'hi!';&#125;;let obj = g();obj instanceof g // trueobj.hello() // 'hi!' 上面代码表明，Generator函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。+ 123456function* g() &#123;this.a = 11;&#125;let obj = g();obj.a // undefined 上面代码中，Generator函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。+ Generator函数也不能跟new命令一起用，会报错。 1234567function* F() &#123;yield this.x = 2;yield this.y = 3;&#125;new F()// TypeError: F is not a constructor 上面代码中，new命令跟构造函数F一起使用，结果报错，因为F不是构造函数。那么，有没有办法让Generator函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？下面是一个变通方法。首先，生成一个空对象，使用bind方法绑定Generator函数内部的this。这样，构造函数调用以后，这个空对象就是Generator函数的实例对象了。 123456789101112131415function* F() &#123;this.a = 1;yield this.b = 2;yield this.c = 3;&#125;var obj = &#123;&#125;;var f = F.call(obj);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;obj.a // 1obj.b // 2obj.c // 3 上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个Iterator对象。这个对象执行三次next方法（因为F内部有两个yield语句），完成F内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。+ 上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？一个办法就是将obj换成F.prototype。 1234567891011121314function* F() &#123;this.a = 1;yield this.b = 2;yield this.c = 3;&#125;var f = F.call(F.prototype);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 再将F改成构造函数，就可以对它执行new命令了。+ 12345678910111213141516171819function* gen() &#123;this.a = 1;yield this.b = 2;yield this.c = 3;&#125;function F() &#123;return gen.call(gen.prototype);&#125;var f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 含义Generator与状态机Generator是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。+ 12345678var ticking = true;var clock = function() &#123; if (ticking) console.log('Tick!'); else console.log('Tock!'); ticking = !ticking;&#125; 上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用Generator实现，就是下面这样。+ 12345678var clock = function*() &#123; while (true) &#123; console.log('Tick!'); yield; console.log('Tock!'); yield; &#125;&#125;; 上面的Generator实现与ES5实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。 Generator与协程协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。+ 协程与子例程的差异传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。+ 协程与普通线程的差异+不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。+ 由于ECMAScript是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。+ Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。+ 如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。+ 应用Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。+ 异步操作的同步化表达Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。+ 1234567891011function* loadUI() &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;var loader = loadUI();// 加载UIloader.next()// 卸载UIloader.next() 上面代码表示，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。+ Ajax是典型的异步操作，通过Generator函数部署Ajax操作，可以用同步的方式表达。+ 1234567891011121314function* main() &#123; var result = yield request("http://some.url"); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it = main();it.next(); 上面代码的main函数，就是通过Ajax操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield语句构成的表达式，本身是没有值的，总是等于undefined。+ 下面是另一个例子，通过Generator函数逐行读取文本文件。+ 12345678910function* numbers() &#123; let file = new FileReader("numbers.txt"); try &#123; while(!file.eof) &#123; yield parseInt(file.readLine(), 10); &#125; &#125; finally &#123; file.close(); &#125;&#125; 上面代码打开文本文件，使用yield语句可以手动逐行读取文件。+ 控制流管理如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。+ 123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); 采用Promise改写上面的代码。+ 12345678910Q.fcall(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量Promise的语法。Generator函数可以进一步改善代码运行流程。+ 1234567891011function* longRunningTask() &#123; try &#123; var value1 = yield step1(); var value2 = yield step2(value1); var value3 = yield step3(value2); var value4 = yield step4(value3); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125; 然后，使用一个函数，按次序自动执行所有步骤。+ 123456789101112scheduler(longRunningTask());function scheduler(task) &#123; setTimeout(function() &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125; &#125;, 0);&#125; 注意，yield语句是同步运行，不是异步运行（否则就失去了取代回调函数的设计目的了）。实际操作中，一般让yield语句返回Promise对象。+ 1234567891011var Q = require('q');function delay(milliseconds) &#123; var deferred = Q.defer(); setTimeout(deferred.resolve, milliseconds); return deferred.promise;&#125;function* f()&#123; yield delay(100);&#125;; 上面代码使用Promise的函数库Q，yield语句返回的就是一个Promise对象。如果yield语句后面的参数，是一个具有遍历器接口的对象，yield会遍历这个对象，再往下执行。这意味着，多个任务按顺序一个接一个执行时，yield语句可以按顺序排列。多个任务需要并列执行时（比如只有A任务和B任务都执行完，才能执行C任务），可以采用数组的写法。 1234567function* parallelTasks() &#123; let [resultA, resultB] = yield [ taskA(), taskB() ]; console.log(resultA, resultB);&#125; 上面代码中，yield语句的参数是一个数组，成员就是两个任务taskA和taskB，只有等这两个任务都完成了，才会接着执行下面的语句。+ 部署iterator接口利用Generator函数，可以在任意对象上部署iterator接口。+ 12345678910111213141516function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了iterator接口。也就是说，可以在任意对象上部署next方法。下面是一个对数组部署Iterator接口的例子，尽管数组原生具有这个接口。 12345678910111213function* makeSimpleGenerator(array)&#123; var nextIndex = 0; while(nextIndex &lt; array.length)&#123; yield array[nextIndex++]; &#125;&#125;var gen = makeSimpleGenerator(['yo', 'ya']);gen.next().value // 'yo'gen.next().value // 'ya'gen.next().done // true 作为数据结构Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。+ 12345function *doStuff() &#123; yield fs.readFile.bind(null, 'hello.txt'); yield fs.readFile.bind(null, 'world.txt'); yield fs.readFile.bind(null, 'and-such.txt');&#125; 上面代码就是依次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样，处理这三个返回的函数。+ 123for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125; 实际上，如果用ES5表达，完全可以用数组模拟Generator的这种用法。+ 1234567function doStuff() &#123; return [ fs.readFile.bind(null, 'hello.txt'), fs.readFile.bind(null, 'world.txt'), fs.readFile.bind(null, 'and-such.txt') ];&#125; 上面的函数，可以用一模一样的for…of循环处理！两相一比较，就不难看出Generator使得数据或者操作，具备了类似数组的接口。+]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map]]></title>
    <url>%2F2018%2F01%2F03%2Fmap%2F</url>
    <content type="text"><![CDATA[Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。引用：官方文档WeakMap详解 语法1new Map([iterable]) 参数iterable:Iterable 可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。 描述一个Map对象以插入顺序迭代其元素 — 一个 for...of 循环为每次迭代返回一个[key，value]数组。 键的相等(Key equality)键的比较是基于 &quot;SameValueZero&quot; 算法：NaN 是与 NaN 相同的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。在目前的ECMAScript规范中，-0和+0被认为是相等的，尽管这在早期的草案中并不是这样。有关详细信息，请参阅浏览器兼容性 表中的“value equality for -0 and 0”。 Objects 和 maps 的比较Object 和 Map类似的一点是,它们都允许你按键存取一个值,都可以删除键,还可以检测一个键是否绑定了值.因此,一直以来,我们都把对象当成Map来使用,不过,现在有了Map,下面的区别解释了为什么使用Map更好点. 一个对象通常都有自己的原型,所以一个对象总有一个”prototype”键。不过，从 ES5 开始可以使用 map = Object.create(null)来创建一个没有原型的对象。 一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。 你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。 但是这并不意味着你可以随意使用 Map，对象仍旧是最常用的。Map 实例只适合用于集合(collections)，你应当考虑修改你原来的代码——先前使用对象来处理集合的地方。对象应该用其字段和方法来作为记录的。 如果你不确定要使用哪个，请思考下面的问题： 在运行之前 key 是否是未知的，是否需要动态地查询 key 呢？ 是否所有的值都是统一类型，这些值可以互换么？ 是否需要不是字符串类型的 key ？ 键值对经常增加或者删除么？ 是否有任意个且非常容易改变的键值对? 这个集合可以遍历么(Is the collection iterated)? 假如以上全是“是”的话，那么你需要用Map 来保存这个集。 相反，你有固定数目的键值对，独立操作它们，区分它们的用法，那么你需要的是对象。 属性 属性 Map.length 属性 length 的值为 0 。 get Map[@@species] 本构造函数用于创建派生对象。 Map.prototype 表示 Map构造器的原型。 允许添加属性从而应用于所有的Map 对象。 Map 实例所有的 Map 对象实例都会继承 Map.prototype。 属性 Map.prototype.constructor 返回一个函数，它创建了实例的原型。默认是Map函数。 Map.prototype.size 返回Map对象的键/值对的数量。 方法 Map.prototype.clear() 移除Map对象的所有键/值对 。 Map.prototype.delete(key) 移除任何与键相关联的值，并且返回该值，该值在之前会被Map.prototype.has(key)返回为true。之后再调用Map.prototype.has(key)会返回false。 Map.prototype.entries() 返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。 Map.prototype.forEach(callbackFn[, thisArg]) 按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。 Map.prototype.get(key) 返回键对应的值，如果不存在，则返回undefined。 Map.prototype.has(key) 返回一个布尔值，表示Map实例是否包含键对应的值。 Map.prototype.keys() 返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。 Map.prototype.set(key, value) 设置Map对象中键的值。返回该Map对象。 Map.prototype.values() 返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。 Map.prototype[@@iterator]() 返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value]数组。 示例使用映射对象 12345678910111213141516171819202122var myMap = new Map();var keyObj = &#123;&#125;, keyFunc = function () &#123;&#125;, keyString = "a string";// 添加键myMap.set(keyString, "和键'a string'关联的值");myMap.set(keyObj, "和键keyObj关联的值");myMap.set(keyFunc, "和键keyFunc关联的值");myMap.size; // 3// 读取值myMap.get(keyString); // "和键'a string'关联的值"myMap.get(keyObj); // "和键keyObj关联的值"myMap.get(keyFunc); // "和键keyFunc关联的值"myMap.get("a string"); // "和键'a string'关联的值" // 因为keyString === 'a string'myMap.get(&#123;&#125;); // undefined, 因为keyObj !== &#123;&#125;myMap.get(function() &#123;&#125;) // undefined, 因为keyFunc !== function () &#123;&#125; 将NaN作为映射的键NaN也可以作为Map对象的键. 虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true), 但下面的例子表明, 两个NaN作为Map的键来说是没有区别的: 1234567var myMap = new Map();myMap.set(NaN, "not a number");myMap.get(NaN); // "not a number"var otherNaN = Number("foo");myMap.get(otherNaN); // "not a number" 使用for..of方法迭代映射映射也可以使用for..of循环来实现迭代： 12345678910111213141516171819202122var myMap = new Map();myMap.set(0, "zero");myMap.set(1, "one");for (var [key, value] of myMap) &#123; console.log(key + " = " + value);&#125;// 将会显示两个log。一个是"0 = zero"另一个是"1 = one"for (var key of myMap.keys()) &#123; console.log(key);&#125;// 将会显示两个log。 一个是 "0" 另一个是 "1"for (var value of myMap.values()) &#123; console.log(value);&#125;// 将会显示两个log。 一个是 "zero" 另一个是 "one"for (var [key, value] of myMap.entries()) &#123; console.log(key + " = " + value);&#125;// 将会显示两个log。 一个是 "0 = zero" 另一个是 "1 = one" 使用forEach()方法迭代映射映射也可以通过forEach()方法迭代： 1234myMap.forEach(function(value, key) &#123; console.log(key + " = " + value);&#125;, myMap)// 将会显示两个logs。 一个是 "0 = zero" 另一个是 "1 = one" 映射与数组对象的关系 123456789101112var kvArray = [["key1", "value1"], ["key2", "value2"]];// 使用映射对象常规的构造函数将一个二维键值对数组对象转换成一个映射关系var myMap = new Map(kvArray);myMap.get("key1"); // 返回值为 "value1"// 使用展开运算符将一个映射关系转换成一个二维键值对数组对象console.log(uneval([...myMap])); // 将会向您显示和kvArray相同的数组// 或者使用展开运算符作用在键或者值的迭代器上，进而得到只含有键或者值得数组console.log(uneval([...myMap.keys()])); // 输出 ["key1", "key2"]]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承中方法属性的重写]]></title>
    <url>%2F2018%2F01%2F02%2Fji-cheng-zhong-fang-fa-shu-xing-de-zhong-xie%2F</url>
    <content type="text"><![CDATA[继承中方法属性的重写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163function F()&#123;&#125;;var f = new F();f.name = "cf";f.hasOwnProperty("name");//trueF.prototype.age = 22;f.hasOwnProperty("age");//false,age是原型对象的属性，name是F对象的属性，不是同一个。hasOwnProperty是对象的方法F.prototype.isPrototypeOf(f);//true//多态：编译时多态，运行时多态：方法重载、重写//js不支持同名的方法var o = &#123;run:function()&#123;&#125;,run:function()&#123;&#125;, //js同名会覆盖，run指向的是这个函数对象的地址，地址名加小括号就是这个类对象开始执行。function F()&#123;&#125; 既是类也是对象，new F()说明是一个类，F()函数名加小括号就是函数执行，说明是一个对象。&#125;=======================================================================function demo (a,b) &#123; console.log(demo.length);//形参个数，2 console.log(arguments.length);//实参个数，3 console.log(arguments[0]); console.log(arguments[1]);&#125;demo(4,5,6);function add()&#123; var total = 0; for (var i = arguments.length - 1; i &gt;= 0; i--) &#123; total += arguments[i]; &#125;; return total;&#125;console.log(add(1));console.log(add(1,2));//可变长度function fontSize()&#123; var ele = document.getElementById("js"); if (arguments.length == 0)&#123; return ele.style.fontSize; &#125;else&#123; ele.style.fontSize = arguments[0]; &#125;&#125;fontSize(18);console.log(fontSize());function setting()&#123; var ele = document.getElementById("js"); if (typeof arguments[0] ==="object")&#123; for(p in arguments[0])&#123;//p是key,arguments[p]是value, ele.style[p] = arguments[0][p]; &#125; &#125;else&#123; ele.style.fontSize = arguments[0]; ele.style.backgroundColor= arguments[1]; &#125;&#125;setting(18,"red");setting(&#123;fontSize:20,backgroundColor:"green"&#125;);//js里面不能写同名的方法，所以只能够对方法的参数做判断，==========================================================================function demo(o)&#123;//demo是一个类，o是类的对象属性 o.run();//调用属性的方法&#125;var o = &#123;run:function()&#123; console.log("o is running...");&#125;&#125;;demo(o);//类调用，java里面类不可以调用,这是跟java不一样的。var p =&#123;run:function()&#123; console.log("p is running...");&#125;&#125;;demo(p);//函数是一个类也是一个对象，函数调用对象就会执行起来。function F()&#123;&#125;;var f = new F();F.prototype.run = function()&#123;console.log("111");&#125;//原型区域，对象. 可以访问f.run();//111f.run = function()&#123;console.log("222");&#125;;//只是给f自己加了一个方法，没有改变类的原型对象，相当于方法的重写。f.什么都是给自己对象加的f.run();//222F.prototype.run();//111f.run = function()&#123;//run指向一个对象的地址 console.log("222"); F.prototype.run();//重写父的，并且还要调用父的，&#125;;f.run();//222 , 111=======================================================================function Parent()&#123; this.run = function()&#123;//现在把Parent当成类看，run是一个对象的地址， console.log("parent is running..."); &#125;&#125;function Child()&#123; Parent.call(this);//继承父的方法,相当于父有了一个run方法，this.run = function()&#123;console.log("parent is running...");&#125;，但是2个方法不是同一个，只是相当于把父的属性和方法在这里写了一遍。 var parentRun = this.run;//用this,parentRun指向run函数的地址， this.run = function ()&#123;//run重新指向，重写，添加同名的子类方法 console.log("child is running..."); parentRun();//地址名小括号就是对象的执行 &#125;&#125;var c = new Child();//Child看成是类，c是对象c.run();//run是函数的地址，地址小括号就是对象执行========================================================================function Parent()&#123; this.name = "333";//只能通过 对象.name 访问 var age = 34;//给嵌套函数使用&#125;var p = new Parent();console.log(p.name);//333console.log(Parent.name);//Parentconsole.log(p.age);//undefined, console.log(Parent.age);//undefined, Parent.aa = "aa"; //静态属性，对象. 访问不到，类. 访问得到Parent.prototype.aaa = "asa";//原型公有区域，对象. 访问得到，类. 访问不到console.log(p.aa);//undefined，console.log(Parent.aa);//aaconsole.log(p.aaa);//asa，console.log(Parent.aaa);//undefinedp.zz = "zz";//只是加给了对象自己，没有加给类和类的原型console.log(p.zz);//zzconsole.log(Parent.zz);//undefinedconsole.log(Parent.prototype.zz)//undefin==========================================================================function Parent()&#123;&#125;Parent.prototype.run = function() &#123; console.log("parent");&#125;;Child.prototype = Object.create(Parent.prototype);//继承Child.prototype.constructor = Child;//修正Child.super = Parent.prototype; //给Child增加静态属性function Child()&#123;&#125;Child.prototype.run=function()&#123; console.log('child is running...'); Child.super.run();&#125;var c = new Child();c.run(); 类里面的this.属性给对象用的，静态属性、方法给类用，什么都不加的和var给嵌套函数用，什么都不加的在window对象中。（静态属性、方法通过F.xx 添加） 对象的静态属性、方法给自己用。（静态属性、方法通过 p.xx 添加） 原型里面的属性、方法是给对象和原型自己用的。（通过 F.prototype.xx 添加） 123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; function F()&#123; this.name = "yw"; var age = 32; sch = 890; &#125; var f = new F(); alert(f.name);//yw alert(f.age);//undefined alert(f.sch);//undefined F.kr = "gh"; F.ss = function()&#123;alert(123);&#125; alert(f.kr);//undefined f.ss();//f.ss is not a function alert(F.prototype.kr);//undefined F.prototype.ss();//F.prototype.ss is not a function f.a = "a"; f.y = function()&#123;alert("y");&#125; alert(F.a);//undefined F.y();//F.y is not a function alert(F.prototype.a);//undefined F.prototype.y();//F.prototype.y is not a function F.prototype.o = "o"; F.prototype.oo = function()&#123;alert("oo");&#125; alert(f.o);//o f.oo();//oo alert(F.o);//undefined F.oo();//F.oo is not a function&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set详解]]></title>
    <url>%2F2018%2F01%2F02%2Fset-and-map%2F</url>
    <content type="text"><![CDATA[Set Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 引用：官方文档 语法 1new Set([iterable]); 参数iterable如果传递一个可迭代对象，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的Set为空。 返回值一个新的Set对象。 简述Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。 值的相等因为 Set 中的值总是唯一的，所以需要判断两个值是否相等。在ECMAScript规范的早期版本中，这不是基于和===操作符中使用的算法相同的算法。具体来说，对于Set s， +0 （+0 严格相等于-0）和-0是不同的值。然而，在 ECMAScript 2015规范中这点已被更改。有关详细信息，请参阅浏览器兼容性 表中的“value equality for -0 and 0”。 另外，NaN和undefined都可以被存储在Set 中， NaN之间被视为相同的值（尽管 NaN !== NaN）。 属性Set.length:length属性的值为0。 get Set[@@species]:构造函数用来创建派生对象. Set.prototype:表示Set构造器的原型，允许向所有Set对象添加新的属性。 Set实例所有Set实例继承自 Set.prototype。 属性 属性 introduce Set.prototype.constructor 返回实例的构造函数。默认情况下是Set Set.prototype.size 返回Set对象的值的个数 方法 方法 introduce Set.prototype.add(value) 在Set对象尾部添加一个元素。返回该Set对象。 Set.prototype.clear() 移除Set对象内的所有元素。 Set.prototype.delete(value) 移除Set的中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。Set.prototype.has(value)在此后会返回false。 Set.prototype.entries() 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。 Set.prototype.forEach(callbackFn[, thisArg]) 按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。 Set.prototype.has(value) 返回一个布尔值，表示该值在Set中存在与否。 Set.prototype.keys() 与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。 Set.prototype.values() 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。 Set.prototype[@@iterator]() 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。 示例使用Set对象 12345678910111213141516171819202122232425let mySet = new Set();mySet.add(1); // Set(1) &#123;1&#125;mySet.add(5); // Set(2) &#123;1, 5&#125;mySet.add(5); // Set &#123; 1, 5 &#125;mySet.add("some text"); // Set(3) &#123;1, 5, "some text"&#125;var o = &#123;a: 1, b: 2&#125;;mySet.add(o);mySet.add(&#123;a: 1, b: 2&#125;); // o 指向的是不同的对象，所以没问题mySet.has(1); // truemySet.has(3); // falsemySet.has(5); // truemySet.has(Math.sqrt(25)); // truemySet.has("Some Text".toLowerCase()); // truemySet.has(o); // truemySet.size; // 5mySet.delete(5); // true, 从set中移除5mySet.has(5); // false, 5已经被移除mySet.size; // 4, 刚刚移除一个值console.log(mySet); // Set &#123;1, "some text", Object &#123;a: 1, b: 2&#125;, Object &#123;a: 1, b: 2&#125;&#125; Set不支持索引 1234arr.indexOf('a') !== -1 //慢//truesetOfWords.has('a') //快 //true 迭代Set 12345678910111213141516171819202122232425262728293031323334353637383940414243// 迭代整个set// 按顺序输出：1, "some text" for (let item of mySet) console.log(item);// 按顺序输出：1, "some text" for (let item of mySet.keys()) console.log(item);// 按顺序输出：1, "some text" for (let item of mySet.values()) console.log(item);// 按顺序输出：1, "some text" //(键与值相等)for (let [key, value] of mySet.entries()) console.log(key);// 转换Set为Array (with Array comprehensions)var myArr = [v for (v of mySet)]; // [1, "some text"]// 替代方案(with Array.from)var myArr = Array.from(mySet); // [1, "some text"]// 如果在HTML文档中工作，也可以：mySet.add(document.body);mySet.has(document.querySelector("body")); // true// Set 和 Array互换mySet2 = new Set([1,2,3,4]);mySet2.size; // 4[...mySet2]; // [1,2,3,4]// intersect can be simulated via var intersection = new Set([...set1].filter(x =&gt; set2.has(x))); // 新的迭代器对象// difference can be simulated viavar difference = new Set([...set1].filter(x =&gt; !set2.has(x)));// 用forEach迭代mySet.forEach(function(value) &#123; console.log(value);&#125;);// 1// 2// 3// 4 Array 相关 123456789var myArray = ["value1", "value2", "value3"];// 用Set构造器将Array转换为Setvar mySet = new Set(myArray);mySet.has("value1"); // returns true// 用...(展开操作符)操作符将Set转换为Arrayconsole.log([...mySet]); // 与myArray完全一致 String 相关 1234var text = 'Indiana';var mySet = new Set(text); // Set &#123;'I', 'n', 'd', 'i', 'a'&#125;mySet.size; // 5]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class详解]]></title>
    <url>%2F2018%2F01%2F01%2Fclass%2F</url>
    <content type="text"><![CDATA[转载：http://www.cnblogs.com/E-WALKER/p/4796278.html Overview借助class 我们可以写出这样的代码: 12345678910111213141516171819202122232425class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); this.color = color; &#125; toString() &#123; return super.toString() + ' in ' + this.color; &#125;&#125;let cp = new ColorPoint(25, 8, 'green');cp.toString(); // '(25, 8) in green'console.log(cp instanceof ColorPoint); // trueconsole.log(cp instanceof Point); // true Base classes我们可以定义如下的class: 123456789class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 我们可以像使用ES5标准中的constructor一样实例化class 123var p = new Point(25, 8);p.toString();// '(25, 8)' 实际上，class还是用function实现的，并没有为js创造一个全新的class体系。 12typeof Point'function' 但是，与function相比，它是不能直接调用的，也就是说必须得new出来 12Point()TypeError: Classes can’t be function-called 另外，它不会像function一样会被hoisted(原因是语义阶段无法解析到extends的内容) 1234567foo(); // works, because `foo` is hoistedfunction foo() &#123;&#125;new Foo(); // ReferenceErrorclass Foo &#123;&#125; 123456789function functionThatUsesBar() &#123; new Bar();&#125;functionThatUsesBar(); // ReferenceErrorclass Bar &#123;&#125;functionThatUsesBar(); // OK 与函数一样，class的定义表达式也有两种，声明形式、表达式形式。之前用的都是声明形式，以下是表达式式的: 12345678910const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;;let inst = new MyClass();console.log(inst.getClassName()); // Meconsole.log(Me.name); // ReferenceError: Me is not defined Inside the body of a class definitionclass定义体是只能包含方法，不能包含属性的(标准定义组织认为原型链中不应包含属性)，属性被写在constructor中。以下是三种会用到的方法(constructor 、static method、 prototype method)： 123456789101112class Foo &#123; constructor(prop) &#123; this.prop = prop; &#125; static staticMethod() &#123; return 'classy'; &#125; prototypeMethod() &#123; return 'prototypical'; &#125;&#125;let foo = new Foo(123); 如下图([[Prototype]]代表着继承关系)当对象被new出来，拿的是Foo.prototype : Object分支，从而可以调prototype method constructor，这个方法本身，代表了class 12Foo === Foo.prototype.constructor// true constructor有时被称为类构造器。相较于ES5，它可以调用父类的constructor(使用super())。static methods,它们归属于类本身，即类方法 1234typeof Foo.staticMethod'function'Foo.staticMethod()'classy' 关于 Getters and setters，它们的语法如下: 12345678910111213141516class MyClass &#123; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop//'getter' 方法名是可以动态生成的 123456789101112class Foo() &#123; myMethod() &#123;&#125;&#125;class Foo() &#123; ['my'+'Method']() &#123;&#125;&#125;const m = 'myMethod';class Foo() &#123; [m]() &#123;&#125;&#125; 增加了迭代器的支持，需要给方法前面加一个* 1234567891011121314151617class IterableArguments &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new IterableArguments('hello', 'world')) &#123; console.log(x);&#125;// hello// world Subclassing通过extends，我们可以继承其它实现constructor的函数或对象。需要注意一下，constructor与非constructor调用父类方法的途径是不同的。 123456789101112131415161718192021222324252627282930class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // (A) this.color = color; &#125; toString() &#123; return super.toString() + ' in ' + this.color; // (B) &#125;&#125;let cp = new ColorPoint(25, 8, 'green');cp.toString()'(25, 8) in green'cp instanceof ColorPoint// truecp instanceof Point// true 子类的原型就是它的父类 123Object.getPrototypeOf(ColorPoint) === Point// true 所以，static method也被继承了 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod(); // 'hello' static方法也是支持调用父类的。 123456789101112class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod(); // 'hello, too' 关于子类中使用构造器，需要注意的是，调用this之前，需要调用super() 12345678910class Foo &#123;&#125; class Bar extends Foo &#123; constructor(num) &#123; let tmp = num * 2; // OK this.num = num; // ReferenceError super(); this.num = num; // OK &#125;&#125; constructors是可以被显示覆盖(override)的。 123456class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;console.log(new Foo() instanceof Foo); // false Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。Object.create() 如果基类中不显示定义constructor，引擎会生成如下代码 1constructor() &#123;&#125; 对于子类 123constructor(...args) &#123; super(...args);&#125; The details of classes 类名不能为eval 或者 arguments，不能有重复的类名，constructor不支持getter,setter。 classes不能像函数一样调用。 原型方法不能用作构造器： 1234class C &#123; m() &#123;&#125;&#125;new C.prototype.m(); // TypeError The details of subclassingES 6中,子类的使用方法如下: 1234567891011121314151617class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; ···&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); this.color = color; &#125; ···&#125;let cp = new ColorPoint(25, 8, 'green'); 原型链实现: 12345678910111213const getProto = Object.getPrototypeOf.bind(Object);getProto(Point) === Function.prototype// truegetProto(function () &#123;&#125;) === Function.prototype// truegetProto(Point.prototype) === Object.prototype// truegetProto(&#123;&#125;) === Object.prototype// true]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入解析 ES6：Symbol]]></title>
    <url>%2F2018%2F01%2F01%2Fsymbol%2F</url>
    <content type="text"><![CDATA[深入解析 ES6：Symbol 引用：http://bubkoo.com/2015/07/24/es6-in-depth-symbols/ Symbol 是什么？ 12typeof Symbol()"symbol" JavaScript 在 1997 年被标准化时，就有 6 种数据类型，直到 ES6 出现之前，程序中的变量一定是以下 6 种数据类型之一： Undefined Null Boolean Number String Object 而symbol则是javascript中的第七种数据类型 Symbol 是完全不一样的东西。一旦创建后就不可更改，不能对它们设置属性（如果在严格模式下尝试这样做，你将得到一个 TypeError）。它们可以作为属性名，这时它们和字符串的属性名没有什么区别。 每个 Symbol 都是独一无二的，不与其它 Symbol 重复（即便是使用相同的 Symbol 描述创建），创建一个 Symbol 就跟创建一个对象一样方便。 ES6 中的 Symbol与传统语言（如 Lisp 和 Ruby）中的 Symbol 中的类似，但并不是完全照搬到 JavaScript 中。在 Lisp 中，所有标识符都是 Symbol；在 JavaScript 中，标识符和大多数属性仍然是字符串，Symbol 只是提供了一个额外的选择。 值得注意的是：与其它类型不同的是，Symbol 不能自动被转换为字符串，当尝试将一个 Symbol 强制转换为字符串时，将返回一个 TypeError。 12345&gt; var sym = Symbol("&lt;3");&gt; "your symbol is " + sym// TypeError: can't convert symbol to string&gt; `your symbol is $&#123;sym&#125;`// TypeError: can't convert symbol to string 应该避免这样的强制转换，应该使用 String(sym) 或 sym.toString() 来转换。 获取 Symbol 的三种方法 Symbol() 每次调用时都返回一个唯一的 Symbol。 Symbol.for(string) 从 Symbol注册表中返回相应的 Symbol，与上个方法不同的是，Symbol注册表中的 Symbol 是共享的。也就是说，如果你调用 Symbol.for(&quot;cat&quot;) 三次，都将返回相同的 Symbol。当不同页面或同一页面不同模块需要共享 Symbol 时，注册表就非常有用。 Symbol.iterator 返回语言预定义的一些 Symbol，每个都有其特殊的用途。 如果你仍不确定 Symbol 是否有用，那么接下来的内容将非常有趣，因为我将为你演示 Symbol 的实际应用。 Symbol 在 ES6 规范中的应用 可以使用 Symbol 来避免代码冲突。 在使用 iterator 时，我们解析for (var item of myArray) 内部是以调用 myArray[Symbol.iterator]() 开始的，这个方法可以使用 myArray.iterator() 来代替，但是使用 Symbol 的后向兼容性更好。 在 ES6 中还有一些地方使用到了 Symbol。（这些特性还没有在 FireFox 中实现。） 使 instanceof 可扩展。在 ES6中，object instanceof constructor 表达式被标准化为构造函数的一个方法：constructor[Symbol.hasInstance](object)，这意味着它是可扩展的。 消除新特性和旧代码之间的冲突。 支持新类型的字符串匹配。在 ES5 中，调用 str.match(myObject) 时，首先会尝试将 myObject转换为 RegExp对象。在 ES6中，首先将检查 myObject中是否有 myObject[Symbol.match](str) 方法，在所有正则表达式工作的地方都可以提供一个自定义的字符串解析方法。 这些用途还比较窄，但仅仅通过我文章中的代码很难看到这些新特性产生的重大影响。JavaScript 的 Symbol 是 PHP 和 Python 中 __doubleUnderscores 的改进版本，标准组织将使用它来为语言添加新特性，而不会对已有代码产生影响。 案例一个布尔值引出的问题：有时，把一些属于其他对象的数据暂存在另一个对象中是非常方便的。例如，假设你正在编写一个 JS 库，使用 CSS 中的 transition 来让一个 DOM元素在屏幕上飞奔，你已经知道不能同时将多个 transition 应用在同一个 div上，否则将使得动画非常不美观，你也确实有办法来解决这个问题，但是首先你需要知道该 div是否已经在移动中。 怎么解决这个问题呢？ 其中一个方法是使用浏览器提供的 API 来探测元素是否处于动画状态，但杀鸡焉用牛刀，在将元素设置为移动时，你的库就知道了该元素正在移动。 你真正需要的是一种机制来跟踪哪些元素正在移动，你可以将正在移动的元素保存在一个数组中，每次要为一个元素设置动画时，首先检查一下这个元素是否已经在这个列表中。 啊哈，但是如果你的数组非常庞大，即便是这样的线性搜索也会产生性能问题。 那么，你真正想做的就是直接在元素上设置一个标志： 1234if (element.isMoving) &#123; smoothAnimations(element);&#125;element.isMoving = true; 这也有一些潜在的问题，不得不承认这样一个事实：还有其他代码也可能操作该 ODM 元素。 在其他代码中，你创建的属性会被 for-in 或 Object.keys() 枚举出来； 在其他一些库中也许已经使用了同样的方式（在元素上设置了相同的属性），那么这将和你的代码发生冲突，产生不可预计的结果； 其他一些库可能在将来会使用同样的方式，这也会与你的代码发生冲突； 标准委员会可能会为每个元素添加一个 .isMoving() 原生方法，那么你的代码就彻底不能工作了。 当然，对于最后三个问题，你可以选择一个无意义的不会有人会使用到的字符串： 1234if (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) &#123; smoothAnimations(element);&#125;element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true; 这似乎太不靠谱了，看了让人眼睛痛。 你还可以用加密算法来生成一个几乎唯一的字符串： 1234567// get 1024 Unicode characters of gibberishvar isMoving = SecureRandom.generateName();...if (element[isMoving]) &#123; smoothAnimations(element);&#125;element[isMoving] = true; object[name] 语法允许我们将任何字符串作为属性名，代码能正常工作，冲突几乎是不可能了，代码看起来也美观多了。但是，这回导致糟糕的调试体验，每次使用 console.log() 打印出包含该属性的元素时，你回看到一个庞大的垃圾字符串，并且如果还不止一个这样的属性呢？每次刷新后属性名都发生了变化，怎么样使这些属性看起来更加直观呢？ 为什么这么难？我们只是为了保存一个小小的标志位。 用 Symbol 来解决问题 Symbol 值可以由程序创建，并可以作为属性名，而且不用担心属性名冲突。 1var mySymbol = Symbol(); 调用 Symbol() 方法将创建一个新的 Symbol 类型的值，并且该值不与其它任何值相等。与数字和字符串一样，Symbol 类型的值也可以作为对象的属性名，正是由于它不与任何其它值相等，对应的属性也不会发生冲突： 12obj[mySymbol] = "ok!"; // guaranteed not to collideconsole.log(obj[mySymbol]); // ok! 下面是使用 Symbol 来解决上面的问题： 1234567// create a unique symbolvar isMoving = Symbol("isMoving");...if (element[isMoving]) &#123; smoothAnimations(element);&#125;element[isMoving] = true; 上面代码需要注意几点： 方法 Symbol(&quot;isMoving&quot;) 中的 &quot;isMoving&quot; 字符串被称为 Symbol的描述信息，这对调试非常有帮助。可以通过 console.log(isMoving) 打印出来，或通过 isMoving.toString() 将 isMoving 转换为字符串时，或在一些错误信息中显示出来。 element[isMoving] 访问的是 symbol-keyed 属性，除了属性名是 Symbol 类型的值之外，与其它属性都一样。 和数组一样，symbol-keyed 属性不能通过 . 操作符来访问，必须使用方括号的方式。 操作 symbol-keyed 属性也非常方便，通过上面代码我们已经知道如何获取和设置 element[isMoving] 的值，我们还可以这样使用：if (isMoving in element) 或 delete element[isMoving]。 另一方面，只有在 isMoving 的作用域范围内才可以使用上述代码，这可以实现弱封装机制：在一个模块内创建一些Symbol，只有在该模块内部的对象才能使用，而不用担心与其它模块的代码发生冲突。 由于 Symbol 的设计初衷是为了避免冲突，当遍历 JavaScript对象时，并不会枚举到以 Symbol 作为建的属性，比如，for-in 循环只会遍历到以字符串作为键的属性，Object.keys(obj) 和 Object.getOwnPropertyNames(obj) 也一样，但这并不意味着 Symbol 为键的属性是不可枚举的：使用 Object.getOwnPropertySymbols(obj) 这个新方法可以枚举出来，还有 Reflect.ownKeys(obj) 这个新方法可以返回对象中所有字符串和 Symbol键。 库和框架的设计者将会发现很多 Symbol 的用途，JavaScript语言本身也对其有广泛的应用。 兼容性对于还没有原生支持 Symbol 的浏览器，你可以使用 polyfill，如 core.js，但该 polyfill 实现并不完美，请阅读注意事项。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板字符串]]></title>
    <url>%2F2018%2F01%2F01%2Fmo-ban-zi-fu-chuan%2F</url>
    <content type="text"><![CDATA[模板字符串 模板字面量/Template literals 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串/template strings”。 语法 12345678`string text``string text line 1 string text line 2``string text $&#123;expression&#125; string text`tag `string text $&#123;expression&#125; string text` Note: 模板字面量也可以使用三元运算符( condition ? true : false ) 和 嵌套 nested！ 描述 模板字符串使用反引号 () 来代替普通字符串中的用双引号和单引号。 模板字符串可以包含特定语法(${expression})的占位符。 占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。 1`\`` === "`" // --&gt; true 多行字符串在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串： 1234console.log("string text line 1\n\string text line 2");// "string text line 1// string text line 2" 要获得同样效果的多行字符串，只需使用如下代码： 1234console.log(`string text line 1string text line 2`);// "string text line 1// string text line 2" 表达式插补在普通字符串中嵌入表达式，必须使用如下语法： 12345var a = 5;var b = 10;console.log("Fifteen is " + (a + b) + " and\nnot " + (2 * a + b) + ".");// "Fifteen is 15 and// not 20." 现在通过模板字符串，我们可以使用一种更优雅的方式来表示： 12345var a = 5;var b = 10;console.log(`Fifteen is $&#123;a + b&#125; and\nnot $&#123;2 * a + b&#125;.`);// "Fifteen is 15 and// not 20." 带标签的模板字符串更高级的形式的模板字面值被标记模板文本。标记使您可以分析模板文本功能。标记功能的第一个参数包含一个字符串值的数组。其余的参数是相关的表达式。最后，你的函数可以返回处理好的的字符串 （或者它可以返回完全不同的东西 , 如下例所述）。用于该标记的函数的名称可以被命名为任何你想要的东西。 12345678910111213141516171819202122232425262728var person = 'Mike';var age = 28;function myTag(strings, personExp, ageExp) &#123; var str0 = strings[0]; // "that " var str1 = strings[1]; // " is a " // 在技术上,有一个字符串在 // 最终的表达式 (在我们的例子中)的后面, // 但它是空的(""), 所以被忽略. // var str2 = strings[2]; var ageStr; if (ageExp &gt; 60)&#123; ageStr = 'old person'; &#125; else &#123; ageStr = 'young person'; &#125; return str0 + personExp + str1 + ageStr;&#125;var output = myTag`that $&#123; person &#125; is a $&#123; age &#125;`;console.log(output); // that Mike is a young person 12345678910111213141516171819202122232425262728//show函数采用rest参数的写法如下：let name = '张三', age = 20, message = show`我来给大家介绍:$&#123;name&#125;的年龄是$&#123;age&#125;.`;function show(stringArr,...values)&#123; let output =""; let index = 0 for(;index&lt;values.length;index++)&#123; output += stringArr[index]+values[index]; &#125; output += stringArr[index]; return output;&#125;message; //"我来给大家介绍:张三的年龄是20." 正如下面例子所展示的，标签函数并不一定需要返回一个字符串。 12345678910111213141516171819function template(strings, ...keys) &#123; return (function(...values) &#123; var dict = values[values.length - 1] || &#123;&#125;; var result = [strings[0]]; keys.forEach(function(key, i) &#123; var value = Number.isInteger(key) ? values[key] : dict[key]; result.push(value, strings[i + 1]); &#125;); return result.join(''); &#125;);&#125;var t1Closure = template`$&#123;0&#125;$&#123;1&#125;$&#123;0&#125;!`;t1Closure('Y', 'A'); // "YAY!" var t2Closure = template`$&#123;0&#125; $&#123;'foo'&#125;!`;t2Closure('Hello', &#123;foo: 'World'&#125;); // "Hello World!" 原始字符串在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串。 123456function tag(strings, ...values) &#123; console.log(strings.raw[0]); // "string text line 1 \\n string text line 2"&#125;tag`string text line 1 \n string text line 2`; 另外，使用String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。 1String.raw`Hi\n$&#123;2+3&#125;!`; 浏览器兼容]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iterator 迭代器]]></title>
    <url>%2F2018%2F01%2F01%2Fiterator-die-dai-qi%2F</url>
    <content type="text"><![CDATA[iterator 迭代器引用：高鹏、Symbol.iterator 迭代器（Iterator）是一个接口，为各种不同的数据结构提供统一的访问机制。任何数据只要部署了 Iterator 接口，就可以完成遍历操作。 Symbol.iterator 属性的属性特性： 属性 属性特性 writable: false enumerable: false configurable: false 描述 当需要对一个对象进行迭代时（比如开始用于一个for..of循环中），它的@@iterator方法都会在不传参情况下被调用，返回的迭代器用于获取要迭代的值。 一些内置类型拥有默认的迭代器行为，其他类型（如 Object）则没有。下表中的内置类型拥有默认的@@iterator方法： Array.prototype@@iterator TypedArray.prototype@@iterator String.prototype@@iterator Map.prototype@@iterator Set.prototype@@iterator 作用 各种数据结构提供一个统一的、简便的访问接口； 使数据结构成员能够按某种次序排列； ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费 示例 自定义迭代器我们可以像下面这样创建自定义的迭代器： 1234567var myIterable = &#123;&#125;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] 不符合标准的迭代器如果一个迭代器 @@iterator 没有返回一个迭代器对象，那么它就是一个不符合标准的迭代器，这样的迭代器将会在运行期抛出异常，甚至非常诡异的 Bug。 123var nonWellFormedIterable = &#123;&#125;nonWellFormedIterable[Symbol.iterator] = () =&gt; 1[...nonWellFormedIterable] // TypeError: [] is not a function 就拿 for…of 语句来说，它首先调用被遍历对象的 Symbol.iterator 方法，该方法返回一个迭代器对象，迭代器对象可以是拥有 next 方法的任何对象。然后， 在 for…of 的每一次循环中，都将调用该迭代器对象上的 next 方法。每一次调用 next 方法，都会返回数据结构的当前成员信息。具体来说就是返回一个包含 value 和 done 两个属性的对象。其中 value 是当前成员的值，done 是一 个布尔值，表示遍历是否结束。 下面的代码实现了一个简单的迭代器对象： 12345678910111213141516171819202122232425262728var sampleIterator = &#123; index: 0, [Symbol.iterator]: function() &#123; return this &#125;, next: function() &#123; if (this.index &lt; 3) &#123; return &#123; done: false, value: this.index++ &#125; &#125; else &#123; return &#123; done: true, value: undefined &#125; &#125; &#125;&#125;for (var val of sampleIterator) &#123; console.log(val)&#125;// 结果为：// 0// 1// 2// [Finished in 2.7s] 上面的代码中，当使用 for…of 遍历 sampleIterator 时，首先调用了该对象的 [Symool.itirator] 方法，该方法返回对象本身。而该对象中包含有 next 方法，所以该对象本身就是一个 Iterator对象。可以供 for..of消费。当 this.index &gt;= 3 时，返回 {done: true, value: undefined}, 循环结束。 数据结构的默认 Iterator 接口 Iterator 接口的目的，就是为所有的数据结构提供一种统一的访问机制，即 for...of 循环。当使用 for…of 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 ES6 规定，默认的 Iterator 接口就部署在数据结构的 Symbol.iterator 属性。调用该方法，就会得到当前数据结构默认的迭代器生成函数。 ES6 中，有三类数据结构原生具备 Iterator 接口：数组、类似数组的对象（如 NodeList ）、Set 和 Map 结构。 12345678910111213let arr = [1, 2, 4]// 迭代器接口部署在数组的 `Symbol.iterator` 属性上，调用该属性就可以得到迭代器对象（一个包含 next 函数的对象）var iterator = arr[Symbol.iterator]()console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())// 输出结果：// &#123; value: 1, done: false &#125;// &#123; value: 2, done: false &#125;// &#123; value: 4, done: false &#125;// &#123; value: undefined, done: true &#125;// [Finished in 2.6s] 类似数组的对象（存在数值键名和 length 属性），可以直接在 Symbol.iterator 属性上部署数组的 Iterator 接口： 12345678910111213141516171819202122232425262728let iterable = &#123; 0: 'a', 1: 'b', 2: 'c', 3: 'd', length: 4,&#125;for (var item of iterable) &#123; console.log(item)&#125;// 输出结果：// a// b// c// d// [Finished in 2.6 s]// 如果 iterable 的 length 属性为 3：// a// b// c// [Finished in 2.7s]// 如果 iterable 的 length 属性为 5：// a// b// c// d// undefined// [Finished in 2.7s] 注：普通对象部署数组的 Symbol.iterator 方法，并没有效果。如果 Symbol.iterator 方法对应的不是遍历器生成函数，解释引擎会报错。 调用 Iterator 接口的场合除了 for…of 循环，还有几个场合会默认调用 Iterator 接口（即 Symbol.iterator). 解构赋值 扩展运算符 yield* 由于数组遍历调用迭代器接口，所以任何接受数组作为参数的场合，其实都调用了 Iterator 接口： for…of Array.from() Map(), Set(), WeakMap(), WeakSet() Promise.all() Promise.race() …]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数]]></title>
    <url>%2F2017%2F12%2F31%2Fjian-tou-han-shu%2F</url>
    <content type="text"><![CDATA[箭头函数 箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数，并且它们不能用作构造函数。 语法 123456789101112基础语法(参数1, 参数2, …, 参数N) =&gt; &#123;函数声明&#125;(参数1, 参数2, …, 参数N) =&gt; 表达式（单一）//相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return表达式&#125;// 当只有一个参数时，圆括号是可选的：(单一参数) =&gt; &#123;函数声明&#125;单一参数 =&gt; &#123;函数声明&#125;// 没有参数的函数应该写成一对圆括号。() =&gt; &#123;函数声明&#125; 高级语法 12345678910//加括号的函数体返回对象字面表达式：参数=&gt; (&#123;foo: bar&#125;)//支持剩余参数和默认参数(参数1, 参数2, ...rest) =&gt; &#123;函数声明&#125;(参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; &#123;函数声明&#125;//同样支持参数列表解构let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;f(); // 6 描述 引入箭头函数有两个方面的作用：更简短的函数并且不绑定this。 更短的函数 123456789101112131415var materials = [ 'Hydrogen', 'Helium', 'Lithium', 'Beryllium'];materials.map(function(material) &#123; return material.length; &#125;); // [8, 6, 7, 9]materials.map((material) =&gt; &#123; return material.length;&#125;); // [8, 6, 7, 9]materials.map(material =&gt; material.length); // [8, 6, 7, 9] 不绑定this 在箭头函数出现之前，每个新定义的函数都有它自己的 this值（在构造函数的情况下是一个新对象，在严格模式的函数调用中为 undefined，如果该函数被称为“对象方法”则为基础对象等）。This被证明是令人厌烦的面向对象风格的编程。 123456789101112function Person() &#123; // Person() 构造函数定义 `this`作为它自己的实例. this.age = 0; setInterval(function growUp() &#123; // 在非严格模式, growUp()函数定义 `this`作为全局对象, // 与在 Person()构造函数中定义的 `this`并不相同. this.age++; &#125;, 1000);&#125;var p = new Person(); 在ECMAScript 3/5中，通过将this值分配给封闭的变量，可以解决this问题。 123456789function Person() &#123; var that = this; that.age = 0; setInterval(function growUp() &#123; // 回调引用的是`that`变量, 其值是预期的对象. that.age++; &#125;, 1000);&#125; 或者，可以创建绑定函数，以便将预先分配的this值传递到绑定的目标函数（上述示例中的growUp()函数）。 箭头功能不会创建自己的this；它使用封闭执行上下文的this值。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同： 123456789function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; // |this| 正确地指向person 对象 &#125;, 1000);&#125;var p = new Person(); 与严格模式的关系鉴于 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。 12var f = () =&gt; &#123;'use strict'; return this&#125;;f() === window; // 或全局对象 严格模式的其他规则依然不变. 通过 call 或 apply 调用由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并没有什么影响： 1234567891011121314151617181920var adder = &#123; base : 1, add : function(a) &#123; var f = v =&gt; v + this.base; return f(a); &#125;, addThruCall: function(a) &#123; var f = v =&gt; v + this.base; var b = &#123; base : 2 &#125;; return f.call(b, a); &#125;&#125;;console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注） 不绑定arguments箭头函数不绑定Arguments 对象。因此，在本示例中，参数只是在封闭范围内引用相同的名称： 123456789101112var arguments = 42;var arr = () =&gt; arguments;arr(); // 42function foo() &#123; var f = (i) =&gt; arguments[0]+i; // 此处的argument为foo的arguments // foo函数的间接参数绑定 return f(2);&#125;foo(1); // 3 在大多数情况下，使用剩余参数是使用arguments对象的好选择。 1234567function foo() &#123; var f = (...args) =&gt; args[0]; return f(2); &#125;foo(1); // 2 像方法一样使用箭头函数如上所述，箭头函数表达式对非方法函数是最合适的。让我们看看当我们试着把它们作为方法时发生了什么。 123456789101112'use strict';var obj = &#123; i: 10, b: () =&gt; console.log(this.i, this), c: function() &#123; console.log( this.i, this) &#125;&#125;obj.b(); // undefinedobj.c(); // 10, Object &#123;...&#125; 箭头函数没有定义this绑定。另一个涉及Object.defineProperty()的示例： 123456789101112'use strict';var obj = &#123; a: 10&#125;;Object.defineProperty(obj, "b", &#123; get: () =&gt; &#123; console.log(this.a, typeof this.a, this); return this.a+10; // 代表全局对象 'Window', 因此 'this.a' 返回 'undefined' &#125;&#125;); 使用 new 操作符箭头函数不能用作构造器，和 new一起用会抛出错误。 12var Foo = () =&gt; &#123;&#125;;var foo = new Foo(); // TypeError: Foo is not a constructor 使用prototype属性箭头函数没有prototype属性。 12var Foo = () =&gt; &#123;&#125;;console.log(Foo.prototype); // undefined 使用 yield 关键字 yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。 函数体箭头功能可以有一个“简写体”或常见的“块体”。 在一个简写体中，只需要一个表达式，并附加一个隐式的返回值。在块体中，必须使用明确的return语句。 12345var func = x =&gt; x * x; // 简写函数 省略returnvar func = (x, y) =&gt; &#123; return x + y; &#125;; //常规编写 明确的返回值 返回对象字面量记住用params =&gt; {object:literal}这种简单的语法返回对象字面量是行不通的。 12345var func = () =&gt; &#123; foo: 1 &#125;; // Calling func() returns undefined!var func = () =&gt; &#123; foo: function() &#123;&#125; &#125;; // SyntaxError: function statement requires a name 这是因为花括号（{} ）里面的代码被解析为一系列语句（即 foo 被认为是一个标签，而非对象字面量的组成部分）。 所以，记得用圆括号把对象字面量包起来： 1var func = () =&gt; (&#123;foo: 1&#125;); 换行箭头函数在参数和箭头之间不能换行。 123var func = () =&gt; 1; // SyntaxError: expected expression, got '=&gt;' 解析顺序虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。 12345678let callback;callback = callback || function() &#123;&#125;; // okcallback = callback || () =&gt; &#123;&#125;; // SyntaxError: invalid arrow-function argumentscallback = callback || (() =&gt; &#123;&#125;); // ok 更多示例 123456789101112131415161718192021222324252627282930313233343536373839404142// 空的箭头函数返回 undefinedlet empty = () =&gt; &#123;&#125;;(() =&gt; 'foobar')(); // Returns "foobar"// (这是一个立即执行函数表达式,可参阅 'IIFE'术语表) var simple = a =&gt; a &gt; 15 ? 15 : a; simple(16); // 15simple(10); // 10let max = (a, b) =&gt; a &gt; b ? a : b;// Easy array filtering, mapping, ...var arr = [5, 6, 13, 0, 1, 18, 23];var sum = arr.reduce((a, b) =&gt; a + b); // 66var even = arr.filter(v =&gt; v % 2 == 0); // [6, 0, 18]var double = arr.map(v =&gt; v * 2); // [10, 12, 26, 0, 2, 36, 46]// 更简明的promise链promise.then(a =&gt; &#123; // ...&#125;).then(b =&gt; &#123; // ...&#125;);// 无参数箭头函数在视觉上容易分析setTimeout( () =&gt; &#123; console.log('I happen sooner'); setTimeout( () =&gt; &#123; // deeper code console.log('I happen later'); &#125;, 1);&#125;, 1); 箭头函数也可以使用条件（三元）运算符： 12345var simple = a =&gt; a &gt; 15 ? 15 : a;simple(16); // 15simple(10); // 10let max = (a, b) =&gt; a &gt; b ? a : b; 箭头函数内定义的变量及其作用域 12345678910111213141516171819// 常规写法var greeting = () =&gt; &#123;let now = new Date(); return ("Good" + ((now.getHours() &gt; 17) ? " evening." : " day."));&#125;greeting(); //"Good day."console.log(now); // ReferenceError: now is not defined 标准的let作用域// 参数括号内定义的变量是局部变量（默认参数）var greeting = (now=new Date()) =&gt; "Good" + (now.getHours() &gt; 17 ? " evening." : " day.");greeting(); //"Good day."console.log(now); // ReferenceError: now is not defined// 对比：函数体内&#123;&#125;不使用var定义的变量是全局变量var greeting = () =&gt; &#123;now = new Date(); return ("Good" + ((now.getHours() &gt; 17) ? " evening." : " day."));&#125;greeting(); //"Good day."console.log(now); // Fri Dec 22 2017 10:01:00 GMT+0800 (中国标准时间)// 对比：函数体内&#123;&#125; 用var定义的变量是局部变量var greeting = () =&gt; &#123;var now = new Date(); return ("Good" + ((now.getHours() &gt; 17) ? " evening." : " day."));&#125;greeting(); //"Good day."console.log(now); // ReferenceError: now is not defined 箭头函数也可以使用闭包： 123456789101112131415161718192021// 标准的闭包函数function A()&#123; var i=0; return function b()&#123; return (++i); &#125;;&#125;;var v=A();v(); //1v(); //2//箭头函数体的闭包（ i=0 是默认参数）var Add = (i=0) =&gt; &#123;return (() =&gt; (++i) )&#125;;var v = Add();v(); //1v(); //2//因为仅有一个返回，return 及括号（）也可以省略var Add = (i=0)=&gt; ()=&gt; (++i); 箭头函数递归 12var fact = (x) =&gt; ( x==0 ? 1 : x*fact(x-1) );fact(5); // 120 浏览器兼容]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for-of详解]]></title>
    <url>%2F2017%2F12%2F30%2Ffor...of%2F</url>
    <content type="text"><![CDATA[for-of for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。 语法123for (variable of iterable) &#123; //statements&#125; variable在每次迭代中，将不同属性的值分配给变量。 iterable可枚举其枚举属性的对象。 推荐在循环对象属性的时候，使用for…in,在遍历数组的时候的时候使用for…of。 for…in循环出的是key，for…of循环出的是value。for…of修复了for…in的缺陷和不足，假设我们往数组添加一个属性name:aArray.name = ‘demo’,再分别查看上面写的两个循环： 123456for(let index in aArray)&#123; console.log(`$&#123;aArray[index]&#125;`); //aArray.name会也被循环出来了，得到的数组的值的顺序也会被打乱&#125;for(var value of aArray)&#123; console.log(value);&#125; 所以说，作用于数组的for-in循环除了遍历数组元素以外,还会遍历自定义属性。 for…of循环不会循环对象的key，只会循环出数组的value，因此for…of不能循环遍历普通对象,对普通对象的属性遍历推荐使用for…in 如果实在想用for…of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组：然后遍历：12345678910111213var student=&#123; name:'wujunchuan', age:22, locate:&#123; country:'china', city:'xiamen', school:'XMUT' &#125;&#125;for(var key of Object.keys(student))&#123; //先获取studentkey的数组，循环数组再得到对象值，基本上是多此一举 //使用Object.keys()方法获取对象key的数组 console.log(key+": "+student[key]);&#125; for…of不能循环普通的对象，需要通过和Object.keys()搭配使用 123456789101112131415161718// for...in循环可以遍历键名，for...of循环会报错。var es6 = &#123; edition: 6, committee: "TC39", standard: "ECMA-262"&#125;;for (e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (e of es6) &#123; console.log(e);&#125;// TypeError: es6 is not iterable 与forEach()不同的是，它可以正确响应break、continue和return语句,forEach循环会简洁很多，但是不能break、continue、return 1234var a = ["a", "b", "c"];a.forEach(function(element) &#123; console.log(element);&#125;); for…of现在浏览器的支持成都还不是很好 示例 迭代Array 123456789let iterable = [10, 20, 30];for (let value of iterable) &#123; value += 1; console.log(value);&#125;// 11// 21// 31 如果你不想修改语句块中的变量 , 也可以使用const代替let。 12345678let iterable = [10, 20, 30];for (const value of iterable) &#123; console.log(value);&#125;// 10// 20// 30 迭代String 12345678let iterable = "boo";for (let value of iterable) &#123; console.log(value);&#125;// "b"// "o"// "o" 迭代 TypedArray 1234567let iterable = new Uint8Array([0x00, 0xff]);for (let value of iterable) &#123; console.log(value);&#125;// 0// 255 迭代Map 123456789101112131415let iterable = new Map([["a", 1], ["b", 2], ["c", 3]]);for (let entry of iterable) &#123; console.log(entry);&#125;// ["a", 1]// ["b", 2]// ["c", 3]for (let [key, value] of iterable) &#123; console.log(value);&#125;// 1// 2// 3 迭代 Set 12345678let iterable = new Set([1, 1, 2, 2, 3, 3]);for (let value of iterable) &#123; console.log(value);&#125;// 1// 2// 3 迭代 arguments 对象 123456789(function() &#123; for (let argument of arguments) &#123; console.log(argument); &#125;&#125;)(1, 2, 3);// 1// 2// 3 迭代 DOM 集合迭代 DOM 元素集合，比如一个NodeList对象：下面的例子演示给每一个 article 标签内的 p 标签添加一个 “read” 类。 123456//注意：这只能在实现了NodeList.prototype[Symbol.iterator]的平台上运行let articleParagraphs = document.querySelectorAll("article &gt; p");for (let paragraph of articleParagraphs) &#123; paragraph.classList.add("read");&#125; 关闭迭代器对于for…of的循环，可以由break, continue[4], throw 或return[5]终止。在这些情况下，迭代器关闭。 12345678910function* foo()&#123; yield 1; yield 2; yield 3; &#125;; for (let o of foo()) &#123; console.log(o); break; // closes iterator, triggers return&#125; 迭代生成器你还可以迭代一个生成器： 1234567891011121314function* fibonacci() &#123; // 一个生成器函数 let [prev, curr] = [0, 1]; for (;;) &#123; // while (true) &#123; [prev, curr] = [curr, prev + curr]; yield curr; &#125;&#125; for (let n of fibonacci()) &#123; console.log(n); // 当n大于1000时跳出循环 if (n &gt;= 1000) break;&#125; 不要重用生成器生成器不应该重用，即使for…of循环的提前终止，例如通过break关键字。在退出循环后，生成器关闭，并尝试再次迭代，不会产生任何进一步的结果。 1234567891011121314var gen = (function *()&#123; yield 1; yield 2; yield 3;&#125;)();for (let o of gen) &#123; console.log(o); break;//关闭生成器&#125; //生成器不应该重用，以下没有意义！for (let o of gen) &#123; console.log(o);&#125; 迭代其他可迭代对象你还可以迭代显式实现可迭代协议的对象： 123456789101112131415161718192021var iterable = &#123; [Symbol.iterator]() &#123; return &#123; i: 0, next() &#123; if (this.i &lt; 3) &#123; return &#123; value: this.i++, done: false &#125;; &#125; return &#123; value: undefined, done: true &#125;; &#125; &#125;; &#125;&#125;;for (var value of iterable) &#123; console.log(value);&#125;// 0// 1// 2 for…of与for…in的区别无论是for…in还是for…of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。 for…in 语句以原始插入顺序迭代对象的可枚举属性。 for…of 语句遍历可迭代对象定义要迭代的数据。 以下示例显示了与Array一起使用时，for…of循环和for…in循环之间的区别。 123456789101112131415161718192021222324Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;;let iterable = [3, 5, 7];iterable.foo = 'hello';for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"&#125;for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // logs 0, 1, 2, "foo" &#125;&#125;for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7&#125;Object.prototype.objCustom = function() &#123;&#125;;Array.prototype.arrCustom = function() &#123;&#125;; let iterable = [3, 5, 7]; iterable.foo = 'hello'; 每个对象将继承objCustom属性，并且作为Array的每个对象将继承arrCustom属性，因为将这些属性添加到Object.prototype和Array.prototype。由于继承和原型链，对象iterable继承属性objCustom和arrCustom。 123for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom" &#125; 此循环仅以原始插入顺序记录iterable 对象的可枚举属性。它不记录数组元素3, 5, 7 或hello，因为这些不是枚举属性。但是它记录了数组索引以及arrCustom和objCustom。如果你不知道为什么这些属性被迭代，array iteration and for…in中有更多解释。 12345for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // logs 0, 1, 2, "foo" &#125;&#125; 这个循环类似于第一个，但是它使用hasOwnProperty() 来检查，如果找到的枚举属性是对象自己的（不是继承的）。如果是，该属性被记录。记录的属性是0, 1, 2和foo，因为它们是自身的属性（不是继承的）。属性arrCustom和objCustom不会被记录，因为它们是继承的。 123for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7 &#125; 该循环迭代并记录iterable作为可迭代对象定义的迭代值，这些是数组元素 3, 5, 7，而不是任何对象的属性。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MJExtension使用指导]]></title>
    <url>%2F2017%2F12%2F27%2FMJExtension%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[转载：https://www.jianshu.com/p/475b28160c89 1、简单的字典 –&gt; 模型:核心代码 mj_objectWithKeyValues123456789101112131415161718192021222324252627typedef enum &#123; SexMale, SexFemale&#125; Sex;@interface User : NSObject@property (copy, nonatomic) NSString *name;/* 姓名 */@property (copy, nonatomic) NSString *icon;/* 头像 */@property (assign, nonatomic) unsigned int age;/* 年龄 */@property (copy, nonatomic) NSString *height;/* 身高 */@property (strong, nonatomic) NSNumber *money;/* 资产 */@property (assign, nonatomic) Sex sex;/* 性别 */@property (assign, nonatomic, getter=isGay) BOOL gay;/* 是否是同性恋 */@end //简单的字典 NSDictionary *dict_user = @&#123; @&quot;name&quot; : @&quot;Jack&quot;, @&quot;icon&quot; : @&quot;lufy.png&quot;, @&quot;age&quot; : @20, @&quot;height&quot; : @&quot;1.55&quot;, @&quot;money&quot; : @100.9, @&quot;sex&quot; : @(SexFemale),/* 枚举需要使用NSNumber包装 */ @&quot;gay&quot; : @YES &#125;; User *user = [User mj_objectWithKeyValues:dict_user]; NSLog(@&quot;MJ---%@----%@---%u---%@---%@---%u----%d&quot;,user.name,user.icon,user.age,user.height,user.money,user.sex,user.gay); //打印结果 //2016-07-04 11:06:59.746 PPDemos[2432:73824] MJ---Jack----lufy.png---20---1.55---100.9---1----1 2、JSON字符串 –&gt; 模型核心代码：mj_objectWithKeyValues:123456// 定义一个JSON字符串 NSString *jsonStr = @&quot;&#123;\&quot;name\&quot;:\&quot;Jack\&quot;, \&quot;icon\&quot;:\&quot;lufy.png\&quot;, \&quot;age\&quot;:20&#125;&quot;; User *user = [User mj_objectWithKeyValues:jsonStr]; NSLog(@&quot;MJ---%@----%@---%u&quot;,user.name,user.icon,user.age); //打印结果 //2016-07-04 11:16:04.655 PPDemos[2563:78561] MJ---Jack----lufy.png---20 3、复杂的字典 –&gt; 模型 (模型里面包含了模型)核心代码 mj_objectWithKeyValues:123456789101112131415//复杂的字典[模型中有个数组属性，数组里面又要装着其他模型的字典] NSDictionary *dict_m8m = @&#123; @&quot;text&quot; : @&quot;Agree!Nice weather!&quot;, @&quot;user&quot; : @&#123; @&quot;name&quot; : @&quot;Jack&quot;, @&quot;icon&quot; : @&quot;lufy.png&quot; &#125;, @&quot;retweetedStatus&quot; : @&#123; @&quot;text&quot; : @&quot;Nice weather!&quot;, @&quot;user&quot; : @&#123; @&quot;name&quot; : @&quot;Rose&quot;, @&quot;icon&quot; : @&quot;nami.png&quot; &#125; &#125; &#125;; 12345678910#import &lt;Foundation/Foundation.h&gt;@class User;@class Status;//Status模型@interface Status : NSObject@property (copy, nonatomic) NSString *text;@property (strong, nonatomic) User *user;/* 其他模型类型 */@property (strong, nonatomic) Status *retweetedStatus;/* 自我模型类型 */@end// 1234567891011121314//字典转模型，模型里面含有模型 Status *status = [Status mj_objectWithKeyValues:dict_m8m]; NSString *text = status.text; NSString *name = status.user.name; NSString *icon = status.user.icon; NSLog(@&quot;mj-----text=%@, name=%@, icon=%@&quot;, text, name, icon); NSString *text2 = status.retweetedStatus.text; NSString *name2 = status.retweetedStatus.user.name; NSString *icon2 = status.retweetedStatus.user.icon; NSLog(@&quot;mj-----text2=%@, name2=%@, icon2=%@&quot;, text2, name2, icon2); // //打印结果 //2016-07-04 11:45:39.675 PPDemos[2781:87089] mj-----text=Agree!Nice weather!, name=Jack, icon=lufy.png //2016-07-04 11:45:39.675 PPDemos[2781:87089] mj-----text2=Nice weather!, name2=Rose, icon2=nami.png 4、模型中有个数组属性，数组里面又要装着其它模型核心代码 mj_objectWithKeyValues和mj_objectClassInArray: 1234@interface Ad : NSObject @property (copy, nonatomic) NSString *image; @property (copy, nonatomic) NSString *url;@end 1234567@interface StatusResult : NSObject/** 存放着一堆的微博数据（里面都是Status模型） */@property (strong, nonatomic) NSMutableArray *statuses;/** 存放着一堆的广告数据（里面都是Ad模型） */@property (strong, nonatomic) NSArray *ads;@property (strong, nonatomic) NSNumber *totalNumber;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#import &quot;StatusResult.h&quot;#import &quot;MJExtension.h&quot;@implementation StatusResult/* 数组中存储模型数据，需要说明数组中存储的模型数据类型 */+(NSDictionary *)mj_objectClassInArray&#123; return @&#123; @&quot;statuses&quot; : @&quot;Status&quot;, @&quot;ads&quot; : @&quot;Ad&quot; &#125;;&#125;@end#####在VC里实现以下来解析数据NSDictionry dict_m8a = @&#123; @&quot;statuses&quot; : @[ @&#123; @&quot;text&quot; : @&quot;Nice weather!&quot;, @&quot;user&quot; : @&#123; @&quot;name&quot; : @&quot;Rose&quot;, @&quot;icon&quot; : @&quot;nami.png&quot; &#125; &#125;, @&#123; @&quot;text&quot; : @&quot;Go camping tomorrow!&quot;, @&quot;user&quot; : @&#123; @&quot;name&quot; : @&quot;Jack&quot;, @&quot;icon&quot; : @&quot;lufy.png&quot; &#125; &#125; ], @&quot;ads&quot;: @[ @&#123; @&quot;image&quot; : @&quot;ad01.png&quot;, @&quot;url&quot; : @&quot;http://www.ad01.com&quot; &#125;, @&#123; @&quot;image&quot; : @&quot;ad02.png&quot;, @&quot;url&quot; : @&quot;http://www.ad02.com&quot; &#125; ], @&quot;totalNumber&quot; : @&quot;2014&quot; &#125;;//【重点，核心】》》数组中存储模型数据，需要说明数组中存储的模型数据类型 [StatusResult mj_setupObjectClassInArray:^NSDictionary *&#123; return @&#123; @&quot;statuses&quot; : @&quot;Status&quot;, // @&quot;statuses&quot; : [Status class], @&quot;ads&quot; : @&quot;Ad&quot; // @&quot;ads&quot; : [Ad class] &#125;;&#125;];// Equals: StatusResult.m implements + mj_objectClassInArray method.//以上方法在VC里写，如果多个地方解析该model，就要写多次，最好在model的.m文件写！//字典转模型，支持模型的数组属性里面又装着模型StatusResult *result = [StatusResult mj_objectWithKeyValues:dict_m8a];//打印博主信息for (Status *status in result.statuses) &#123; NSString *text = status.text; NSString *name = status.user.name; NSString *icon = status.user.icon; NSLog(@&quot;mj---text=%@, name=%@, icon=%@&quot;, text, name, icon);&#125;//打印广告for (Ad *ad in result.ads) &#123; NSLog(@&quot;mj---image=%@, url=%@&quot;, ad.image, ad.url);&#125;//打印结果//2016-07-04 13:47:58.994 PPDemos[3353:113055] mj---text=Nice weather!, name=Rose, icon=nami.png//2016-07-04 13:47:58.995 PPDemos[3353:113055] mj---text=Go camping tomorrow!, name=Jack, icon=lufy.png//2016-07-04 13:47:58.995 PPDemos[3353:113055] mj---image=ad01.png, url=http://www.ad01.com//2016-07-04 13:47:58.995 PPDemos[3353:113055] mj---image=ad02.png, url=http://www.ad02.com 5、模型中的属性名和字典中的key不相同(或者需要多级映射)核心代码： mj_objectWithKeyValues:和mj_replacedKeyFromPropertyName： 多级映射，用点语法设置1234@interface Bag : NSObject @property (copy, nonatomic) NSString *name; @property (assign, nonatomic) double price;@end 12345678910import &lt;Foundation/Foundation.h&gt;@class Bag;@interface Student : NSObject @property (copy, nonatomic) NSString *ID; @property (copy, nonatomic) NSString *desc; @property (copy, nonatomic) NSString *nowName; @property (copy, nonatomic) NSString *oldName; @property (copy, nonatomic) NSString *nameChangedTime; @property (strong, nonatomic) Bag *bag;@end 1234567891011121314@implementation Student+(NSDictionary *)mj_replacedKeyFromPropertyName&#123;// 实现这个方法的目的：告诉MJExtension框架模型中的属性名对应着字典的哪个key return @&#123; @&quot;ID&quot; : @&quot;id&quot;, @&quot;desc&quot; : @&quot;desciption&quot;, @&quot;oldName&quot; : @&quot;name.oldName&quot;, @&quot;nowName&quot; : @&quot;name.newName&quot;, @&quot;nameChangedTime&quot; : @&quot;name.info[1].nameChangedTime&quot;, @&quot;bag&quot; : @&quot;other.bag&quot; &#125;;&#125;@end 12345678910111213141516171819202122NSDictionry *dict_nokey = @&#123; @&quot;id&quot; : @&quot;20&quot;, @&quot;desciption&quot; : @&quot;kids&quot;, @&quot;name&quot; : @&#123; @&quot;newName&quot; : @&quot;lufy&quot;, @&quot;oldName&quot; : @&quot;kitty&quot;, @&quot;info&quot; : @[ @&quot;test-data&quot;, @&#123; @&quot;nameChangedTime&quot; : @&quot;2013-08&quot; &#125; ] &#125;, @&quot;other&quot; : @&#123; @&quot;bag&quot; : @&#123; @&quot;name&quot; : @&quot;a red bag&quot;, @&quot;price&quot; : @100.7 &#125; &#125;&#125;; 123456789101112131415161718192021//// // How to map// [Student mj_setupReplacedKeyFromPropertyName:^NSDictionary *&#123; // return @&#123; // @&quot;ID&quot; : @&quot;id&quot;, // @&quot;desc&quot; : @&quot;desciption&quot;, // @&quot;oldName&quot; : @&quot;name.oldName&quot;, // @&quot;nowName&quot; : @&quot;name.newName&quot;, // @&quot;nameChangedTime&quot; : @&quot;name.info[1].nameChangedTime&quot;, // @&quot;bag&quot; : @&quot;other.bag&quot; // &#125;;// &#125;];// // Equals: Student.m implements +mj_replacedKeyFromPropertyName method.//字典转模型，支持多级映射Student *stu = [Student mj_objectWithKeyValues:dict_nokey];//打印NSLog(@&quot;ID=%@, desc=%@, oldName=%@, nowName=%@, nameChangedTime=%@&quot;,stu.ID, stu.desc, stu.oldName, stu.nowName, stu.nameChangedTime);NSLog(@&quot;bagName=%@, bagPrice=%f&quot;, stu.bag.name, stu.bag.price);//2016-07-04 14:20:28.082 PPDemos[3602:126004] ID=20, desc=kids, oldName=kitty, nowName=lufy, nameChangedTime=2013-08//2016-07-04 14:20:28.082 PPDemos[3602:126004] bagName=a red bag, bagPrice=100.700000 6.将一个字典数组转成模型数组 核心代码mj_objectArrayWithKeyValuesArray: 123456789101112131415161718NSArray *dictArray = @[ @&#123; @&quot;name&quot; : @&quot;Jack&quot;, @&quot;icon&quot; : @&quot;lufy.png&quot; &#125;, @&#123; @&quot;name&quot; : @&quot;Rose&quot;, @&quot;icon&quot; : @&quot;nami.png&quot; &#125;];//字典数组转模型数组，使用的是mj_objectArrayWithKeyValuesArray:方法NSArray *userArray = [User mj_objectArrayWithKeyValuesArray:dictArray];//打印for (User *user in userArray) &#123; NSLog(@&quot;name=%@, icon=%@&quot;, user.name, user.icon);&#125;// name=Jack, icon=lufy.png// name=Rose, icon=nami.png 7、 将一个模型转成字典核心代码mj_keyValues：12345678910111213141516171819User *user = [[User alloc] init];user.name = @&quot;Jack&quot;;user.icon = @&quot;lufy.png&quot;;//Status *status = [[Status alloc] init];status.user = user;status.text = @&quot;Nice mood!&quot;;////模型转字典，使用的是mj_keyValues属性NSDictionary *statusDict = status.mj_keyValues;NSLog(@&quot;%@&quot;, statusDict);/* &#123; text = &quot;Nice mood!&quot;; user = &#123; icon = &quot;lufy.png&quot;; name = Jack; &#125;; &#125; 8、将一个模型数组转成字典数组核心代码mj_keyValuesArrayWithObjectArray： 1234567891011121314151617181920212223242526//创建模型数组 User *user1 = [[User alloc] init]; user1.name = @&quot;Jack&quot;; user1.icon = @&quot;lufy.png&quot;; User *user2 = [[User alloc] init]; user2.name = @&quot;Rose&quot;; user2.icon = @&quot;nami.png&quot;; NSArray *userArray = @[user1, user2]; //模型数组转字典数组，使用的是mj_keyValuesArrayWithObjectArray:方法 NSArray *dictArray = [User mj_keyValuesArrayWithObjectArray:userArray]; NSLog(@&quot;%@&quot;, dictArray); /* ( &#123; icon = &quot;lufy.png&quot;; name = Jack; &#125;, &#123; icon = &quot;nami.png&quot;; name = Rose; &#125; ) */ 更多用法 参考NSObject+MJKeyValue.h 参考NSObject+MJCoding.h]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
</search>
